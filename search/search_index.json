{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CMDx","text":"<p>Build business logic that's powerful, predictable, and maintainable.</p> <p> </p> <p>Say goodbye to messy service objects. CMDx helps you design business logic with clarity and consistency\u2014build faster, debug easier, and ship with confidence.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>gem install cmdx\n# - or -\nbundle add cmdx\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Build powerful business logic in four simple steps:</p>"},{"location":"#1-compose","title":"1. Compose","text":"Full Featured TaskMinimum Viable Task <pre><code>class AnalyzeMetrics &lt; CMDx::Task\n  register :middleware, CMDx::Middlewares::Correlate, id: -&gt; { Current.request_id }\n\n  on_success :track_analysis_completion!\n\n  required :dataset_id, type: :integer, numeric: { min: 1 }\n  optional :analysis_type, default: \"standard\"\n\n  def work\n    if dataset.nil?\n      fail!(\"Dataset not found\", code: 404)\n    elsif dataset.unprocessed?\n      skip!(\"Dataset not ready for analysis\")\n    else\n      context.result = PValueAnalyzer.execute(dataset:, analysis_type:)\n      context.analyzed_at = Time.now\n\n      SendAnalyzedEmail.execute(user_id: Current.account.manager_id)\n    end\n  end\n\n  private\n\n  def dataset\n    @dataset ||= Dataset.find_by(id: dataset_id)\n  end\n\n  def track_analysis_completion!\n    dataset.update!(analysis_result_id: context.result.id)\n  end\nend\n</code></pre> <pre><code>class SendAnalyzedEmail &lt; CMDx::Task\n  def work\n    user = User.find(context.user_id)\n    MetricsMailer.analyzed(user).deliver_now\n  end\nend\n</code></pre>"},{"location":"#2-execute","title":"2. Execute","text":"<pre><code>result = AnalyzeMetrics.execute(\n  dataset_id: 123,\n  \"analysis_type\" =&gt; \"advanced\"\n)\n</code></pre>"},{"location":"#3-react","title":"3. React","text":"<pre><code>if result.success?\n  puts \"Metrics analyzed at #{result.context.analyzed_at}\"\nelsif result.skipped?\n  puts \"Skipping analyzation due to: #{result.reason}\"\nelsif result.failed?\n  puts \"Analyzation failed due to: #{result.reason} with code #{result.metadata[:code]}\"\nend\n</code></pre>"},{"location":"#4-observe","title":"4. Observe","text":"<pre><code>I, [2022-07-17T18:42:37.000000 #3784] INFO -- CMDx:\nindex=1 chain_id=\"018c2b95-23j4-2kj3-32kj-3n4jk3n4jknf\" type=\"Task\" class=\"SendAnalyzedEmail\" state=\"complete\" status=\"success\" metadata={runtime: 347}\n\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"AnalyzeMetrics\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n</code></pre> <p>Ready to dive in? Check out the Getting Started guide to learn more.</p>"},{"location":"#ecosystem","title":"Ecosystem","text":"<ul> <li>cmdx-rspec - RSpec test matchers</li> </ul> <p>For backwards compatibility of certain functionality:</p> <ul> <li>cmdx-i18n - 85+ translations, <code>v1.5.0</code> - <code>v1.6.2</code></li> <li>cmdx-parallel - Parallel workflow tasks, <code>v1.6.1</code> - <code>v1.6.2</code></li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Bug reports and pull requests are welcome at https://github.com/drexed/cmdx. We're committed to fostering a welcoming, collaborative community. Please follow our code of conduct.</p>"},{"location":"#license","title":"License","text":"<p>The gem is available as open source under the terms of the MIT License.</p>"},{"location":"callbacks/","title":"Callbacks","text":"<p>Run custom logic at specific points during task execution. Callbacks have full access to task context and results, making them perfect for logging, notifications, cleanup, and more.</p> <p>See Global Configuration for framework-wide callback setup.</p> <p>Important</p> <p>Callbacks execute in declaration order (FIFO). Multiple callbacks of the same type run sequentially.</p>"},{"location":"callbacks/#available-callbacks","title":"Available Callbacks","text":"<p>Callbacks execute in a predictable lifecycle order:</p> <pre><code>1. before_validation           # Pre-validation setup\n2. before_execution            # Prepare for execution\n\n# --- Task#work executes ---\n\n3. on_[complete|interrupted]   # State-based (execution lifecycle)\n4. on_executed                 # Always runs after work completes\n5. on_[success|skipped|failed] # Status-based (business outcome)\n6. on_[good|bad]               # Outcome-based (success/skip vs fail)\n</code></pre>"},{"location":"callbacks/#declarations","title":"Declarations","text":""},{"location":"callbacks/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for simple callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  before_execution :find_reservation\n\n  # Batch declarations (works for any type)\n  on_complete :notify_guest, :update_availability\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def find_reservation\n    @reservation ||= Reservation.find(context.reservation_id)\n  end\n\n  def notify_guest\n    GuestNotifier.call(context.guest, result)\n  end\n\n  def update_availability\n    AvailabilityService.update(context.room_ids, result)\n  end\nend\n</code></pre>"},{"location":"callbacks/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for inline callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Proc\n  on_interrupted proc { ReservationSystem.pause! }\n\n  # Lambda\n  on_complete -&gt; { ReservationSystem.resume! }\nend\n</code></pre>"},{"location":"callbacks/#class-or-module","title":"Class or Module","text":"<p>Implement reusable callback logic in dedicated classes:</p> <pre><code>class BookingConfirmationCallback\n  def call(task)\n    if task.result.success?\n      MessagingApi.send_confirmation(task.context.guest)\n    else\n      MessagingApi.send_issue_alert(task.context.manager)\n    end\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # Class or Module\n  on_success BookingConfirmationCallback\n\n  # Instance\n  on_interrupted BookingConfirmationCallback.new\nend\n</code></pre>"},{"location":"callbacks/#conditional-execution","title":"Conditional Execution","text":"<p>Control callback execution with conditional logic:</p> <pre><code>class MessagingPermissionCheck\n  def call(task)\n    task.context.guest.can?(:receive_messages)\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # If and/or Unless\n  before_execution :notify_guest, if: :messaging_enabled?, unless: :messaging_blocked?\n\n  # Proc\n  on_failure :increment_failure, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Legacy\") }\n\n  # Lambda\n  on_success :ping_housekeeping, if: proc { context.rooms_need_cleaning? }\n\n  # Class or Module\n  on_complete :send_confirmation, unless: MessagingPermissionCheck\n\n  # Instance\n  on_complete :send_confirmation, if: MessagingPermissionCheck.new\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def messaging_enabled?\n    context.guest.messaging_preference == true\n  end\n\n  def messaging_blocked?\n    context.guest.communication_status == :blocked\n  end\nend\n</code></pre>"},{"location":"callbacks/#callback-removal","title":"Callback Removal","text":"<p>Remove unwanted callbacks dynamically:</p> <p>Important</p> <p>Each <code>deregister</code> call removes one callback. Use multiple calls for batch removals.</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Symbol\n  deregister :callback, :before_execution, :notify_guest\n\n  # Class or Module (no instances)\n  deregister :callback, :on_complete, BookingConfirmationCallback\nend\n</code></pre>"},{"location":"deprecation/","title":"Task Deprecation","text":"<p>Manage legacy tasks gracefully with built-in deprecation support. Choose how to handle deprecated tasks\u2014log warnings for awareness, issue Ruby warnings for development, or prevent execution entirely.</p>"},{"location":"deprecation/#modes","title":"Modes","text":""},{"location":"deprecation/#raise","title":"Raise","text":"<p>Prevent task execution completely. Perfect for tasks that must no longer run.</p> <p>Warning</p> <p>Use <code>:raise</code> mode carefully\u2014it will break existing workflows immediately.</p> <pre><code>class ProcessObsoleteAPI &lt; CMDx::Task\n  settings(deprecated: :raise)\n\n  def work\n    # Will never execute...\n  end\nend\n\nresult = ProcessObsoleteAPI.execute\n#=&gt; raises CMDx::DeprecationError: \"ProcessObsoleteAPI usage prohibited\"\n</code></pre>"},{"location":"deprecation/#log","title":"Log","text":"<p>Allow execution while tracking deprecation in logs. Ideal for gradual migrations.</p> <pre><code>class ProcessLegacyFormat &lt; CMDx::Task\n  settings(deprecated: :log)\n\n  # Same\n  settings(deprecated: true)\n\n  def work\n    # Executes but logs deprecation warning...\n  end\nend\n\nresult = ProcessLegacyFormat.execute\nresult.successful? #=&gt; true\n\n# Deprecation warning appears in logs:\n# WARN -- : DEPRECATED: ProcessLegacyFormat - migrate to replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#warn","title":"Warn","text":"<p>Issue Ruby warnings visible during development and testing. Keeps production logs clean while alerting developers.</p> <pre><code>class ProcessOldData &lt; CMDx::Task\n  settings(deprecated: :warn)\n\n  def work\n    # Executes but emits Ruby warning...\n  end\nend\n\nresult = ProcessOldData.execute\nresult.successful? #=&gt; true\n\n# Ruby warning appears in stderr:\n# [ProcessOldData] DEPRECATED: migrate to a replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#declarations","title":"Declarations","text":""},{"location":"deprecation/#symbol-or-string","title":"Symbol or String","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecated: :raise)\n\n  # String\n  settings(deprecated: \"warn\")\nend\n</code></pre>"},{"location":"deprecation/#boolean-or-nil","title":"Boolean or Nil","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Deprecates with default :log mode\n  settings(deprecated: true)\n\n  # Skips deprecation\n  settings(deprecated: false)\n  settings(deprecated: nil)\nend\n</code></pre>"},{"location":"deprecation/#method","title":"Method","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecated: :deprecated?)\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def deprecated?\n    Time.now.year &gt; 2024 ? :raise : false\n  end\nend\n</code></pre>"},{"location":"deprecation/#proc-or-lambda","title":"Proc or Lambda","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Proc\n  settings(deprecated: proc { Rails.env.development? ? :raise : :log })\n\n  # Lambda\n  settings(deprecated: -&gt; { Current.tenant.legacy_mode? ? :warn : :raise })\nend\n</code></pre>"},{"location":"deprecation/#class-or-module","title":"Class or Module","text":"<pre><code>class OutdatedTaskDeprecator\n  def call(task)\n    task.class.name.include?(\"Outdated\")\n  end\nend\n\nclass OutdatedConnector &lt; CMDx::Task\n  # Class or Module\n  settings(deprecated: OutdatedTaskDeprecator)\n\n  # Instance\n  settings(deprecated: OutdatedTaskDeprecator.new)\nend\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>CMDx is a Ruby framework for building maintainable, observable business logic through composable command objects. It brings structure, consistency, and powerful developer tools to your business processes.</p> <p>Common challenges it solves:</p> <ul> <li>Inconsistent service object patterns across your codebase</li> <li>Limited logging makes debugging a nightmare</li> <li>Fragile error handling erodes confidence</li> </ul> <p>What you get:</p> <ul> <li>Consistent, standardized architecture</li> <li>Built-in flow control and error handling</li> <li>Composable, reusable workflows</li> <li>Comprehensive logging for observability</li> <li>Attribute validation with type coercions</li> <li>Sensible defaults and developer-friendly APIs</li> </ul>"},{"location":"getting_started/#the-cero-pattern","title":"The CERO Pattern","text":"<p>CMDx embraces the Compose, Execute, React, Observe (CERO) pattern\u2014a simple yet powerful approach to building reliable business logic.</p> <p>\ud83e\udde9 Compose \u2014 Define small, focused tasks with typed attributes and validations</p> <p>\u26a1 Execute \u2014 Run tasks with clear outcomes and pluggable behaviors</p> <p>\ud83d\udd04 React \u2014 Adapt to outcomes by chaining follow-up tasks or handling faults</p> <p>\ud83d\udd0d Observe \u2014 Capture structured logs and execution chains for debugging</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Add CMDx to your Gemfile:</p> <pre><code>gem 'cmdx'\n</code></pre> <p>For Rails applications, generate the configuration:</p> <pre><code>rails generate cmdx:install\n</code></pre> <p>This creates <code>config/initializers/cmdx.rb</code> file.</p>"},{"location":"getting_started/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>CMDx uses a straightforward two-tier configuration system:</p> <ol> <li>Global Configuration \u2014 Framework-wide defaults</li> <li>Task Settings \u2014 Class-level overrides using <code>settings</code></li> </ol> <p>Important</p> <p>Task settings take precedence over global config. Settings are inherited from parent classes and can be overridden in subclasses.</p>"},{"location":"getting_started/#global-configuration","title":"Global Configuration","text":"<p>Configure framework-wide defaults that apply to all tasks. These settings come with sensible defaults out of the box.</p>"},{"location":"getting_started/#breakpoints","title":"Breakpoints","text":"<p>Control when <code>execute!</code> raises a <code>CMDx::Fault</code> based on task status.</p> <pre><code>CMDx.configure do |config|\n  config.task_breakpoints = \"failed\" # String or Array[String]\nend\n</code></pre> <p>For workflows, configure which statuses halt the execution pipeline:</p> <pre><code>CMDx.configure do |config|\n  config.workflow_breakpoints = [\"skipped\", \"failed\"]\nend\n</code></pre>"},{"location":"getting_started/#backtraces","title":"Backtraces","text":"<p>Enable detailed backtraces for non-fault exceptions to improve debugging. Optionally clean up stack traces to remove framework noise.</p> <p>Note</p> <p>In Rails environments, <code>backtrace_cleaner</code> defaults to <code>Rails.backtrace_cleaner.clean</code>.</p> <pre><code>CMDx.configure do |config|\n  # Truthy\n  config.backtrace = true\n\n  # Via callable (must respond to `call(backtrace)`)\n  config.backtrace_cleaner = AdvanceCleaner.new\n\n  # Via proc or lambda\n  config.backtrace_cleaner = -&gt;(backtrace) { backtrace[0..5] }\nend\n</code></pre>"},{"location":"getting_started/#exception-handlers","title":"Exception Handlers","text":"<p>Register handlers that run when non-fault exceptions occur.</p> <p>Tip</p> <p>Use exception handlers to send errors to your APM of choice.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, exception)`)\n  config.exception_handler = NewRelicReporter\n\n  # Via proc or lambda\n  config.exception_handler = proc do |task, exception|\n    APMService.report(exception, extra_data: { task: task.name, id: task.id })\n  end\nend\n</code></pre>"},{"location":"getting_started/#logging","title":"Logging","text":"<pre><code>CMDx.configure do |config|\n  config.logger = CustomLogger.new($stdout)\nend\n</code></pre>"},{"location":"getting_started/#middlewares","title":"Middlewares","text":"<p>See the Middlewares docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, options)`)\n  config.middlewares.register CMDx::Middlewares::Timeout\n\n  # Via proc or lambda\n  config.middlewares.register proc { |task, options|\n    start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    result = yield\n    end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    Rails.logger.debug { \"task completed in #{((end_time - start_time) * 1000).round(2)}ms\" }\n    result\n  }\n\n  # With options\n  config.middlewares.register AuditTrailMiddleware, service_name: \"document_processor\"\n\n  # Remove middleware\n  config.middlewares.deregister CMDx::Middlewares::Timeout\nend\n</code></pre> <p>Note</p> <p>Middlewares are executed in registration order. Each middleware wraps the next, creating an execution chain around task logic.</p>"},{"location":"getting_started/#callbacks","title":"Callbacks","text":"<p>See the Callbacks docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via method\n  config.callbacks.register :before_execution, :initialize_user_session\n\n  # Via callable (must respond to `call(task)`)\n  config.callbacks.register :on_success, LogUserActivity\n\n  # Via proc or lambda\n  config.callbacks.register :on_complete, proc { |task|\n    execution_time = task.metadata[:runtime]\n    Metrics.timer(\"task.execution_time\", execution_time, tags: [\"task:#{task.class.name.underscore}\"])\n  }\n\n  # With options\n  config.callbacks.register :on_failure, :send_alert_notification, if: :critical_task?\n\n  # Remove callback\n  config.callbacks.deregister :on_success, LogUserActivity\nend\n</code></pre>"},{"location":"getting_started/#coercions","title":"Coercions","text":"<p>See the Attributes - Coercions docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.coercions.register :currency, CurrencyCoercion\n\n  # Via method (must match signature `def coordinates_coercion(value, options)`)\n  config.coercions.register :coordinates, :coordinates_coercion\n\n  # Via proc or lambda\n  config.coercions.register :tag_list, proc { |value, options|\n    delimiter = options[:delimiter] || ','\n    max_tags = options[:max_tags] || 50\n\n    tags = value.to_s.split(delimiter).map(&amp;:strip).reject(&amp;:empty?)\n    tags.first(max_tags)\n  }\n\n  # Remove coercion\n  config.coercions.deregister :currency\nend\n</code></pre>"},{"location":"getting_started/#validators","title":"Validators","text":"<p>See the Attributes - Validations docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.validators.register :username, UsernameValidator\n\n  # Via method (must match signature `def url_validator(value, options)`)\n  config.validators.register :url, :url_validator\n\n  # Via proc or lambda\n  config.validators.register :access_token, proc { |value, options|\n    expected_prefix = options[:prefix] || \"tok_\"\n    minimum_length = options[:min_length] || 40\n\n    value.start_with?(expected_prefix) &amp;&amp; value.length &gt;= minimum_length\n  }\n\n  # Remove validator\n  config.validators.deregister :username\nend\n</code></pre>"},{"location":"getting_started/#task-configuration","title":"Task Configuration","text":""},{"location":"getting_started/#settings","title":"Settings","text":"<p>Override global configuration for specific tasks using <code>settings</code>:</p> <pre><code>class GenerateInvoice &lt; CMDx::Task\n  settings(\n    # Global configuration overrides\n    task_breakpoints: [\"failed\"],                # Breakpoint override\n    workflow_breakpoints: [],                    # Breakpoint override\n    backtrace: true,                             # Toggle backtrace\n    backtrace_cleaner: -&gt;(bt) { bt[0..5] },      # Backtrace cleaner\n    logger: CustomLogger.new($stdout),           # Custom logger\n\n    # Task configuration settings\n    breakpoints: [\"failed\"],                     # Contextual pointer for :task_breakpoints and :workflow_breakpoints\n    log_level: :info,                            # Log level override\n    log_formatter: CMDx::LogFormatters::Json.new # Log formatter override\n    tags: [\"billing\", \"financial\"],              # Logging tags\n    deprecated: true,                            # Task deprecations\n    retries: 3,                                  # Non-fault exception retries\n    retry_on: [External::ApiError],              # List of exceptions to retry on\n    retry_jitter: 1                              # Space between retry iteration, eg: current retry num + 1\n  )\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Important</p> <p>Retries reuse the same context. By default, all <code>StandardError</code> exceptions are retried unless you specify <code>retry_on</code>.</p>"},{"location":"getting_started/#registrations","title":"Registrations","text":"<p>Register or deregister middlewares, callbacks, coercions, and validators for specific tasks:</p> <pre><code>class SendCampaignEmail &lt; CMDx::Task\n  # Middlewares\n  register :middleware, CMDx::Middlewares::Timeout\n  deregister :middleware, AuditTrailMiddleware\n\n  # Callbacks\n  register :callback, :on_complete, proc { |task|\n    runtime = task.metadata[:runtime]\n    Analytics.track(\"email_campaign.sent\", runtime, tags: [\"task:#{task.class.name}\"])\n  }\n  deregister :callback, :before_execution, :initialize_user_session\n\n  # Coercions\n  register :coercion, :currency, CurrencyCoercion\n  deregister :coercion, :coordinates\n\n  # Validators\n  register :validator, :username, :username_validator\n  deregister :validator, :url\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"getting_started/#configuration-management","title":"Configuration Management","text":""},{"location":"getting_started/#access","title":"Access","text":"<pre><code># Global configuration access\nCMDx.configuration.logger               #=&gt; &lt;Logger instance&gt;\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"]\nCMDx.configuration.middlewares.registry #=&gt; [&lt;Middleware&gt;, ...]\n\n# Task configuration access\nclass ProcessUpload &lt; CMDx::Task\n  settings(tags: [\"files\", \"storage\"])\n\n  def work\n    self.class.settings[:logger] #=&gt; Global configuration value\n    self.class.settings[:tags]   #=&gt; Task configuration value =&gt; [\"files\", \"storage\"]\n  end\nend\n</code></pre>"},{"location":"getting_started/#resetting","title":"Resetting","text":"<p>Warning</p> <p>Resetting affects your entire application. Use this primarily in test environments.</p> <pre><code># Reset to framework defaults\nCMDx.reset_configuration!\n\n# Verify reset\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"] (default)\nCMDx.configuration.middlewares.registry #=&gt; Empty registry\n\n# Commonly used in test setup (RSpec example)\nRSpec.configure do |config|\n  config.before(:each) do\n    CMDx.reset_configuration!\n  end\nend\n</code></pre>"},{"location":"getting_started/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:task ModerateBlogPost\n</code></pre> <p>This creates a new task file with the basic structure:</p> <pre><code># app/tasks/moderate_blog_post.rb\nclass ModerateBlogPost &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + noun for task names, eg: <code>ModerateBlogPost</code>, <code>ScheduleAppointment</code>, <code>ValidateDocument</code></p>"},{"location":"getting_started/#type-safety","title":"Type safety","text":"<p>CMDx includes built-in RBS (Ruby Type Signature) inline annotations throughout the codebase, providing type information for static analysis and editor support.</p> <ul> <li>Type checking \u2014 Catch type errors before runtime using tools like Steep or TypeProf</li> <li>Better IDE support \u2014 Enhanced autocomplete, navigation, and inline documentation</li> <li>Self-documenting code \u2014 Clear method signatures and return types</li> <li>Refactoring confidence \u2014 Type-aware refactoring reduces bugs</li> </ul>"},{"location":"internationalization/","title":"Internationalization (i18n)","text":"<p>CMDx supports 90+ languages out of the box for all error messages, validations, coercions, and faults. Error messages automatically adapt to the current <code>I18n.locale</code>, making it easy to build applications for global audiences.</p>"},{"location":"internationalization/#usage","title":"Usage","text":"<p>All error messages are automatically localized based on your current locale:</p> <pre><code>class ProcessQuote &lt; CMDx::Task\n  attribute :price, type: :float\n\n  def work\n    # Your logic here...\n  end\nend\n\nI18n.with_locale(:fr) do\n  result = ProcessQuote.execute(price: \"invalid\")\n  result.metadata[:messages][:price] #=&gt; [\"impossible de contraindre en float\"]\nend\n</code></pre>"},{"location":"internationalization/#configuration","title":"Configuration","text":"<p>CMDx uses the <code>I18n</code> gem for localization. In Rails, locales load automatically.</p>"},{"location":"internationalization/#copy-locale-files","title":"Copy Locale Files","text":"<p>Copy locale files to your Rails application's <code>config/locales</code> directory:</p> <pre><code>rails generate cmdx:locale [LOCALE]\n\n# Eg: generate french locale\nrails generate cmdx:locale fr\n</code></pre>"},{"location":"internationalization/#available-locales","title":"Available Locales","text":"<ul> <li>af - Afrikaans</li> <li>ar - Arabic</li> <li>az - Azerbaijani</li> <li>be - Belarusian</li> <li>bg - Bulgarian</li> <li>bn - Bengali</li> <li>bs - Bosnian</li> <li>ca - Catalan</li> <li>cnr - Montenegrin</li> <li>cs - Czech</li> <li>cy - Welsh</li> <li>da - Danish</li> <li>de - German</li> <li>dz - Dzongkha</li> <li>el - Greek</li> <li>en - English</li> <li>eo - Esperanto</li> <li>es - Spanish</li> <li>et - Estonian</li> <li>eu - Basque</li> <li>fa - Persian</li> <li>fi - Finnish</li> <li>fr - French</li> <li>fy - Western Frisian</li> <li>gd - Scottish Gaelic</li> <li>gl - Galician</li> <li>he - Hebrew</li> <li>hi - Hindi</li> <li>hr - Croatian</li> <li>hu - Hungarian</li> <li>hy - Armenian</li> <li>id - Indonesian</li> <li>is - Icelandic</li> <li>it - Italian</li> <li>ja - Japanese</li> <li>ka - Georgian</li> <li>kk - Kazakh</li> <li>km - Khmer</li> <li>kn - Kannada</li> <li>ko - Korean</li> <li>lb - Luxembourgish</li> <li>lo - Lao</li> <li>lt - Lithuanian</li> <li>lv - Latvian</li> <li>mg - Malagasy</li> <li>mk - Macedonian</li> <li>ml - Malayalam</li> <li>mn - Mongolian</li> <li>mr-IN - Marathi (India)</li> <li>ms - Malay</li> <li>nb - Norwegian Bokm\u00e5l</li> <li>ne - Nepali</li> <li>nl - Dutch</li> <li>nn - Norwegian Nynorsk</li> <li>oc - Occitan</li> <li>or - Odia</li> <li>pa - Punjabi</li> <li>pl - Polish</li> <li>pt - Portuguese</li> <li>rm - Romansh</li> <li>ro - Romanian</li> <li>ru - Russian</li> <li>sc - Sardinian</li> <li>sk - Slovak</li> <li>sl - Slovenian</li> <li>sq - Albanian</li> <li>sr - Serbian</li> <li>st - Southern Sotho</li> <li>sv - Swedish</li> <li>sw - Swahili</li> <li>ta - Tamil</li> <li>te - Telugu</li> <li>th - Thai</li> <li>tl - Tagalog</li> <li>tr - Turkish</li> <li>tt - Tatar</li> <li>ug - Uyghur</li> <li>uk - Ukrainian</li> <li>ur - Urdu</li> <li>uz - Uzbek</li> <li>vi - Vietnamese</li> <li>wo - Wolof</li> <li>zh-CN - Chinese (Simplified)</li> <li>zh-HK - Chinese (Hong Kong)</li> <li>zh-TW - Chinese (Traditional)</li> <li>zh-YUE - Chinese (Yue)</li> </ul>"},{"location":"logging/","title":"Logging","text":"<p>CMDx automatically logs every task execution with structured data, making debugging and monitoring effortless. Choose from multiple formatters to match your logging infrastructure.</p>"},{"location":"logging/#formatters","title":"Formatters","text":"<p>Choose the format that works best for your logging system:</p> Formatter Use Case Output Style <code>Line</code> Traditional logging Single-line format <code>Json</code> Structured systems Compact JSON <code>KeyValue</code> Log parsing <code>key=value</code> pairs <code>Logstash</code> ELK stack JSON with @version/@timestamp <code>Raw</code> Minimal output Message content only <p>Sample output:</p> <pre><code>&lt;!-- Success (INFO level) --&gt;\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- GenerateInvoice:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"GenerateInvoice\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n\n&lt;!-- Skipped (WARN level) --&gt;\nW, [2022-07-17T18:43:15.000000 #3784] WARN -- ValidateCustomer:\nindex=1 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"ValidateCustomer\" state=\"interrupted\" status=\"skipped\" reason=\"Customer already validated\"\n\n&lt;!-- Failed (ERROR level) --&gt;\nE, [2022-07-17T18:43:15.000000 #3784] ERROR -- CalculateTax:\nindex=2 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"CalculateTax\"  state=\"interrupted\" status=\"failed\" metadata={error_code: \"TAX_SERVICE_UNAVAILABLE\"}\n\n&lt;!-- Failed Chain --&gt;\nE, [2022-07-17T18:43:15.000000 #3784] ERROR -- BillingWorkflow:\nindex=3 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"BillingWorkflow\"  state=\"interrupted\" status=\"failed\" caused_failure={index: 2, class: \"CalculateTax\", status: \"failed\"} threw_failure={index: 1, class: \"ValidateCustomer\", status: \"failed\"}\n</code></pre> <p>Tip</p> <p>Use logging as a low-level event stream to track all tasks in a request. Combine with correlation for powerful distributed tracing.</p>"},{"location":"logging/#structure","title":"Structure","text":"<p>Every log entry includes rich metadata. Available fields depend on execution context and outcome.</p>"},{"location":"logging/#core-fields","title":"Core Fields","text":"Field Description Example <code>severity</code> Log level <code>INFO</code>, <code>WARN</code>, <code>ERROR</code> <code>timestamp</code> ISO 8601 execution time <code>2022-07-17T18:43:15.000000</code> <code>pid</code> Process ID <code>3784</code>"},{"location":"logging/#task-information","title":"Task Information","text":"Field Description Example <code>index</code> Execution sequence position <code>0</code>, <code>1</code>, <code>2</code> <code>chain_id</code> Unique execution chain ID <code>018c2b95-b764-7615...</code> <code>type</code> Execution unit type <code>Task</code>, <code>Workflow</code> <code>class</code> Task class name <code>GenerateInvoiceTask</code> <code>id</code> Unique task instance ID <code>018c2b95-b764-7615...</code> <code>tags</code> Custom categorization <code>[\"billing\", \"financial\"]</code>"},{"location":"logging/#execution-data","title":"Execution Data","text":"Field Description Example <code>state</code> Lifecycle state <code>complete</code>, <code>interrupted</code> <code>status</code> Business outcome <code>success</code>, <code>skipped</code>, <code>failed</code> <code>outcome</code> Final classification <code>success</code>, <code>interrupted</code> <code>metadata</code> Custom task data <code>{order_id: 123, amount: 99.99}</code>"},{"location":"logging/#failure-chain","title":"Failure Chain","text":"Field Description <code>reason</code> Reason given for the stoppage <code>caused</code> Cause exception details <code>caused_failure</code> Original failing task details <code>threw_failure</code> Task that propagated the failure"},{"location":"logging/#usage","title":"Usage","text":"<p>Access the framework logger directly within tasks:</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  def work\n    logger.debug { \"Activated feature flags: #{Features.active_flags}\" }\n    # Your logic here...\n    logger.info(\"Subscription processed\")\n  end\nend\n</code></pre>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Wrap task execution with middleware for cross-cutting concerns like authentication, caching, timeouts, and monitoring. Think Rack middleware, but for your business logic.</p> <p>See Global Configuration for framework-wide setup.</p>"},{"location":"middlewares/#execution-order","title":"Execution Order","text":"<p>Middleware wraps task execution in layers, like an onion:</p> <p>Note</p> <p>First registered = outermost wrapper. They execute in registration order.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  register :middleware, AuditMiddleware         # 1st: outermost wrapper\n  register :middleware, AuthorizationMiddleware # 2nd: middle wrapper\n  register :middleware, CacheMiddleware         # 3rd: innermost wrapper\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Execution flow:\n# 1. AuditMiddleware (before)\n# 2.   AuthorizationMiddleware (before)\n# 3.     CacheMiddleware (before)\n# 4.       [task execution]\n# 5.     CacheMiddleware (after)\n# 6.   AuthorizationMiddleware (after)\n# 7. AuditMiddleware (after)\n</code></pre>"},{"location":"middlewares/#declarations","title":"Declarations","text":""},{"location":"middlewares/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple middleware logic:</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Proc\n  register :middleware, proc do |task, options, &amp;block|\n    result = block.call\n    Analytics.track(result.status)\n    result\n  end\n\n  # Lambda\n  register :middleware, -&gt;(task, options, &amp;block) {\n    result = block.call\n    Analytics.track(result.status)\n    result\n  }\nend\n</code></pre>"},{"location":"middlewares/#class-or-module","title":"Class or Module","text":"<p>For complex middleware logic, use classes or modules:</p> <pre><code>class TelemetryMiddleware\n  def call(task, options)\n    result = yield\n    Telemetry.record(result.status)\n  ensure\n    result # Always return result\n  end\nend\n\nclass ProcessCampaign &lt; CMDx::Task\n  # Class or Module\n  register :middleware, TelemetryMiddleware\n\n  # Instance\n  register :middleware, TelemetryMiddleware.new\n\n  # With options\n  register :middleware, MonitoringMiddleware, service_key: ENV[\"MONITORING_KEY\"]\n  register :middleware, MonitoringMiddleware.new(ENV[\"MONITORING_KEY\"])\nend\n</code></pre>"},{"location":"middlewares/#removals","title":"Removals","text":"<p>Remove class or module-based middleware globally or per-task:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one middleware. Use multiple calls for batch removals.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Class or Module (no instances)\n  deregister :middleware, TelemetryMiddleware\nend\n</code></pre>"},{"location":"middlewares/#built-in","title":"Built-in","text":""},{"location":"middlewares/#timeout","title":"Timeout","text":"<p>Prevent tasks from running too long:</p> <pre><code>class ProcessReport &lt; CMDx::Task\n  # Default timeout: 3 seconds\n  register :middleware, CMDx::Middlewares::Timeout\n\n  # Seconds (takes Numeric, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, seconds: :max_processing_time\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, unless: -&gt; { self.class.name.include?(\"Quick\") }\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def max_processing_time\n    Rails.env.production? ? 2 : 10\n  end\nend\n\n# Slow task\nresult = ProcessReport.execute\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failure\"\nresult.reason   #=&gt; \"[CMDx::TimeoutError] execution exceeded 3 seconds\"\nresult.cause    #=&gt; &lt;CMDx::TimeoutError&gt;\nresult.metadata #=&gt; { limit: 3 }\n</code></pre>"},{"location":"middlewares/#correlate","title":"Correlate","text":"<p>Add correlation IDs for distributed tracing and request tracking:</p> <pre><code>class ProcessExport &lt; CMDx::Task\n  # Default correlation ID generation\n  register :middleware, CMDx::Middlewares::Correlate\n\n  # Seconds (takes Object, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, id: proc { |task| task.context.session_id }\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, if: :correlation_enabled?\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def correlation_enabled?\n    ENV[\"CORRELATION_ENABLED\"] == \"true\"\n  end\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { correlation_id: \"550e8400-e29b-41d4-a716-446655440000\" }\n</code></pre>"},{"location":"middlewares/#runtime","title":"Runtime","text":"<p>Track task execution time in milliseconds using a monotonic clock:</p> <pre><code>class PerformanceMonitoringCheck\n  def call(task)\n    task.context.tenant.monitoring_enabled?\n  end\nend\n\nclass ProcessExport &lt; CMDx::Task\n  # Default timeout is 3 seconds\n  register :middleware, CMDx::Middlewares::Runtime\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Runtime, if: PerformanceMonitoringCheck\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { runtime: 1247 } (ms)\n</code></pre>"},{"location":"tips_and_tricks/","title":"Tips and Tricks","text":"<p>Best practices, patterns, and techniques to build maintainable CMDx applications.</p>"},{"location":"tips_and_tricks/#project-organization","title":"Project Organization","text":""},{"location":"tips_and_tricks/#directory-structure","title":"Directory Structure","text":"<p>Create a well-organized command structure for maintainable applications:</p> <pre><code>/app/\n\u2514\u2500\u2500 /tasks/\n    \u251c\u2500\u2500 /invoices/\n    \u2502   \u251c\u2500\u2500 calculate_tax.rb\n    \u2502   \u251c\u2500\u2500 validate_invoice.rb\n    \u2502   \u251c\u2500\u2500 send_invoice.rb\n    \u2502   \u2514\u2500\u2500 process_invoice.rb # workflow\n    \u251c\u2500\u2500 /reports/\n    \u2502   \u251c\u2500\u2500 generate_pdf.rb\n    \u2502   \u251c\u2500\u2500 compile_data.rb\n    \u2502   \u251c\u2500\u2500 export_csv.rb\n    \u2502   \u2514\u2500\u2500 create_reports.rb # workflow\n    \u251c\u2500\u2500 application_task.rb # base class\n    \u251c\u2500\u2500 authenticate_session.rb\n    \u2514\u2500\u2500 activate_account.rb\n</code></pre>"},{"location":"tips_and_tricks/#naming-conventions","title":"Naming Conventions","text":"<p>Follow consistent naming patterns for clarity and maintainability:</p> <pre><code># Verb + Noun\nclass ExportData &lt; CMDx::Task; end\nclass CompressFile &lt; CMDx::Task; end\nclass ValidateSchema &lt; CMDx::Task; end\n\n# Use present tense verbs for actions\nclass GenerateToken &lt; CMDx::Task; end      # \u2713 Good\nclass GeneratingToken &lt; CMDx::Task; end    # \u274c Avoid\nclass TokenGeneration &lt; CMDx::Task; end    # \u274c Avoid\n</code></pre>"},{"location":"tips_and_tricks/#story-telling","title":"Story Telling","text":"<p>Break down complex logic into descriptive methods that read like a narrative:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    charge_payment_method\n    assign_to_warehouse\n    send_notification\n  end\n\n  private\n\n  def charge_payment_method\n    order.primary_payment_method.charge!\n  end\n\n  def assign_to_warehouse\n    order.ready_for_shipping!\n  end\n\n  def send_notification\n    if order.products_out_of_stock?\n      OrderMailer.pending(order).deliver\n    else\n      OrderMailer.preparing(order).deliver\n    end\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#style-guide","title":"Style Guide","text":"<p>Follow this order for consistent, readable tasks:</p> <pre><code>class ExportReport &lt; CMDx::Task\n\n  # 1. Register functions\n  register :middleware, CMDx::Middlewares::Correlate\n  register :validator, :format, FormatValidator\n\n  # 2. Define callbacks\n  before_execution :find_report\n  on_complete :track_export_metrics, if: -&gt;(task) { Current.tenant.analytics? }\n\n  # 3. Declare attributes\n  attributes :user_id\n  required :report_id\n  optional :format_type\n\n  # 4. Define work method\n  def work\n    report.compile!\n    report.export!\n\n    context.exported_at = Time.now\n  end\n\n  # TIP: Favor private business logic to reduce the surface of the public API.\n  private\n\n  # 5. Build helper functions\n  def find_report\n    @report ||= Report.find(report_id)\n  end\n\n  def track_export_metrics\n    Analytics.increment(:report_exported)\n  end\n\nend\n</code></pre>"},{"location":"tips_and_tricks/#attribute-options","title":"Attribute Options","text":"<p>Use <code>with_options</code> to reduce duplication:</p> <pre><code>class ConfigureCompany &lt; CMDx::Task\n  # Apply common options to multiple attributes\n  with_options(type: :string, presence: true) do\n    attributes :website, format: { with: URI::DEFAULT_PARSER.make_regexp(%w[http https]) }\n    required :company_name, :industry\n    optional :description, format: { with: /\\A[\\w\\s\\-\\.,!?]+\\z/ }\n  end\n\n  # Nested attributes with shared prefix\n  required :headquarters do\n    with_options(prefix: :hq_) do\n      attributes :street, :city, :zip_code, type: :string\n      required :country, type: :string, inclusion: { in: VALID_COUNTRIES }\n      optional :region, type: :string\n    end\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#advanced-examples","title":"Advanced Examples","text":"<ul> <li>Active Record Query Tagging</li> <li>Paper Trail Whatdunnit</li> </ul>"},{"location":"workflows/","title":"Workflows","text":"<p>Compose multiple tasks into powerful, sequential pipelines. Workflows provide a declarative way to build complex business processes with conditional execution, shared context, and flexible error handling.</p>"},{"location":"workflows/#declarations","title":"Declarations","text":"<p>Tasks run in declaration order (FIFO), sharing a common context across the pipeline.</p> <p>Warning</p> <p>Don't define a <code>work</code> method in workflows\u2014the module handles execution automatically.</p>"},{"location":"workflows/#task","title":"Task","text":"<pre><code>class OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateUserProfile\n  task SetupAccountPreferences\n\n  tasks SendWelcomeEmail, SendWelcomeSms, CreateDashboard\nend\n</code></pre> <p>Tip</p> <p>Execute tasks in parallel via the cmdx-parallel gem.</p>"},{"location":"workflows/#group","title":"Group","text":"<p>Group related tasks to share configuration:</p> <p>Important</p> <p>Settings and conditionals apply to all tasks in the group.</p> <pre><code>class ContentModerationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Screening phase\n  tasks ScanForProfanity, CheckForSpam, ValidateImages, breakpoints: [\"skipped\"]\n\n  # Review phase\n  tasks ApplyFilters, ScoreContent, FlagSuspicious\n\n  # Decision phase\n  tasks PublishContent, QueueForReview, NotifyModerators\nend\n</code></pre>"},{"location":"workflows/#conditionals","title":"Conditionals","text":"<p>Conditionals support multiple syntaxes for flexible execution control:</p> <pre><code>class ContentAccessCheck\n  def call(task)\n    task.context.user.can?(:publish_content)\n  end\nend\n\nclass OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # If and/or Unless\n  task SendWelcomeEmail, if: :email_configured?, unless: :email_disabled?\n\n  # Proc\n  task SendWelcomeEmail, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Premium\") }\n\n  # Lambda\n  task SendWelcomeEmail, if: proc { context.features_enabled? }\n\n  # Class or Module\n  task SendWelcomeEmail, unless: ContentAccessCheck\n\n  # Instance\n  task SendWelcomeEmail, if: ContentAccessCheck.new\n\n  # Conditional applies to all tasks of this declaration group\n  tasks SendWelcomeEmail, CreateDashboard, SetupTutorial, if: :email_configured?\n\n  private\n\n  def email_configured?\n    context.user.email_address == true\n  end\n\n  def email_disabled?\n    context.user.communication_preference == :disabled\n  end\nend\n</code></pre>"},{"location":"workflows/#halt-behavior","title":"Halt Behavior","text":"<p>By default, skipped tasks don't stop the workflow\u2014they're treated as no-ops. Configure breakpoints globally or per-task to customize this behavior.</p> <pre><code>class AnalyticsWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CollectMetrics      # If fails \u2192 workflow stops\n  task FilterOutliers      # If skipped \u2192 workflow continues\n  task GenerateDashboard   # Only runs if no failures occurred\nend\n</code></pre>"},{"location":"workflows/#task-configuration","title":"Task Configuration","text":"<p>Configure halt behavior for the entire workflow:</p> <pre><code>class SecurityWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Halt on both failed and skipped results\n  settings(workflow_breakpoints: [\"skipped\", \"failed\"])\n\n  task PerformSecurityScan\n  task ValidateSecurityRules\nend\n\nclass OptionalTasksWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Never halt, always continue\n  settings(breakpoints: [])\n\n  task TryBackupData\n  task TryCleanupLogs\n  task TryOptimizeCache\nend\n</code></pre>"},{"location":"workflows/#group-configuration","title":"Group Configuration","text":"<p>Different task groups can have different halt behavior:</p> <pre><code>class SubscriptionWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateSubscription, ValidatePayment, workflow_breakpoints: [\"skipped\", \"failed\"]\n\n  # Never halt, always continue\n  task SendConfirmationEmail, UpdateBilling, breakpoints: []\nend\n</code></pre>"},{"location":"workflows/#nested-workflows","title":"Nested Workflows","text":"<p>Build hierarchical workflows by composing workflows within workflows:</p> <pre><code>class EmailPreparationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateRecipients\n  task CompileTemplate\nend\n\nclass EmailDeliveryWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks SendEmails, TrackDeliveries\nend\n\nclass CompleteEmailWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task EmailPreparationWorkflow\n  task EmailDeliveryWorkflow, if: proc { context.preparation_successful? }\n  task GenerateDeliveryReport\nend\n</code></pre>"},{"location":"workflows/#parallel-execution","title":"Parallel Execution","text":"<p>Run tasks concurrently using the Parallel gem. It automatically uses all available processors for maximum throughput.</p> <p>Warning</p> <p>Context is read-only during parallel execution. Load all required data beforehand.</p> <pre><code>class SendWelcomeNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Default options (dynamically calculated to available processors)\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel\n\n  # Fix number of threads\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_threads: 2\n\n  # Fix number of forked processes\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_processes: 2\n\n  # NOTE: Reactors are not supported\nend\n</code></pre>"},{"location":"workflows/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx workflow tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:workflow SendNotifications\n</code></pre> <p>This creates a new workflow task file with the basic structure:</p> <pre><code># app/tasks/send_notifications.rb\nclass SendNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks Task1, Task2\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + pluralized noun for workflow task names, eg: <code>SendNotifications</code>, <code>DownloadFiles</code>, <code>ValidateDocuments</code></p>"},{"location":"attributes/coercions/","title":"Attributes - Coercions","text":"<p>Automatically convert inputs to expected types. Coercions handle everything from simple string-to-integer conversions to JSON parsing.</p> <p>See Global Configuration for custom coercion setup.</p>"},{"location":"attributes/coercions/#usage","title":"Usage","text":"<p>Define attribute types to enable automatic coercion:</p> <pre><code>class ParseMetrics &lt; CMDx::Task\n  # Coerce into a symbol\n  attribute :measurement_type, type: :symbol\n\n  # Coerce into a rational fallback to big decimal\n  attribute :value, type: [:rational, :big_decimal]\n\n  # Coerce with options\n  attribute :recorded_at, type: :date, strptime: \"%m-%d-%Y\"\n\n  def work\n    measurement_type #=&gt; :temperature\n    recorded_at      #=&gt; &lt;Date 2024-01-23&gt;\n    value            #=&gt; 98.6 (Float)\n  end\nend\n\nParseMetrics.execute(\n  measurement_type: \"temperature\",\n  recorded_at: \"01-23-2020\",\n  value: \"98.6\"\n)\n</code></pre> <p>Tip</p> <p>Specify multiple coercion types for attributes that could be a variety of value formats. CMDx attempts each type in order until one succeeds.</p>"},{"location":"attributes/coercions/#built-in-coercions","title":"Built-in Coercions","text":"Type Options Description Examples <code>:array</code> Array conversion with JSON support <code>\"val\"</code> \u2192 <code>[\"val\"]</code><code>\"[1,2,3]\"</code> \u2192 <code>[1, 2, 3]</code> <code>:big_decimal</code> <code>:precision</code> High-precision decimal <code>\"123.456\"</code> \u2192 <code>BigDecimal(\"123.456\")</code> <code>:boolean</code> Boolean with text patterns <code>\"yes\"</code> \u2192 <code>true</code>, <code>\"no\"</code> \u2192 <code>false</code> <code>:complex</code> Complex numbers <code>\"1+2i\"</code> \u2192 <code>Complex(1, 2)</code> <code>:date</code> <code>:strptime</code> Date objects <code>\"2024-01-23\"</code> \u2192 <code>Date.new(2024, 1, 23)</code> <code>:datetime</code> <code>:strptime</code> DateTime objects <code>\"2024-01-23 10:30\"</code> \u2192 <code>DateTime.new(2024, 1, 23, 10, 30)</code> <code>:float</code> Floating-point numbers <code>\"123.45\"</code> \u2192 <code>123.45</code> <code>:hash</code> Hash conversion with JSON support <code>'{\"a\":1}'</code> \u2192 <code>{\"a\" =&gt; 1}</code> <code>:integer</code> Integer with hex/octal support <code>\"0xFF\"</code> \u2192 <code>255</code>, <code>\"077\"</code> \u2192 <code>63</code> <code>:rational</code> Rational numbers <code>\"1/2\"</code> \u2192 <code>Rational(1, 2)</code> <code>:string</code> String conversion <code>123</code> \u2192 <code>\"123\"</code> <code>:symbol</code> Symbol conversion <code>\"abc\"</code> \u2192 <code>:abc</code> <code>:time</code> <code>:strptime</code> Time objects <code>\"10:30:00\"</code> \u2192 <code>Time.new(2024, 1, 23, 10, 30)</code>"},{"location":"attributes/coercions/#declarations","title":"Declarations","text":"<p>Important</p> <p>Custom coercions must raise <code>CMDx::CoercionError</code> with a descriptive message.</p>"},{"location":"attributes/coercions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple coercion logic:</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  # Proc\n  register :callback, :geolocation, proc do |value, options = {}|\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  end\n\n  # Lambda\n  register :callback, :geolocation, -&gt;(value, options = {}) {\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/coercions/#class-or-module","title":"Class or Module","text":"<p>Register custom coercion logic for specialized type handling:</p> <pre><code>class GeolocationCoercion\n  def self.call(value, options = {})\n    Geolocation(value)\n  rescue StandardError\n    raise CMDx::CoercionError, \"could not convert into a geolocation\"\n  end\nend\n\nclass TransformCoordinates &lt; CMDx::Task\n  register :coercion, :geolocation, GeolocationCoercion\n\n  attribute :latitude, type: :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#removals","title":"Removals","text":"<p>Remove unwanted coercions:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one coercion. Use multiple calls for batch removals.</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  deregister :coercion, :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#error-handling","title":"Error Handling","text":"<p>Coercion failures provide detailed error information including attribute paths, attempted types, and specific failure reasons:</p> <pre><code>class AnalyzePerformance &lt; CMDx::Task\n  attribute  :iterations, type: :integer\n  attribute  :score, type: [:float, :big_decimal]\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = AnalyzePerformance.execute(\n  iterations: \"not-a-number\",\n  score: \"invalid-float\"\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"iterations could not coerce into an integer. score could not coerce into one of: float, big_decimal.\",\n                #       messages: {\n                #         iterations: [\"could not coerce into an integer\"],\n                #         score: [\"could not coerce into one of: float, big_decimal\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/defaults/","title":"Attributes - Defaults","text":"<p>Provide fallback values for optional attributes. Defaults kick in when values aren't provided or are <code>nil</code>.</p>"},{"location":"attributes/defaults/#declarations","title":"Declarations","text":"<p>Defaults work seamlessly with coercions, validations, and nested attributes:</p>"},{"location":"attributes/defaults/#static-values","title":"Static Values","text":"<pre><code>class OptimizeDatabase &lt; CMDx::Task\n  attribute :strategy, default: :incremental\n  attribute :level, default: \"basic\"\n  attribute :notify_admin, default: true\n  attribute :timeout_minutes, default: 30\n  attribute :indexes, default: []\n  attribute :options, default: {}\n\n  def work\n    strategy        #=&gt; :incremental\n    level           #=&gt; \"basic\"\n    notify_admin    #=&gt; true\n    timeout_minutes #=&gt; 30\n    indexes         #=&gt; []\n    options         #=&gt; {}\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic default values:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :granularity, default: :default_granularity\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def default_granularity\n    Current.user.premium? ? \"hourly\" : \"daily\"\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic default values:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, default: proc { Current.tenant.cache_duration || 24 }\n\n  # Lambda\n  attribute :compression, default: -&gt; { Current.tenant.premium? ? \"gzip\" : \"none\" }\nend\n</code></pre>"},{"location":"attributes/defaults/#coercions-and-validations","title":"Coercions and Validations","text":"<p>Defaults follow the same coercion and validation rules as provided values:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, default: \"7\", type: :integer\n\n  # Validations\n  optional :frequency, default: \"daily\", inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/definitions/","title":"Attributes - Definitions","text":"<p>Attributes define your task's interface with automatic validation, type coercion, and accessor generation. They're the contract between callers and your business logic.</p>"},{"location":"attributes/definitions/#declarations","title":"Declarations","text":"<p>Tip</p> <p>Prefer using the <code>required</code> and <code>optional</code> alias for <code>attributes</code> for brevity and to clearly signal intent.</p>"},{"location":"attributes/definitions/#optional","title":"Optional","text":"<p>Optional attributes return <code>nil</code> when not provided.</p> <pre><code>class ScheduleEvent &lt; CMDx::Task\n  attribute :title\n  attributes :duration, :location\n\n  # Alias for attributes (preferred)\n  optional :description\n  optional :visibility, :attendees\n\n  def work\n    title       #=&gt; \"Team Standup\"\n    duration    #=&gt; 30\n    location    #=&gt; nil\n    description #=&gt; nil\n    visibility  #=&gt; nil\n    attendees   #=&gt; [\"alice@company.com\", \"bob@company.com\"]\n  end\nend\n\n# Attributes passed as keyword arguments\nScheduleEvent.execute(\n  title: \"Team Standup\",\n  duration: 30,\n  attendees: [\"alice@company.com\", \"bob@company.com\"]\n)\n</code></pre>"},{"location":"attributes/definitions/#required","title":"Required","text":"<p>Required attributes must be provided in call arguments or task execution will fail.</p> <pre><code>class PublishArticle &lt; CMDx::Task\n  attribute :title, required: true\n  attributes :content, :author_id, required: true\n\n  # Alias for attributes =&gt; required: true (preferred)\n  required :category\n  required :status, :tags\n\n  def work\n    title     #=&gt; \"Getting Started with Ruby\"\n    content   #=&gt; \"This is a comprehensive guide...\"\n    author_id #=&gt; 42\n    category  #=&gt; \"programming\"\n    status    #=&gt; :published\n    tags      #=&gt; [\"ruby\", \"beginner\"]\n  end\nend\n\n# Attributes passed as keyword arguments\nPublishArticle.execute(\n  title: \"Getting Started with Ruby\",\n  content: \"This is a comprehensive guide...\",\n  author_id: 42,\n  category: \"programming\",\n  status: :published,\n  tags: [\"ruby\", \"beginner\"]\n)\n</code></pre>"},{"location":"attributes/definitions/#sources","title":"Sources","text":"<p>Attributes read from any accessible object\u2014not just context. Use sources to pull data from models, services, or any callable:</p>"},{"location":"attributes/definitions/#context","title":"Context","text":"<pre><code>class BackupDatabase &lt; CMDx::Task\n  # Default source is :context\n  required :database_name\n  optional :compression_level\n\n  # Explicitly specify context source\n  attribute :backup_path, source: :context\n\n  def work\n    database_name     #=&gt; context.database_name\n    backup_path       #=&gt; context.backup_path\n    compression_level #=&gt; context.compression_level\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  attributes :host, :credentials, source: :database_config\n\n  # Access from declared attributes\n  attribute :connection_string, source: :credentials\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def database_config\n    @database_config ||= DatabaseConfig.find(context.database_name)\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  # Proc\n  attribute :timestamp, source: proc { Time.current }\n\n  # Lambda\n  attribute :server, source: -&gt; { Current.server }\nend\n</code></pre>"},{"location":"attributes/definitions/#class-or-module","title":"Class or Module","text":"<p>For complex source logic, use classes or modules:</p> <pre><code>class DatabaseResolver\n  def self.call(task)\n    Database.find(task.context.database_name)\n  end\nend\n\nclass BackupDatabase &lt; CMDx::Task\n  # Class or Module\n  attribute :schema, source: DatabaseResolver\n\n  # Instance\n  attribute :metadata, source: DatabaseResolver.new\nend\n</code></pre>"},{"location":"attributes/definitions/#nesting","title":"Nesting","text":"<p>Build complex structures with nested attributes. Children inherit their parent as source and support all attribute options:</p> <p>Note</p> <p>Nested attributes support all features: naming, coercions, validations, defaults, and more.</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  # Required parent with required children\n  required :network_config do\n    required :hostname, :port, :protocol, :subnet\n    optional :load_balancer\n    attribute :firewall_rules\n  end\n\n  # Optional parent with conditional children\n  optional :ssl_config do\n    required :certificate_path, :private_key # Only required if ssl_config provided\n    optional :enable_http2, prefix: true\n  end\n\n  # Multi-level nesting\n  attribute :monitoring do\n    required :provider\n\n    optional :alerting do\n      required :threshold_percentage\n      optional :notification_channel\n    end\n  end\n\n  def work\n    network_config   #=&gt; { hostname: \"api.company.com\" ... }\n    hostname         #=&gt; \"api.company.com\"\n    load_balancer    #=&gt; nil\n  end\nend\n\nConfigureServer.execute(\n  server_id: \"srv-001\",\n  network_config: {\n    hostname: \"api.company.com\",\n    port: 443,\n    protocol: \"https\",\n    subnet: \"10.0.1.0/24\",\n    firewall_rules: \"allow_web_traffic\"\n  },\n  monitoring: {\n    provider: \"datadog\",\n    alerting: {\n      threshold_percentage: 85.0,\n      notification_channel: \"slack\"\n    }\n  }\n)\n</code></pre> <p>Important</p> <p>Child requirements only apply when the parent is provided\u2014perfect for optional structures.</p>"},{"location":"attributes/definitions/#error-handling","title":"Error Handling","text":"<p>Validation failures provide detailed, structured error messages:</p> <p>Note</p> <p>Nested attributes are only validated when their parent is present and valid.</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  required :server_id, :environment\n  required :network_config do\n    required :hostname, :port\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Missing required top-level attributes\nresult = ConfigureServer.execute(server_id: \"srv-001\")\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"environment is required. network_config is required.\",\n                #       messages: {\n                #         environment: [\"is required\"],\n                #         network_config: [\"is required\"]\n                #       }\n                #     }\n                #   }\n\n# Missing required nested attributes\nresult = ConfigureServer.execute(\n  server_id: \"srv-001\",\n  environment: \"production\",\n  network_config: { hostname: \"api.company.com\" } # Missing port\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"port is required.\",\n                #       messages: {\n                #         port: [\"is required\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/naming/","title":"Attributes - Naming","text":"<p>Customize accessor method names to avoid conflicts and improve clarity. Affixing changes only the generated methods\u2014not the original attribute names.</p> <p>Note</p> <p>Use naming when attributes conflict with existing methods or need better clarity in your code.</p>"},{"location":"attributes/naming/#prefix","title":"Prefix","text":"<p>Adds a prefix to the generated accessor method name.</p> <pre><code>class GenerateReport &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :template, prefix: true\n\n  # Static\n  attribute :format, prefix: \"report_\"\n\n  def work\n    context_template #=&gt; \"monthly_sales\"\n    report_format    #=&gt; \"pdf\"\n  end\nend\n\n# Attributes passed as original attribute names\nGenerateReport.execute(template: \"monthly_sales\", format: \"pdf\")\n</code></pre>"},{"location":"attributes/naming/#suffix","title":"Suffix","text":"<p>Adds a suffix to the generated accessor method name.</p> <pre><code>class DeployApplication &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :branch, suffix: true\n\n  # Static\n  attribute :version, suffix: \"_tag\"\n\n  def work\n    branch_context #=&gt; \"main\"\n    version_tag    #=&gt; \"v1.2.3\"\n  end\nend\n\n# Attributes passed as original attribute names\nDeployApplication.execute(branch: \"main\", version: \"v1.2.3\")\n</code></pre>"},{"location":"attributes/naming/#as","title":"As","text":"<p>Completely renames the generated accessor method.</p> <pre><code>class ScheduleMaintenance &lt; CMDx::Task\n  attribute :scheduled_at, as: :when\n\n  def work\n    when #=&gt; &lt;DateTime&gt;\n  end\nend\n\n# Attributes passed as original attribute names\nScheduleMaintenance.execute(scheduled_at: DateTime.new(2024, 12, 15, 2, 0, 0))\n</code></pre>"},{"location":"attributes/transformations/","title":"Attributes - Transformations","text":"<p>Modify attribute values after coercion but before validation. Perfect for normalization, formatting, and data cleanup.</p>"},{"location":"attributes/transformations/#declarations","title":"Declarations","text":""},{"location":"attributes/transformations/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic value transformations:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :options, transform: :compact_blank\nend\n</code></pre>"},{"location":"attributes/transformations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic value transformations:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, transform: proc { |v| v * 2 }\n\n  # Lambda\n  attribute :compression, transform: -&gt;(v) { v.to_s.upcase.strip[0..2]  }\nend\n</code></pre>"},{"location":"attributes/transformations/#class-or-module","title":"Class or Module","text":"<p>Use any object that responds to <code>call</code> for reusable transformation logic:</p> <pre><code>class EmailNormalizer\n  def call(value)\n    value.to_s.downcase.strip\n  end\nend\n\nclass ProcessContacts &lt; CMDx::Task\n  # Class or Module\n  attribute :email, transform: EmailNormalizer\n\n  # Instance\n  attribute :email, transform: EmailNormalizer.new\nend\n</code></pre>"},{"location":"attributes/transformations/#validations","title":"Validations","text":"<p>Validations run on transformed values, ensuring data consistency:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, type: :integer, transform: proc { |v| v.clamp(1, 5) }\n\n  # Validations\n  optional :frequency, transform: :downcase, inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/validations/","title":"Attributes - Validations","text":"<p>Ensure inputs meet requirements before execution. Validations run after coercions, giving you declarative data integrity checks.</p> <p>See Global Configuration for custom validator setup.</p>"},{"location":"attributes/validations/#usage","title":"Usage","text":"<p>Define validation rules on attributes to enforce data requirements:</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  # Required field with presence validation\n  attribute :user_id, presence: true\n\n  # String with length constraints\n  attribute :preferences, length: { minimum: 10, maximum: 500 }\n\n  # Numeric range validation\n  attribute :tier_level, inclusion: { in: 1..5 }\n\n  # Format validation for email\n  attribute :contact_email, format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    user_id       #=&gt; \"98765\"\n    preferences   #=&gt; \"Send weekly digest emails\"\n    tier_level    #=&gt; 3\n    contact_email #=&gt; \"user@company.com\"\n  end\nend\n\nProcessSubscription.execute(\n  user_id: \"98765\",\n  preferences: \"Send weekly digest emails\",\n  tier_level: 3,\n  contact_email: \"user@company.com\"\n)\n</code></pre> <p>Tip</p> <p>Validations run after coercions, so you can validate the final coerced values rather than raw input.</p>"},{"location":"attributes/validations/#built-in-validators","title":"Built-in Validators","text":""},{"location":"attributes/validations/#common-options","title":"Common Options","text":"<p>This list of options is available to all validators:</p> Option Description <code>:allow_nil</code> Skip validation when value is <code>nil</code> <code>:if</code> Symbol, proc, lambda, or callable determining when to validate <code>:unless</code> Symbol, proc, lambda, or callable determining when to skip validation <code>:message</code> Custom error message for validation failures"},{"location":"attributes/validations/#exclusion","title":"Exclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :status, exclusion: { in: %w[recalled archived] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of forbidden values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value exclusions <code>:in_message</code> Custom message for range-based exclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#format","title":"Format","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :sku, format: /\\A[A-Z]{3}-[0-9]{4}\\z/\n\n  attribute :sku, format: { with: /\\A[A-Z]{3}-[0-9]{4}\\z/ }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>regexp</code> Alias for :with option <code>:with</code> Regex pattern that the value must match <code>:without</code> Regex pattern that the value must not match"},{"location":"attributes/validations/#inclusion","title":"Inclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :availability, inclusion: { in: %w[available limited] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of allowed values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value inclusions <code>:in_message</code> Custom message for range-based inclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#length","title":"Length","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :title, length: { within: 5..100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the length must fall within (inclusive) <code>:not_within</code> Range that the length must not fall within <code>:in</code> Alias for :within <code>:not_in</code> Range that the length must not fall within <code>:min</code> Minimum allowed length <code>:max</code> Maximum allowed length <code>:is</code> Exact required length <code>:is_not</code> Length that is not allowed <code>:within_message</code> Custom message for within/range validations <code>:in_message</code> Custom message for :in validation <code>:not_within_message</code> Custom message for not_within validation <code>:not_in_message</code> Custom message for not_in validation <code>:min_message</code> Custom message for minimum length validation <code>:max_message</code> Custom message for maximum length validation <code>:is_message</code> Custom message for exact length validation <code>:is_not_message</code> Custom message for is_not validation"},{"location":"attributes/validations/#numeric","title":"Numeric","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :word_count, numeric: { min: 100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the value must fall within (inclusive) <code>:not_within</code> Range that the value must not fall within <code>:in</code> Alias for :within option <code>:not_in</code> Alias for :not_within option <code>:min</code> Minimum allowed value (inclusive, &gt;=) <code>:max</code> Maximum allowed value (inclusive, &lt;=) <code>:is</code> Exact value that must match <code>:is_not</code> Value that must not match <code>:within_message</code> Custom message for range validations <code>:not_within_message</code> Custom message for exclusion validations <code>:min_message</code> Custom message for minimum validation <code>:max_message</code> Custom message for maximum validation <code>:is_message</code> Custom message for exact match validation <code>:is_not_message</code> Custom message for exclusion validation"},{"location":"attributes/validations/#presence","title":"Presence","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :content, presence: true\n\n  attribute :content, presence: { message: \"cannot be blank\" }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>true</code> Ensures value is not nil, empty string, or whitespace"},{"location":"attributes/validations/#declarations","title":"Declarations","text":"<p>Important</p> <p>Custom validators must raise <code>CMDx::ValidationError</code> with a descriptive message.</p>"},{"location":"attributes/validations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple validation logic:</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  # Proc\n  register :validator, :api_key, proc do |value, options = {}|\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\n\n  # Lambda\n  register :validator, :api_key, -&gt;(value, options = {}) {\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/validations/#class-or-module","title":"Class or Module","text":"<p>Register custom validation logic for specialized requirements:</p> <pre><code>class ApiKeyValidator\n  def self.call(value, options = {})\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\nend\n\nclass SetupApplication &lt; CMDx::Task\n  register :validator, :api_key, ApiKeyValidator\n\n  attribute :access_key, api_key: true\nend\n</code></pre>"},{"location":"attributes/validations/#removals","title":"Removals","text":"<p>Remove unwanted validators:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one validator. Use multiple calls for batch removals.</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  deregister :validator, :api_key\nend\n</code></pre>"},{"location":"attributes/validations/#error-handling","title":"Error Handling","text":"<p>Validation failures provide detailed, structured error messages:</p> <pre><code>class CreateProject &lt; CMDx::Task\n  attribute :project_name, presence: true, length: { minimum: 3, maximum: 50 }\n  attribute :budget, numeric: { greater_than: 1000, less_than: 1000000 }\n  attribute :priority, inclusion: { in: [:low, :medium, :high] }\n  attribute :contact_email, format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = CreateProject.execute(\n  project_name: \"AB\",           # Too short\n  budget: 500,                  # Too low\n  priority: :urgent,            # Not in allowed list\n  contact_email: \"invalid-email\"    # Invalid format\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"project_name is too short (minimum is 3 characters). budget must be greater than 1000. priority is not included in the list. contact_email is invalid.\",\n                #       messages: {\n                #         project_name: [\"is too short (minimum is 3 characters)\"],\n                #         budget: [\"must be greater than 1000\"],\n                #         priority: [\"is not included in the list\"],\n                #         contact_email: [\"is invalid\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"basics/chain/","title":"Basics - Chain","text":"<p>Chains automatically track related task executions within a thread. Think of them as execution traces that help you understand what happened and in what order.</p>"},{"location":"basics/chain/#management","title":"Management","text":"<p>Each thread maintains its own isolated chain using thread-local storage.</p> <p>Warning</p> <p>Chains are thread-local. Don't share chain references across threads\u2014it causes race conditions.</p> <pre><code># Thread A\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch1.csv\")\n  result.chain.id    #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nend\n\n# Thread B (completely separate chain)\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch2.csv\")\n  result.chain.id    #=&gt; \"z3a42b95-c821-7892-b156-dd7c921fe2a3\"\nend\n\n# Access current thread's chain\nCMDx::Chain.current  #=&gt; Returns current chain or nil\nCMDx::Chain.clear    #=&gt; Clears current thread's chain\n</code></pre>"},{"location":"basics/chain/#links","title":"Links","text":"<p>Tasks automatically create or join the current thread's chain:</p> <p>Important</p> <p>Chain management is automatic\u2014no manual lifecycle handling needed.</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    # First task creates new chain\n    result1 = ValidateHeaders.execute(file_path: context.file_path)\n    result1.chain.id           #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\n    result1.chain.results.size #=&gt; 1\n\n    # Second task joins existing chain\n    result2 = SendNotification.execute(to: \"admin@company.com\")\n    result2.chain.id == result1.chain.id  #=&gt; true\n    result2.chain.results.size            #=&gt; 2\n\n    # Both results reference the same chain\n    result1.chain.results == result2.chain.results #=&gt; true\n  end\nend\n</code></pre>"},{"location":"basics/chain/#inheritance","title":"Inheritance","text":"<p>Subtasks automatically inherit the current thread's chain, building a unified execution trail:</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    context.dataset = Dataset.find(context.dataset_id)\n\n    # Subtasks automatically inherit current chain\n    ValidateSchema.execute\n    TransformData.execute!(context)\n    SaveToDatabase.execute(dataset_id: context.dataset_id)\n  end\nend\n\nresult = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# All tasks share the same chain\nchain.results.size #=&gt; 4 (main task + 3 subtasks)\nchain.results.map { |r| r.task.class }\n#=&gt; [ImportDataset, ValidateSchema, TransformData, SaveToDatabase]\n</code></pre>"},{"location":"basics/chain/#structure","title":"Structure","text":"<p>Chains expose comprehensive execution information:</p> <p>Important</p> <p>Chain state reflects the first (outermost) task result. Subtasks maintain their own states.</p> <pre><code>result = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# Chain identification\nchain.id      #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nchain.results #=&gt; Array of all results in execution order\n\n# State delegation (from first/outer-most result)\nchain.state   #=&gt; \"complete\"\nchain.status  #=&gt; \"success\"\nchain.outcome #=&gt; \"success\"\n\n# Access individual results\nchain.results.each_with_index do |result, index|\n  puts \"#{index}: #{result.task.class} - #{result.status}\"\nend\n</code></pre>"},{"location":"basics/context/","title":"Basics - Context","text":"<p>Context is your data container for inputs, intermediate values, and outputs. It makes sharing data between tasks effortless.</p>"},{"location":"basics/context/#assigning-data","title":"Assigning Data","text":"<p>Context automatically captures all task inputs, normalizing keys to symbols:</p> <pre><code># Direct execution\nCalculateShipping.execute(weight: 2.5, destination: \"CA\")\n\n# Instance creation\nCalculateShipping.new(weight: 2.5, \"destination\" =&gt; \"CA\")\n</code></pre> <p>Important</p> <p>String keys convert to symbols automatically. Prefer symbols for consistency.</p>"},{"location":"basics/context/#accessing-data","title":"Accessing Data","text":"<p>Access context data using method notation, hash keys, or safe accessors:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Method style access (preferred)\n    weight = context.weight\n    destination = context.destination\n\n    # Hash style access\n    service_type = context[:service_type]\n    options = context[\"options\"]\n\n    # Safe access with defaults\n    rush_delivery = context.fetch!(:rush_delivery, false)\n    carrier = context.dig(:options, :carrier)\n\n    # Shorter alias\n    cost = ctx.weight * ctx.rate_per_pound  # ctx aliases context\n  end\nend\n</code></pre> <p>Important</p> <p>Undefined attributes return <code>nil</code> instead of raising errors\u2014perfect for optional data.</p>"},{"location":"basics/context/#modifying-context","title":"Modifying Context","text":"<p>Context supports dynamic modification during task execution:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Direct assignment\n    context.carrier = Carrier.find_by(code: context.carrier_code)\n    context.package = Package.new(weight: context.weight)\n    context.calculated_at = Time.now\n\n    # Hash-style assignment\n    context[:status] = \"calculating\"\n    context[\"tracking_number\"] = \"SHIP#{SecureRandom.hex(6)}\"\n\n    # Conditional assignment\n    context.insurance_included ||= false\n\n    # Batch updates\n    context.merge!(\n      status: \"completed\",\n      shipping_cost: calculate_cost,\n      estimated_delivery: Time.now + 3.days\n    )\n\n    # Remove sensitive data\n    context.delete!(:credit_card_token)\n  end\n\n  private\n\n  def calculate_cost\n    base_rate = context.weight * context.rate_per_pound\n    base_rate + (base_rate * context.tax_percentage)\n  end\nend\n</code></pre> <p>Tip</p> <p>Use context for both input values and intermediate results. This creates natural data flow through your task execution pipeline.</p>"},{"location":"basics/context/#data-sharing","title":"Data Sharing","text":"<p>Share context across tasks for seamless data flow:</p> <pre><code># During execution\nclass CalculateShipping &lt; CMDx::Task\n  def work\n    # Validate shipping data\n    validation_result = ValidateAddress.execute(context)\n\n    # Via context\n    CalculateInsurance.execute(context)\n\n    # Via result\n    NotifyShippingCalculated.execute(validation_result)\n\n    # Context now contains accumulated data from all tasks\n    context.address_validated    #=&gt; true (from validation)\n    context.insurance_calculated #=&gt; true (from insurance)\n    context.notification_sent    #=&gt; true (from notification)\n  end\nend\n\n# After execution\nresult = CalculateShipping.execute(destination: \"New York, NY\")\n\nCreateShippingLabel.execute(result)\n</code></pre>"},{"location":"basics/execution/","title":"Basics - Execution","text":"<p>CMDx offers two execution methods with different error handling approaches. Choose based on your needs: safe result handling or exception-based control flow.</p>"},{"location":"basics/execution/#execution-methods","title":"Execution Methods","text":"<p>Both methods return results, but handle failures differently:</p> Method Returns Exceptions Use Case <code>execute</code> Always returns <code>CMDx::Result</code> Never raises Predictable result handling <code>execute!</code> Returns <code>CMDx::Result</code> on success Raises <code>CMDx::Fault</code> when skipped or failed Exception-based control flow"},{"location":"basics/execution/#non-bang-execution","title":"Non-bang Execution","text":"<p>Always returns a <code>CMDx::Result</code>, never raises exceptions. Perfect for most use cases.</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Check execution state\nresult.success?         #=&gt; true/false\nresult.failed?          #=&gt; true/false\nresult.skipped?         #=&gt; true/false\n\n# Access result data\nresult.context.email    #=&gt; \"user@example.com\"\nresult.state            #=&gt; \"complete\"\nresult.status           #=&gt; \"success\"\n</code></pre>"},{"location":"basics/execution/#bang-execution","title":"Bang Execution","text":"<p>Raises <code>CMDx::Fault</code> exceptions on failure or skip. Returns results only on success.</p> Exception Raised When <code>CMDx::FailFault</code> Task execution fails <code>CMDx::SkipFault</code> Task execution is skipped <p>Important</p> <p>Behavior depends on <code>task_breakpoints</code> or <code>workflow_breakpoints</code> config. Default: only failures raise exceptions.</p> <pre><code>begin\n  result = CreateAccount.execute!(email: \"user@example.com\")\n  SendWelcomeEmail.execute(result.context)\nrescue CMDx::FailFault =&gt; e\n  ScheduleAccountRetryJob.perform_later(e.result.context.email)\nrescue CMDx::SkipFault =&gt; e\n  Rails.logger.info(\"Account creation skipped: #{e.result.reason}\")\nrescue Exception =&gt; e\n  ErrorTracker.capture(unhandled_exception: e)\nend\n</code></pre>"},{"location":"basics/execution/#direct-instantiation","title":"Direct Instantiation","text":"<p>Tasks can be instantiated directly for advanced use cases, testing, and custom execution patterns:</p> <pre><code># Direct instantiation\ntask = CreateAccount.new(email: \"user@example.com\", send_welcome: true)\n\n# Access properties before execution\ntask.id                      #=&gt; \"abc123...\" (unique task ID)\ntask.context.email           #=&gt; \"user@example.com\"\ntask.context.send_welcome    #=&gt; true\ntask.result.state            #=&gt; \"initialized\"\ntask.result.status           #=&gt; \"success\"\n\n# Manual execution\ntask.execute\n# or\ntask.execute!\n\ntask.result.success?         #=&gt; true/false\n</code></pre>"},{"location":"basics/execution/#result-details","title":"Result Details","text":"<p>The <code>Result</code> object provides comprehensive execution information:</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Execution metadata\nresult.id           #=&gt; \"abc123...\"  (unique execution ID)\nresult.task         #=&gt; CreateAccount instance (frozen)\nresult.chain        #=&gt; Task execution chain\n\n# Context and metadata\nresult.context      #=&gt; Context with all task data\nresult.metadata     #=&gt; Hash with execution metadata\n</code></pre>"},{"location":"basics/setup/","title":"Basics - Setup","text":"<p>Tasks are the heart of CMDx\u2014self-contained units of business logic with built-in validation, error handling, and execution tracking.</p>"},{"location":"basics/setup/#structure","title":"Structure","text":"<p>Tasks need only two things: inherit from <code>CMDx::Task</code> and define a <code>work</code> method:</p> <pre><code>class ValidateDocument &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Without a <code>work</code> method, execution raises <code>CMDx::UndefinedMethodError</code>.</p> <pre><code>class IncompleteTask &lt; CMDx::Task\n  # No `work` method defined\nend\n\nIncompleteTask.execute #=&gt; raises CMDx::UndefinedMethodError\n</code></pre>"},{"location":"basics/setup/#inheritance","title":"Inheritance","text":"<p>Share configuration across tasks using inheritance:</p> <pre><code>class ApplicationTask &lt; CMDx::Task\n  register :middleware, SecurityMiddleware\n\n  before_execution :initialize_request_tracking\n\n  attribute :session_id\n\n  private\n\n  def initialize_request_tracking\n    context.tracking_id ||= SecureRandom.uuid\n  end\nend\n\nclass SyncInventory &lt; ApplicationTask\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"basics/setup/#lifecycle","title":"Lifecycle","text":"<p>Tasks follow a predictable execution pattern:</p> <p>Caution</p> <p>Tasks are single-use objects. Once executed, they're frozen and immutable.</p> Stage State Status Description Instantiation <code>initialized</code> <code>success</code> Task created with context Validation <code>executing</code> <code>success</code>/<code>failed</code> Attributes validated Execution <code>executing</code> <code>success</code>/<code>failed</code>/<code>skipped</code> <code>work</code> method runs Completion <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Result finalized Freezing <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Task becomes immutable"},{"location":"interruptions/exceptions/","title":"Interruptions - Exceptions","text":"<p>Exception handling differs between <code>execute</code> and <code>execute!</code>. Choose the method that matches your error handling strategy.</p>"},{"location":"interruptions/exceptions/#exception-handling","title":"Exception Handling","text":"<p>Important</p> <p>Prefer <code>skip!</code> and <code>fail!</code> over raising exceptions\u2014they signal intent more clearly.</p>"},{"location":"interruptions/exceptions/#non-bang-execution","title":"Non-bang execution","text":"<p>Captures all exceptions and returns them as failed results:</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nresult = CompressDocument.execute(document_id: \"unknown-doc-id\")\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.failed?  #=&gt; true\nresult.reason   #=&gt; \"[ActiveRecord::NotFoundError] record not found\"\nresult.cause    #=&gt; &lt;ActiveRecord::NotFoundError&gt;\n</code></pre> <p>Note</p> <p>Use <code>exception_handler</code> with <code>execute</code> to send exceptions to APM tools before they become failed results.</p>"},{"location":"interruptions/exceptions/#bang-execution","title":"Bang execution","text":"<p>Lets exceptions propagate naturally for standard Ruby error handling:</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nbegin\n  CompressDocument.execute!(document_id: \"unknown-doc-id\")\nrescue ActiveRecord::NotFoundError =&gt; e\n  puts \"Handle exception: #{e.message}\"\nend\n</code></pre>"},{"location":"interruptions/faults/","title":"Interruptions - Faults","text":"<p>Faults are exceptions raised by <code>execute!</code> when tasks halt. They carry rich context about execution state, enabling sophisticated error handling patterns.</p>"},{"location":"interruptions/faults/#fault-types","title":"Fault Types","text":"Type Triggered By Use Case <code>CMDx::Fault</code> Base class Catch-all for any interruption <code>CMDx::SkipFault</code> <code>skip!</code> method Optional processing, early returns <code>CMDx::FailFault</code> <code>fail!</code> method Validation errors, processing failures <p>Important</p> <p>All faults inherit from <code>CMDx::Fault</code> and expose result, task, context, and chain data.</p>"},{"location":"interruptions/faults/#fault-handling","title":"Fault Handling","text":"<pre><code>begin\n  ProcessTicket.execute!(ticket_id: 456)\nrescue CMDx::SkipFault =&gt; e\n  logger.info \"Ticket processing skipped: #{e.message}\"\n  schedule_retry(e.context.ticket_id)\nrescue CMDx::FailFault =&gt; e\n  logger.error \"Ticket processing failed: #{e.message}\"\n  notify_admin(e.context.assigned_agent, e.result.metadata[:error_code])\nrescue CMDx::Fault =&gt; e\n  logger.warn \"Ticket processing interrupted: #{e.message}\"\n  rollback_changes\nend\n</code></pre>"},{"location":"interruptions/faults/#data-access","title":"Data Access","text":"<p>Access rich execution data from fault exceptions:</p> <pre><code>begin\n  LicenseActivation.execute!(license_key: key, machine_id: machine)\nrescue CMDx::Fault =&gt; e\n  # Result information\n  e.result.state     #=&gt; \"interrupted\"\n  e.result.status    #=&gt; \"failed\" or \"skipped\"\n  e.result.reason    #=&gt; \"License key already activated\"\n\n  # Task information\n  e.task.class       #=&gt; &lt;LicenseActivation&gt;\n  e.task.id          #=&gt; \"abc123...\"\n\n  # Context data\n  e.context.license_key #=&gt; \"ABC-123-DEF\"\n  e.context.machine_id  #=&gt; \"[FILTERED]\"\n\n  # Chain information\n  e.chain.id         #=&gt; \"def456...\"\n  e.chain.size       #=&gt; 3\nend\n</code></pre>"},{"location":"interruptions/faults/#advanced-matching","title":"Advanced Matching","text":""},{"location":"interruptions/faults/#task-specific-matching","title":"Task-Specific Matching","text":"<p>Handle faults only from specific tasks using <code>for?</code>:</p> <pre><code>begin\n  DocumentWorkflow.execute!(document_data: data)\nrescue CMDx::FailFault.for?(FormatValidator, ContentProcessor) =&gt; e\n  # Handle only document-related failures\n  retry_with_alternate_parser(e.context)\nrescue CMDx::SkipFault.for?(VirusScanner, ContentFilter) =&gt; e\n  # Handle security-related skips\n  quarantine_for_review(e.context.document_id)\nend\n</code></pre>"},{"location":"interruptions/faults/#custom-logic-matching","title":"Custom Logic Matching","text":"<pre><code>begin\n  ReportGenerator.execute!(report: report_data)\nrescue CMDx::Fault.matches? { |f| f.context.data_size &gt; 10_000 } =&gt; e\n  escalate_large_dataset_failure(e)\nrescue CMDx::FailFault.matches? { |f| f.result.metadata[:attempt_count] &gt; 3 } =&gt; e\n  abandon_report_generation(e)\nrescue CMDx::Fault.matches? { |f| f.result.metadata[:error_type] == \"memory\" } =&gt; e\n  increase_memory_and_retry(e)\nend\n</code></pre>"},{"location":"interruptions/faults/#fault-propagation","title":"Fault Propagation","text":"<p>Propagate failures with <code>throw!</code> to preserve context and maintain the error chain:</p>"},{"location":"interruptions/faults/#basic-propagation","title":"Basic Propagation","text":"<pre><code>class ReportGenerator &lt; CMDx::Task\n  def work\n    # Throw if skipped or failed\n    validation_result = DataValidator.execute(context)\n    throw!(validation_result)\n\n    # Only throw if skipped\n    check_permissions = CheckPermissions.execute(context)\n    throw!(check_permissions) if check_permissions.skipped?\n\n    # Only throw if failed\n    data_result = DataProcessor.execute(context)\n    throw!(data_result) if data_result.failed?\n\n    # Continue processing\n    generate_report\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#additional-metadata","title":"Additional Metadata","text":"<pre><code>class BatchProcessor &lt; CMDx::Task\n  def work\n    step_result = FileValidation.execute(context)\n\n    if step_result.failed?\n      throw!(step_result, {\n        batch_stage: \"validation\",\n        can_retry: true,\n        next_step: \"file_repair\"\n      })\n    end\n\n    continue_batch\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#chain-analysis","title":"Chain Analysis","text":"<p>Trace fault origins and propagation through the execution chain:</p> <pre><code>result = DocumentWorkflow.execute(invalid_data)\n\nif result.failed?\n  # Trace the original failure\n  original = result.caused_failure\n  if original\n    puts \"Original failure: #{original.task.class.name}\"\n    puts \"Reason: #{original.reason}\"\n  end\n\n  # Find what propagated the failure\n  thrower = result.threw_failure\n  puts \"Propagated by: #{thrower.task.class.name}\" if thrower\n\n  # Analyze failure type\n  case\n  when result.caused_failure?\n    puts \"This task was the original source\"\n  when result.threw_failure?\n    puts \"This task propagated a failure\"\n  when result.thrown_failure?\n    puts \"This task failed due to propagation\"\n  end\nend\n</code></pre>"},{"location":"interruptions/halt/","title":"Interruptions - Halt","text":"<p>Stop task execution intentionally using <code>skip!</code> or <code>fail!</code>. Both methods signal clear intent about why execution stopped.</p>"},{"location":"interruptions/halt/#skipping","title":"Skipping","text":"<p>Use <code>skip!</code> when the task doesn't need to run. It's a no-op, not an error.</p> <p>Important</p> <p>Skipped tasks are considered \"good\" outcomes\u2014they succeeded by doing nothing.</p> <pre><code>class ProcessInventory &lt; CMDx::Task\n  def work\n    # Without a reason\n    skip! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    # With a reason\n    skip!(\"Warehouse closed\") unless Time.now.hour.between?(8, 18)\n\n    inventory = Inventory.find(context.inventory_id)\n\n    if inventory.already_counted?\n      skip!(\"Inventory already counted today\")\n    else\n      inventory.count!\n    end\n  end\nend\n\nresult = ProcessInventory.execute(inventory_id: 456)\n\n# Executed\nresult.status #=&gt; \"skipped\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Warehouse closed\"\n</code></pre>"},{"location":"interruptions/halt/#failing","title":"Failing","text":"<p>Use <code>fail!</code> when the task can't complete successfully. It signals controlled, intentional failure:</p> <pre><code>class ProcessRefund &lt; CMDx::Task\n  def work\n    # Without a reason\n    fail! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    refund = Refund.find(context.refund_id)\n\n    # With a reason\n    if refund.expired?\n      fail!(\"Refund period has expired\")\n    elsif !refund.amount.positive?\n      fail!(\"Refund amount must be positive\")\n    else\n      refund.process!\n    end\n  end\nend\n\nresult = ProcessRefund.execute(refund_id: 789)\n\n# Executed\nresult.status #=&gt; \"failed\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Refund period has expired\"\n</code></pre>"},{"location":"interruptions/halt/#metadata-enrichment","title":"Metadata Enrichment","text":"<p>Enrich halt calls with metadata for better debugging and error handling:</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    license = License.find(context.license_id)\n\n    if license.already_renewed?\n      # Without metadata\n      skip!(\"License already renewed\")\n    end\n\n    unless license.renewal_eligible?\n      # With metadata\n      fail!(\n        \"License not eligible for renewal\",\n        error_code: \"LICENSE.NOT_ELIGIBLE\",\n        retry_after: Time.current + 30.days\n      )\n    end\n\n    process_renewal\n  end\nend\n\nresult = ProcessRenewal.execute(license_id: 567)\n\n# Without metadata\nresult.metadata #=&gt; {}\n\n# With metadata\nresult.metadata #=&gt; {\n                #     error_code: \"LICENSE.NOT_ELIGIBLE\",\n                #     retry_after: &lt;Time 30 days from now&gt;\n                #   }\n</code></pre>"},{"location":"interruptions/halt/#state-transitions","title":"State Transitions","text":"<p>Halt methods trigger specific state and status transitions:</p> Method State Status Outcome <code>skip!</code> <code>interrupted</code> <code>skipped</code> <code>good? = true</code>, <code>bad? = true</code> <code>fail!</code> <code>interrupted</code> <code>failed</code> <code>good? = false</code>, <code>bad? = true</code> <pre><code>result = ProcessRenewal.execute(license_id: 567)\n\n# State information\nresult.state        #=&gt; \"interrupted\"\nresult.status       #=&gt; \"skipped\" or \"failed\"\nresult.interrupted? #=&gt; true\nresult.complete?    #=&gt; false\n\n# Outcome categorization\nresult.good?        #=&gt; true for skipped, false for failed\nresult.bad?         #=&gt; true for both skipped and failed\n</code></pre>"},{"location":"interruptions/halt/#execution-behavior","title":"Execution Behavior","text":"<p>Halt methods behave differently depending on the call method used:</p>"},{"location":"interruptions/halt/#non-bang-execution","title":"Non-bang execution","text":"<p>Returns result object without raising exceptions:</p> <pre><code>result = ProcessRefund.execute(refund_id: 789)\n\ncase result.status\nwhen \"success\"\n  puts \"Refund processed: $#{result.context.refund.amount}\"\nwhen \"skipped\"\n  puts \"Refund skipped: #{result.reason}\"\nwhen \"failed\"\n  puts \"Refund failed: #{result.reason}\"\n  handle_refund_error(result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#bang-execution","title":"Bang execution","text":"<p>Raises exceptions for halt conditions based on <code>task_breakpoints</code> configuration:</p> <pre><code>begin\n  result = ProcessRefund.execute!(refund_id: 789)\n  puts \"Success: Refund processed\"\nrescue CMDx::SkipFault =&gt; e\n  puts \"Skipped: #{e.message}\"\nrescue CMDx::FailFault =&gt; e\n  puts \"Failed: #{e.message}\"\n  handle_refund_failure(e.result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#best-practices","title":"Best Practices","text":"<p>Always provide a reason for better debugging and clearer exception messages:</p> <pre><code># Good: Clear, specific reason\nskip!(\"Document processing paused for compliance review\")\nfail!(\"File format not supported by processor\", code: \"FORMAT_UNSUPPORTED\")\n\n# Acceptable: Generic, non-specific reason\nskip!(\"Paused\")\nfail!(\"Unsupported\")\n\n# Bad: Default, cannot determine reason\nskip! #=&gt; \"Unspecified\"\nfail! #=&gt; \"Unspecified\"\n</code></pre>"},{"location":"interruptions/halt/#manual-errors","title":"Manual Errors","text":"<p>For rare cases, manually add errors before halting:</p> <p>Important</p> <p>Manual errors don't stop execution\u2014you still need to call <code>fail!</code> or <code>skip!</code>.</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    if document.nonrenewable?\n      errors.add(:document, \"not renewable\")\n      fail!(\"document could not be renewed\")\n    else\n      document.renew!\n    end\n  end\nend\n</code></pre>"},{"location":"outcomes/result/","title":"Outcomes - Result","text":"<p>Results are your window into task execution. They expose everything: outcome, state, timing, context, and metadata.</p>"},{"location":"outcomes/result/#result-attributes","title":"Result Attributes","text":"<p>Access essential execution information:</p> <p>Important</p> <p>Results are immutable after execution completes.</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Object data\nresult.task     #=&gt; &lt;BuildApplication&gt;\nresult.context  #=&gt; &lt;CMDx::Context&gt;\nresult.chain    #=&gt; &lt;CMDx::Chain&gt;\n\n# Execution data\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\n\n# Fault data\nresult.reason   #=&gt; \"Build tool not found\"\nresult.cause    #=&gt; &lt;CMDx::FailFault&gt;\nresult.metadata #=&gt; { error_code: \"BUILD_TOOL.NOT_FOUND\" }\n</code></pre>"},{"location":"outcomes/result/#lifecycle-information","title":"Lifecycle Information","text":"<p>Check execution state and status with predicate methods:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# State predicates (execution lifecycle)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\nresult.executed?    #=&gt; true (execution finished)\n\n# Status predicates (execution outcome)\nresult.success?     #=&gt; true (successful execution)\nresult.failed?      #=&gt; false (no failure)\nresult.skipped?     #=&gt; false (not skipped)\n\n# Outcome categorization\nresult.good?        #=&gt; true (success or skipped)\nresult.bad?         #=&gt; false (skipped or failed)\n</code></pre>"},{"location":"outcomes/result/#outcome-analysis","title":"Outcome Analysis","text":"<p>Get a unified outcome string combining state and status:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\nresult.outcome #=&gt; \"success\" (state and status)\n</code></pre>"},{"location":"outcomes/result/#chain-analysis","title":"Chain Analysis","text":"<p>Trace fault origins and propagation:</p> <pre><code>result = DeploymentWorkflow.execute(app_name: \"webapp\")\n\nif result.failed?\n  # Find the original cause of failure\n  if original_failure = result.caused_failure\n    puts \"Root cause: #{original_failure.task.class.name}\"\n    puts \"Reason: #{original_failure.reason}\"\n  end\n\n  # Find what threw the failure to this result\n  if throwing_task = result.threw_failure\n    puts \"Failure source: #{throwing_task.task.class.name}\"\n    puts \"Reason: #{throwing_task.reason}\"\n  end\n\n  # Failure classification\n  result.caused_failure?  #=&gt; true if this result was the original cause\n  result.threw_failure?   #=&gt; true if this result threw a failure\n  result.thrown_failure?  #=&gt; true if this result received a thrown failure\nend\n</code></pre>"},{"location":"outcomes/result/#index-and-position","title":"Index and Position","text":"<p>Results track their position within execution chains:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Position in execution sequence\nresult.index #=&gt; 0 (first task in chain)\n\n# Access via chain\nresult.chain.results[result.index] == result #=&gt; true\n</code></pre>"},{"location":"outcomes/result/#block-yield","title":"Block Yield","text":"<p>Execute code with direct result access:</p> <pre><code>BuildApplication.execute(version: \"1.2.3\") do |result|\n  if result.success?\n    notify_deployment_ready(result)\n  elsif result.failed?\n    handle_build_failure(result)\n  else\n    log_skip_reason(result)\n  end\nend\n</code></pre>"},{"location":"outcomes/result/#handlers","title":"Handlers","text":"<p>Handle outcomes with functional-style methods. Handlers return the result for chaining:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Status-based handlers\nresult\n  .handle_success { |result| notify_deployment_ready(result) }\n  .handle_failed { |result| handle_build_failure(result) }\n  .handle_skipped { |result| log_skip_reason(result) }\n\n# State-based handlers\nresult\n  .handle_complete { |result| update_build_status(result) }\n  .handle_interrupted { |result| cleanup_partial_artifacts(result) }\n\n# Outcome-based handlers\nresult\n  .handle_good { |result| increment_success_counter(result) }\n  .handle_bad { |result| alert_operations_team(result) }\n</code></pre>"},{"location":"outcomes/result/#pattern-matching","title":"Pattern Matching","text":"<p>Use Ruby 3.0+ pattern matching for elegant outcome handling:</p> <p>Important</p> <p>Pattern matching works with both array and hash deconstruction.</p>"},{"location":"outcomes/result/#array-pattern","title":"Array Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin [\"complete\", \"success\"]\n  redirect_to build_success_page\nin [\"interrupted\", \"failed\"]\n  retry_build_with_backoff(result)\nin [\"interrupted\", \"skipped\"]\n  log_skip_and_continue\nend\n</code></pre>"},{"location":"outcomes/result/#hash-pattern","title":"Hash Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin { state: \"complete\", status: \"success\" }\n  celebrate_build_success\nin { status: \"failed\", metadata: { retryable: true } }\n  schedule_build_retry(result)\nin { bad: true, metadata: { reason: String =&gt; reason } }\n  escalate_build_error(\"Build failed: #{reason}\")\nend\n</code></pre>"},{"location":"outcomes/result/#pattern-guards","title":"Pattern Guards","text":"<pre><code>case result\nin { status: \"failed\", metadata: { attempts: n } } if n &lt; 3\n  retry_build_with_delay(result, n * 2)\nin { status: \"failed\", metadata: { attempts: n } } if n &gt;= 3\n  mark_build_permanently_failed(result)\nin { runtime: time } if time &gt; performance_threshold\n  investigate_build_performance(result)\nend\n</code></pre>"},{"location":"outcomes/states/","title":"Outcomes - States","text":"<p>States track where a task is in its execution lifecycle\u2014from creation through completion or interruption.</p>"},{"location":"outcomes/states/#definitions","title":"Definitions","text":"State Description <code>initialized</code> Task created but execution not yet started. Default state for new tasks. <code>executing</code> Task is actively running its business logic. Transient state during execution. <code>complete</code> Task finished execution successfully without any interruption or halt. <code>interrupted</code> Task execution was stopped due to a fault, exception, or explicit halt. <p>State-Status combinations:</p> State Status Meaning <code>initialized</code> <code>success</code> Task created, not yet executed <code>executing</code> <code>success</code> Task currently running <code>complete</code> <code>success</code> Task finished successfully <code>complete</code> <code>skipped</code> Task finished by skipping execution <code>interrupted</code> <code>failed</code> Task stopped due to failure <code>interrupted</code> <code>skipped</code> Task stopped by skip condition"},{"location":"outcomes/states/#transitions","title":"Transitions","text":"<p>Caution</p> <p>States are managed automatically\u2014never modify them manually.</p> <pre><code># Valid state transition flow\ninitialized \u2192 executing \u2192 complete    (successful execution)\ninitialized \u2192 executing \u2192 interrupted (skipped/failed execution)\n</code></pre>"},{"location":"outcomes/states/#predicates","title":"Predicates","text":"<p>Use state predicates to check the current execution lifecycle:</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state checks\nresult.initialized? #=&gt; false (after execution)\nresult.executing?   #=&gt; false (after execution)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\n\n# State categorization\nresult.executed?    #=&gt; true (complete OR interrupted)\n</code></pre>"},{"location":"outcomes/states/#handlers","title":"Handlers","text":"<p>Handle lifecycle events with state-based handlers. Use <code>handle_executed</code> for cleanup that runs regardless of outcome:</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state handlers\nresult\n  .handle_complete { |result| send_upload_notification(result) }\n  .handle_interrupted { |result| cleanup_temp_files(result) }\n  .handle_executed { |result| log_upload_metrics(result) }\n</code></pre>"},{"location":"outcomes/statuses/","title":"Outcomes - Statuses","text":"<p>Statuses represent the business outcome\u2014did the task succeed, skip, or fail? This differs from state, which tracks the execution lifecycle.</p>"},{"location":"outcomes/statuses/#definitions","title":"Definitions","text":"Status Description <code>success</code> Task execution completed successfully with expected business outcome. Default status for all tasks. <code>skipped</code> Task intentionally stopped execution because conditions weren't met or continuation was unnecessary. <code>failed</code> Task stopped execution due to business rule violations, validation errors, or exceptions."},{"location":"outcomes/statuses/#transitions","title":"Transitions","text":"<p>Important</p> <p>Status transitions are final and unidirectional. Once skipped or failed, tasks can't return to success.</p> <pre><code># Valid status transitions\nsuccess \u2192 skipped    # via skip!\nsuccess \u2192 failed     # via fail! or exception\n\n# Invalid transitions (will raise errors)\nskipped \u2192 success    # \u274c Cannot transition\nskipped \u2192 failed     # \u274c Cannot transition\nfailed \u2192 success     # \u274c Cannot transition\nfailed \u2192 skipped     # \u274c Cannot transition\n</code></pre>"},{"location":"outcomes/statuses/#predicates","title":"Predicates","text":"<p>Use status predicates to check execution outcomes:</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status checks\nresult.success? #=&gt; true/false\nresult.skipped? #=&gt; true/false\nresult.failed?  #=&gt; true/false\n\n# Outcome categorization\nresult.good?    #=&gt; true if success OR skipped\nresult.bad?     #=&gt; true if skipped OR failed (not success)\n</code></pre>"},{"location":"outcomes/statuses/#handlers","title":"Handlers","text":"<p>Branch business logic with status-based handlers. Use <code>handle_good</code> and <code>handle_bad</code> for success/skip vs failed outcomes:</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status handlers\nresult\n  .handle_success { |result| mark_notification_sent(result) }\n  .handle_skipped { |result| log_notification_skipped(result) }\n  .handle_failed { |result| queue_retry_notification(result) }\n\n# Outcome-based handlers\nresult\n  .handle_good { |result| update_message_stats(result) }\n  .handle_bad { |result| track_delivery_failure(result) }\n</code></pre>"}]}