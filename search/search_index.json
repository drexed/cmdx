{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CMDx","text":"<p>Build business logic that's powerful, predictable, and chaos-free.</p> <p> </p> <p>Ditch the messy service objects. CMDx helps you design business processes with clarity and consistency\u2014build faster, debug easier, and keep your sanity.</p>"},{"location":"#compose-execute-react-observe-cero-pattern","title":"Compose, Execute, React, Observe (CERO) pattern","text":"<p>CMDx encourages breaking business logic into composable tasks. Each task can be combined into larger workflows, executed with standardized flow control, and fully observed through logging, validations, and context.</p> <p>\ud83e\udde9 Compose \u2192 Define small, contract-driven tasks with typed attributes, validations, and natural workflow composition.</p> <p>\u26a1 Execute \u2192 Run tasks with clear outcomes, intentional halts, and pluggable behaviors via middlewares and callbacks.</p> <p>\ud83d\udd04 React \u2192 Adapt to outcomes by chaining follow-up tasks, handling faults, or shaping future flows.</p> <p>\ud83d\udd0d Observe \u2192 Capture immutable results, structured logs, and full execution chains for reliable tracing and insight.</p>"},{"location":"#installation","title":"Installation","text":"<p>Add this line to your application's Gemfile:</p> <pre><code>gem \"cmdx\"\n</code></pre> <p>And then execute:</p> <pre><code>bundle\n</code></pre> <p>Or install it yourself as:</p> <pre><code>gem install cmdx\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Here's how a quick 4 step process can open up a world of possibilities:</p>"},{"location":"#1-compose","title":"1. Compose","text":"<pre><code># Minimum Viable Task\n\nclass SendAnalyzedEmail &lt; CMDx::Task\n  def work\n    user = User.find(context.user_id)\n    MetricsMailer.analyzed(user).deliver_now\n  end\nend\n\n# Full Featured Task\n\nclass AnalyzeMetrics &lt; CMDx::Task\n  register :middleware, CMDx::Middlewares::Correlate, id: -&gt; { Current.request_id }\n\n  on_success :track_analysis_completion!\n\n  required :dataset_id, type: :integer, numeric: { min: 1 }\n  optional :analysis_type, default: \"standard\"\n\n  def work\n    if dataset.nil?\n      fail!(\"Dataset not found\", code: 404)\n    elsif dataset.unprocessed?\n      skip!(\"Dataset not ready for analysis\")\n    else\n      context.result = PValueAnalyzer.execute(dataset:, analysis_type:)\n      context.analyzed_at = Time.now\n\n      SendAnalyzedEmail.execute(user_id: Current.account.manager_id)\n    end\n  end\n\n  private\n\n  def dataset\n    @dataset ||= Dataset.find_by(id: dataset_id)\n  end\n\n  def track_analysis_completion!\n    dataset.update!(analysis_result_id: context.result.id)\n  end\nend\n</code></pre>"},{"location":"#2-execute","title":"2. Execute","text":"<pre><code>result = AnalyzeMetrics.execute(\n  dataset_id: 123,\n  \"analysis_type\" =&gt; \"advanced\"\n)\n</code></pre>"},{"location":"#3-react","title":"3. React","text":"<pre><code>if result.success?\n  puts \"Metrics analyzed at #{result.context.analyzed_at}\"\nelsif result.skipped?\n  puts \"Skipping analyzation due to: #{result.reason}\"\nelsif result.failed?\n  puts \"Analyzation failed due to: #{result.reason} with code #{result.metadata[:code]}\"\nend\n</code></pre>"},{"location":"#4-observe","title":"4. Observe","text":"<pre><code>I, [2022-07-17T18:42:37.000000 #3784] INFO -- CMDx:\nindex=1 chain_id=\"018c2b95-23j4-2kj3-32kj-3n4jk3n4jknf\" type=\"Task\" class=\"SendAnalyzedEmail\" state=\"complete\" status=\"success\" metadata={runtime: 347}\n\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"AnalyzeMetrics\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n</code></pre>"},{"location":"#ecosystem","title":"Ecosystem","text":"<ul> <li>cmdx-rspec - RSpec test matchers</li> </ul> <p>For backwards compatibility of certain functionality:</p> <ul> <li>cmdx-i18n - 85+ translations, <code>v1.5.0</code> - <code>v1.6.2</code></li> <li>cmdx-parallel - Parallel workflow tasks, <code>v1.6.1</code> - <code>v1.6.2</code></li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Bug reports and pull requests are welcome on GitHub at https://github.com/drexed/cmdx. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the Contributor Covenant code of conduct.</p>"},{"location":"#license","title":"License","text":"<p>The gem is available as open source under the terms of the MIT License.</p>"},{"location":"#code-of-conduct","title":"Code of Conduct","text":"<p>Everyone interacting in the CMDx project's codebases, issue trackers, chat rooms and mailing lists is expected to follow the code of conduct.</p>"},{"location":"callbacks/","title":"Callbacks","text":"<p>Callbacks provide precise control over task execution lifecycle, running custom logic at specific transition points. Callback callables have access to the same context and result information as the <code>execute</code> method, enabling rich integration patterns.</p> <p>Check out the Getting Started docs for global configuration.</p> <p>Important</p> <p>Callbacks execute in the order they are declared within each hook type. Multiple callbacks of the same type execute in declaration order (FIFO: first in, first out).</p>"},{"location":"callbacks/#available-callbacks","title":"Available Callbacks","text":"<p>Callbacks execute in precise lifecycle order. Here is the complete execution sequence:</p> <pre><code>1. before_validation           # Pre-validation setup\n2. before_execution            # Setup and preparation\n\n# --- Task#work executed ---\n\n3. on_[complete|interrupted]   # Based on execution state\n4. on_executed                 # Task finished (any outcome)\n5. on_[success|skipped|failed] # Based on execution status\n6. on_[good|bad]               # Based on outcome classification\n</code></pre>"},{"location":"callbacks/#declarations","title":"Declarations","text":""},{"location":"callbacks/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for simple callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  before_execution :find_reservation\n\n  # Batch declarations (works for any type)\n  on_complete :notify_guest, :update_availability\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def find_reservation\n    @reservation ||= Reservation.find(context.reservation_id)\n  end\n\n  def notify_guest\n    GuestNotifier.call(context.guest, result)\n  end\n\n  def update_availability\n    AvailabilityService.update(context.room_ids, result)\n  end\nend\n</code></pre>"},{"location":"callbacks/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for inline callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Proc\n  on_interrupted proc { ReservationSystem.pause! }\n\n  # Lambda\n  on_complete -&gt; { ReservationSystem.resume! }\nend\n</code></pre>"},{"location":"callbacks/#class-or-module","title":"Class or Module","text":"<p>Implement reusable callback logic in dedicated classes:</p> <pre><code>class BookingConfirmationCallback\n  def call(task)\n    if task.result.success?\n      MessagingApi.send_confirmation(task.context.guest)\n    else\n      MessagingApi.send_issue_alert(task.context.manager)\n    end\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # Class or Module\n  on_success BookingConfirmationCallback\n\n  # Instance\n  on_interrupted BookingConfirmationCallback.new\nend\n</code></pre>"},{"location":"callbacks/#conditional-execution","title":"Conditional Execution","text":"<p>Control callback execution with conditional logic:</p> <pre><code>class MessagingPermissionCheck\n  def call(task)\n    task.context.guest.can?(:receive_messages)\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # If and/or Unless\n  before_execution :notify_guest, if: :messaging_enabled?, unless: :messaging_blocked?\n\n  # Proc\n  on_failure :increment_failure, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Legacy\") }\n\n  # Lambda\n  on_success :ping_housekeeping, if: proc { context.rooms_need_cleaning? }\n\n  # Class or Module\n  on_complete :send_confirmation, unless: MessagingPermissionCheck\n\n  # Instance\n  on_complete :send_confirmation, if: MessagingPermissionCheck.new\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def messaging_enabled?\n    context.guest.messaging_preference == true\n  end\n\n  def messaging_blocked?\n    context.guest.communication_status == :blocked\n  end\nend\n</code></pre>"},{"location":"callbacks/#callback-removal","title":"Callback Removal","text":"<p>Remove callbacks at runtime for dynamic behavior control:</p> <p>Important</p> <p>Only one removal operation is allowed per <code>deregister</code> call. Multiple removals require separate calls.</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Symbol\n  deregister :callback, :before_execution, :notify_guest\n\n  # Class or Module (no instances)\n  deregister :callback, :on_complete, BookingConfirmationCallback\nend\n</code></pre>"},{"location":"deprecation/","title":"Task Deprecation","text":"<p>Task deprecation provides a systematic approach to managing legacy tasks in CMDx applications. The deprecation system enables controlled migration paths by issuing warnings, logging messages, or preventing execution of deprecated tasks entirely, helping teams maintain code quality while providing clear upgrade paths.</p>"},{"location":"deprecation/#modes","title":"Modes","text":""},{"location":"deprecation/#raise","title":"Raise","text":"<p><code>:raise</code> mode prevents task execution entirely. Use this for tasks that should no longer be used under any circumstances.</p> <p>Warning</p> <p>Use <code>:raise</code> mode carefully in production environments as it will break existing workflows immediately.</p> <pre><code>class ProcessObsoleteAPI &lt; CMDx::Task\n  settings(deprecated: :raise)\n\n  def work\n    # Will never execute...\n  end\nend\n\nresult = ProcessObsoleteAPI.execute\n#=&gt; raises CMDx::DeprecationError: \"ProcessObsoleteAPI usage prohibited\"\n</code></pre>"},{"location":"deprecation/#log","title":"Log","text":"<p><code>:log</code> mode allows continued usage while tracking deprecation warnings. Perfect for gradual migration scenarios where immediate replacement isn't feasible.</p> <pre><code>class ProcessLegacyFormat &lt; CMDx::Task\n  settings(deprecated: :log)\n\n  # Same\n  settings(deprecated: true)\n\n  def work\n    # Executes but logs deprecation warning...\n  end\nend\n\nresult = ProcessLegacyFormat.execute\nresult.successful? #=&gt; true\n\n# Deprecation warning appears in logs:\n# WARN -- : DEPRECATED: ProcessLegacyFormat - migrate to replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#warn","title":"Warn","text":"<p><code>:warn</code> mode issues Ruby warnings visible in development and testing environments. Useful for alerting developers without affecting production logging.</p> <pre><code>class ProcessOldData &lt; CMDx::Task\n  settings(deprecated: :warn)\n\n  def work\n    # Executes but emits Ruby warning...\n  end\nend\n\nresult = ProcessOldData.execute\nresult.successful? #=&gt; true\n\n# Ruby warning appears in stderr:\n# [ProcessOldData] DEPRECATED: migrate to a replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#declarations","title":"Declarations","text":""},{"location":"deprecation/#symbol-or-string","title":"Symbol or String","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecated: :raise)\n\n  # String\n  settings(deprecated: \"warn\")\nend\n</code></pre>"},{"location":"deprecation/#boolean-or-nil","title":"Boolean or Nil","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Deprecates with default :log mode\n  settings(deprecated: true)\n\n  # Skips deprecation\n  settings(deprecated: false)\n  settings(deprecated: nil)\nend\n</code></pre>"},{"location":"deprecation/#method","title":"Method","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecated: :deprecated?)\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def deprecated?\n    Time.now.year &gt; 2024 ? :raise : false\n  end\nend\n</code></pre>"},{"location":"deprecation/#proc-or-lambda","title":"Proc or Lambda","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Proc\n  settings(deprecated: proc { Rails.env.development? ? :raise : :log })\n\n  # Lambda\n  settings(deprecated: -&gt; { Current.tenant.legacy_mode? ? :warn : :raise })\nend\n</code></pre>"},{"location":"deprecation/#class-or-module","title":"Class or Module","text":"<pre><code>class OutdatedTaskDeprecator\n  def call(task)\n    task.class.name.include?(\"Outdated\")\n  end\nend\n\nclass OutdatedConnector &lt; CMDx::Task\n  # Class or Module\n  settings(deprecated: OutdatedTaskDeprecator)\n\n  # Instance\n  settings(deprecated: OutdatedTaskDeprecator.new)\nend\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>CMDx is a Ruby framework for building maintainable, observable business logic through composable command objects. Design robust workflows with automatic attribute validation, structured error handling, comprehensive logging, and intelligent execution flow control.</p> <p>Common challenges:</p> <ul> <li>Inconsistent patterns across implementations</li> <li>Minimal or no logging, making debugging painful</li> <li>Fragile designs that erode developer confidence</li> </ul> <p>Practical solutions:</p> <ul> <li>Establishes a consistent, standardized design</li> <li>Provides flow control and error handling</li> <li>Supports composable, reusable workflows</li> <li>Includes detailed logging for observability</li> <li>Defines input attributes with fallback defaults</li> <li>Adds validations and type coercions</li> <li>Plus many other developer-friendly tools</li> </ul>"},{"location":"getting_started/#compose-execute-react-observe-pattern","title":"Compose, Execute, React, Observe pattern","text":"<p>CMDx encourages breaking business logic into composable tasks. Each task can be combined into larger workflows, executed with standardized flow control, and fully observed through logging, validations, and context.</p> <ul> <li>Compose \u2192 Define small, contract-driven tasks with typed attributes, validations, and natural workflow composition.</li> <li>Execute \u2192 Run tasks with clear outcomes, intentional halts, and pluggable behaviors via middlewares and callbacks.</li> <li>React \u2192 Adapt to outcomes by chaining follow-up tasks, handling faults, or shaping future flows.</li> <li>Observe \u2192 Capture immutable results, structured logs, and full execution chains for reliable tracing and insight.</li> </ul>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Add CMDx to your Gemfile:</p> <pre><code>gem 'cmdx'\n</code></pre> <p>For Rails applications, generate the configuration:</p> <pre><code>rails generate cmdx:install\n</code></pre> <p>This creates <code>config/initializers/cmdx.rb</code> file.</p>"},{"location":"getting_started/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>CMDx follows a two-tier configuration hierarchy:</p> <ol> <li>Global Configuration: Framework-wide defaults</li> <li>Task Settings: Class-level overrides via <code>settings</code></li> </ol> <p>Important</p> <p>Task-level settings take precedence over global configuration. Settings are inherited from superclasses and can be overridden in subclasses.</p>"},{"location":"getting_started/#global-configuration","title":"Global Configuration","text":"<p>Global configuration settings apply to all tasks inherited from <code>CMDx::Task</code>. Globally these settings are initialized with sensible defaults.</p>"},{"location":"getting_started/#breakpoints","title":"Breakpoints","text":"<p>Raise <code>CMDx::Fault</code> when a task called with <code>execute!</code> returns a matching status.</p> <pre><code>CMDx.configure do |config|\n  # String or Array[String]\n  config.task_breakpoints = \"failed\"\nend\n</code></pre> <p>Workflow breakpoints stops execution and of workflow pipeline on the first task that returns a matching status and throws its <code>CMDx::Fault</code>.</p> <pre><code>CMDx.configure do |config|\n  # String or Array[String]\n  config.workflow_breakpoints = [\"skipped\", \"failed\"]\nend\n</code></pre>"},{"location":"getting_started/#backtraces","title":"Backtraces","text":"<p>Enable backtraces to be logged on any non-fault exceptions for improved debugging context. Run them through a cleaner to remove unwanted stack trace noise.</p> <p>Note</p> <p>The <code>backtrace_cleaner</code> is set to <code>Rails.backtrace_cleaner.clean</code> in a Rails env by default.</p> <pre><code>CMDx.configure do |config|\n  # Truthy\n  config.backtrace = true\n\n  # Via callable (must respond to `call(backtrace)`)\n  config.backtrace_cleaner = AdvanceCleaner.new\n\n  # Via proc or lambda\n  config.backtrace_cleaner = -&gt;(backtrace) { backtrace[0..5] }\nend\n</code></pre>"},{"location":"getting_started/#exception-handlers","title":"Exception Handlers","text":"<p>Use exception handlers are called on non-fault standard error based exceptions.</p> <p>Tip</p> <p>Use exception handlers to send errors to your APM of choice.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, exception)`)\n  config.exception_handler = NewRelicReporter\n\n  # Via proc or lambda\n  config.exception_handler = proc do |task, exception|\n    APMService.report(exception, extra_data: { task: task.name, id: task.id })\n  end\nend\n</code></pre>"},{"location":"getting_started/#logging","title":"Logging","text":"<pre><code>CMDx.configure do |config|\n  config.logger = CustomLogger.new($stdout)\nend\n</code></pre>"},{"location":"getting_started/#middlewares","title":"Middlewares","text":"<p>See the Middlewares docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, options)`)\n  config.middlewares.register CMDx::Middlewares::Timeout\n\n  # Via proc or lambda\n  config.middlewares.register proc { |task, options|\n    start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    result = yield\n    end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    Rails.logger.debug { \"task completed in #{((end_time - start_time) * 1000).round(2)}ms\" }\n    result\n  }\n\n  # With options\n  config.middlewares.register AuditTrailMiddleware, service_name: \"document_processor\"\n\n  # Remove middleware\n  config.middlewares.deregister CMDx::Middlewares::Timeout\nend\n</code></pre> <p>Note</p> <p>Middlewares are executed in registration order. Each middleware wraps the next, creating an execution chain around task logic.</p>"},{"location":"getting_started/#callbacks","title":"Callbacks","text":"<p>See the Callbacks docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via method\n  config.callbacks.register :before_execution, :initialize_user_session\n\n  # Via callable (must respond to `call(task)`)\n  config.callbacks.register :on_success, LogUserActivity\n\n  # Via proc or lambda\n  config.callbacks.register :on_complete, proc { |task|\n    execution_time = task.metadata[:runtime]\n    Metrics.timer(\"task.execution_time\", execution_time, tags: [\"task:#{task.class.name.underscore}\"])\n  }\n\n  # With options\n  config.callbacks.register :on_failure, :send_alert_notification, if: :critical_task?\n\n  # Remove callback\n  config.callbacks.deregister :on_success, LogUserActivity\nend\n</code></pre>"},{"location":"getting_started/#coercions","title":"Coercions","text":"<p>See the Attributes - Coercions docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.coercions.register :currency, CurrencyCoercion\n\n  # Via method (must match signature `def coordinates_coercion(value, options)`)\n  config.coercions.register :coordinates, :coordinates_coercion\n\n  # Via proc or lambda\n  config.coercions.register :tag_list, proc { |value, options|\n    delimiter = options[:delimiter] || ','\n    max_tags = options[:max_tags] || 50\n\n    tags = value.to_s.split(delimiter).map(&amp;:strip).reject(&amp;:empty?)\n    tags.first(max_tags)\n  }\n\n  # Remove coercion\n  config.coercions.deregister :currency\nend\n</code></pre>"},{"location":"getting_started/#validators","title":"Validators","text":"<p>See the Attributes - Validations docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.validators.register :username, UsernameValidator\n\n  # Via method (must match signature `def url_validator(value, options)`)\n  config.validators.register :url, :url_validator\n\n  # Via proc or lambda\n  config.validators.register :access_token, proc { |value, options|\n    expected_prefix = options[:prefix] || \"tok_\"\n    minimum_length = options[:min_length] || 40\n\n    value.start_with?(expected_prefix) &amp;&amp; value.length &gt;= minimum_length\n  }\n\n  # Remove validator\n  config.validators.deregister :username\nend\n</code></pre>"},{"location":"getting_started/#task-configuration","title":"Task Configuration","text":""},{"location":"getting_started/#settings","title":"Settings","text":"<p>Override global configuration for specific tasks using <code>settings</code>:</p> <pre><code>class GenerateInvoice &lt; CMDx::Task\n  settings(\n    # Global configuration overrides\n    task_breakpoints: [\"failed\"],                # Breakpoint override\n    workflow_breakpoints: [],                    # Breakpoint override\n    backtrace: true,                             # Toggle backtrace\n    backtrace_cleaner: -&gt;(bt) { bt[0..5] },      # Backtrace cleaner\n    logger: CustomLogger.new($stdout),           # Custom logger\n\n    # Task configuration settings\n    breakpoints: [\"failed\"],                     # Contextual pointer for :task_breakpoints and :workflow_breakpoints\n    log_level: :info,                            # Log level override\n    log_formatter: CMDx::LogFormatters::Json.new # Log formatter override\n    tags: [\"billing\", \"financial\"],              # Logging tags\n    deprecated: true,                            # Task deprecations\n    retries: 3,                                  # Non-fault exception retries\n    retry_on: [External::ApiError],              # List of exceptions to retry on\n    retry_jitter: 1                              # Space between retry iteration, eg: current retry num + 1\n  )\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Important</p> <p>Retries reuse the same context when executing its work. By default all <code>StandardErrors</code> will be retried if no <code>retry_on</code> option is passed.</p>"},{"location":"getting_started/#registrations","title":"Registrations","text":"<p>Register middlewares, callbacks, coercions, and validators on a specific task. Deregister options that should not be available.</p> <pre><code>class SendCampaignEmail &lt; CMDx::Task\n  # Middlewares\n  register :middleware, CMDx::Middlewares::Timeout\n  deregister :middleware, AuditTrailMiddleware\n\n  # Callbacks\n  register :callback, :on_complete, proc { |task|\n    runtime = task.metadata[:runtime]\n    Analytics.track(\"email_campaign.sent\", runtime, tags: [\"task:#{task.class.name}\"])\n  }\n  deregister :callback, :before_execution, :initialize_user_session\n\n  # Coercions\n  register :coercion, :currency, CurrencyCoercion\n  deregister :coercion, :coordinates\n\n  # Validators\n  register :validator, :username, :username_validator\n  deregister :validator, :url\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"getting_started/#configuration-management","title":"Configuration Management","text":""},{"location":"getting_started/#access","title":"Access","text":"<pre><code># Global configuration access\nCMDx.configuration.logger               #=&gt; &lt;Logger instance&gt;\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"]\nCMDx.configuration.middlewares.registry #=&gt; [&lt;Middleware&gt;, ...]\n\n# Task configuration access\nclass ProcessUpload &lt; CMDx::Task\n  settings(tags: [\"files\", \"storage\"])\n\n  def work\n    self.class.settings[:logger] #=&gt; Global configuration value\n    self.class.settings[:tags]   #=&gt; Task configuration value =&gt; [\"files\", \"storage\"]\n  end\nend\n</code></pre>"},{"location":"getting_started/#resetting","title":"Resetting","text":"<p>Warning</p> <p>Resetting configuration affects the entire application. Use primarily in test environments or during application initialization.</p> <pre><code># Reset to framework defaults\nCMDx.reset_configuration!\n\n# Verify reset\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"] (default)\nCMDx.configuration.middlewares.registry #=&gt; Empty registry\n\n# Commonly used in test setup (RSpec example)\nRSpec.configure do |config|\n  config.before(:each) do\n    CMDx.reset_configuration!\n  end\nend\n</code></pre>"},{"location":"getting_started/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:task ModerateBlogPost\n</code></pre> <p>This creates a new task file with the basic structure:</p> <pre><code># app/tasks/moderate_blog_post.rb\nclass ModerateBlogPost &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + noun for task names, eg: <code>ModerateBlogPost</code>, <code>ScheduleAppointment</code>, <code>ValidateDocument</code></p>"},{"location":"internationalization/","title":"Internationalization (i18n)","text":"<p>CMDx provides comprehensive internationalization support for all error messages, attribute validation failures, coercion errors, and fault messages. All user-facing text is automatically localized based on the current <code>I18n.locale</code>, ensuring your applications can serve global audiences with native-language error reporting.</p>"},{"location":"internationalization/#localization","title":"Localization","text":"<p>CMDx automatically localizes all error messages based on the <code>I18n.locale</code> setting.</p> <pre><code>class ProcessQuote &lt; CMDx::Task\n  attribute :price, type: :float\n\n  def work\n    # Your logic here...\n  end\nend\n\nI18n.with_locale(:fr) do\n  result = ProcessQuote.execute(price: \"invalid\")\n  result.metadata[:messages][:price] #=&gt; [\"impossible de contraindre en float\"]\nend\n</code></pre>"},{"location":"internationalization/#configuration","title":"Configuration","text":"<p>Localization is handled by the <code>I18n</code> gem. In Rails applications, locales are loaded automatically and managed via the <code>I18n.available_locales</code> setting.</p>"},{"location":"internationalization/#local-copies","title":"Local Copies","text":"<p>Execute the following command to copy any locale into the Rails applications <code>config/locales</code> directory:</p> <pre><code>rails generate cmdx:locale [LOCALE]\n\n# Eg: generate french locale\nrails generate cmdx:locale fr\n</code></pre>"},{"location":"internationalization/#available-locales","title":"Available Locales","text":"<ul> <li>af - Afrikaans</li> <li>ar - Arabic</li> <li>az - Azerbaijani</li> <li>be - Belarusian</li> <li>bg - Bulgarian</li> <li>bn - Bengali</li> <li>bs - Bosnian</li> <li>ca - Catalan</li> <li>cnr - Montenegrin</li> <li>cs - Czech</li> <li>cy - Welsh</li> <li>da - Danish</li> <li>de - German</li> <li>dz - Dzongkha</li> <li>el - Greek</li> <li>en - English</li> <li>eo - Esperanto</li> <li>es - Spanish</li> <li>et - Estonian</li> <li>eu - Basque</li> <li>fa - Persian</li> <li>fi - Finnish</li> <li>fr - French</li> <li>fy - Western Frisian</li> <li>gd - Scottish Gaelic</li> <li>gl - Galician</li> <li>he - Hebrew</li> <li>hi - Hindi</li> <li>hr - Croatian</li> <li>hu - Hungarian</li> <li>hy - Armenian</li> <li>id - Indonesian</li> <li>is - Icelandic</li> <li>it - Italian</li> <li>ja - Japanese</li> <li>ka - Georgian</li> <li>kk - Kazakh</li> <li>km - Khmer</li> <li>kn - Kannada</li> <li>ko - Korean</li> <li>lb - Luxembourgish</li> <li>lo - Lao</li> <li>lt - Lithuanian</li> <li>lv - Latvian</li> <li>mg - Malagasy</li> <li>mk - Macedonian</li> <li>ml - Malayalam</li> <li>mn - Mongolian</li> <li>mr-IN - Marathi (India)</li> <li>ms - Malay</li> <li>nb - Norwegian Bokm\u00e5l</li> <li>ne - Nepali</li> <li>nl - Dutch</li> <li>nn - Norwegian Nynorsk</li> <li>oc - Occitan</li> <li>or - Odia</li> <li>pa - Punjabi</li> <li>pl - Polish</li> <li>pt - Portuguese</li> <li>rm - Romansh</li> <li>ro - Romanian</li> <li>ru - Russian</li> <li>sc - Sardinian</li> <li>sk - Slovak</li> <li>sl - Slovenian</li> <li>sq - Albanian</li> <li>sr - Serbian</li> <li>st - Southern Sotho</li> <li>sv - Swedish</li> <li>sw - Swahili</li> <li>ta - Tamil</li> <li>te - Telugu</li> <li>th - Thai</li> <li>tl - Tagalog</li> <li>tr - Turkish</li> <li>tt - Tatar</li> <li>ug - Uyghur</li> <li>uk - Ukrainian</li> <li>ur - Urdu</li> <li>uz - Uzbek</li> <li>vi - Vietnamese</li> <li>wo - Wolof</li> <li>zh-CN - Chinese (Simplified)</li> <li>zh-HK - Chinese (Hong Kong)</li> <li>zh-TW - Chinese (Traditional)</li> <li>zh-YUE - Chinese (Yue)</li> </ul>"},{"location":"logging/","title":"Logging","text":"<p>CMDx provides comprehensive automatic logging for task execution with structured data, customizable formatters, and intelligent severity mapping. All task results are logged after completion with rich metadata for debugging and monitoring.</p>"},{"location":"logging/#formatters","title":"Formatters","text":"<p>CMDx supports multiple log formatters to integrate with various logging systems:</p> Formatter Use Case Output Style <code>Line</code> Traditional logging Single-line format <code>Json</code> Structured systems Compact JSON <code>KeyValue</code> Log parsing <code>key=value</code> pairs <code>Logstash</code> ELK stack JSON with @version/@timestamp <code>Raw</code> Minimal output Message content only <p>Sample output:</p> <pre><code>&lt;!-- Success (INFO level) --&gt;\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- GenerateInvoice:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"GenerateInvoice\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n\n&lt;!-- Skipped (WARN level) --&gt;\nW, [2022-07-17T18:43:15.000000 #3784] WARN -- ValidateCustomer:\nindex=1 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"ValidateCustomer\" state=\"interrupted\" status=\"skipped\" reason=\"Customer already validated\"\n\n&lt;!-- Failed (ERROR level) --&gt;\nE, [2022-07-17T18:43:15.000000 #3784] ERROR -- CalculateTax:\nindex=2 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"CalculateTax\"  state=\"interrupted\" status=\"failed\" metadata={error_code: \"TAX_SERVICE_UNAVAILABLE\"}\n\n&lt;!-- Failed Chain --&gt;\nE, [2022-07-17T18:43:15.000000 #3784] ERROR -- BillingWorkflow:\nindex=3 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"BillingWorkflow\"  state=\"interrupted\" status=\"failed\" caused_failure={index: 2, class: \"CalculateTax\", status: \"failed\"} threw_failure={index: 1, class: \"ValidateCustomer\", status: \"failed\"}\n</code></pre> <p>Tip</p> <p>Logging can be used as low-level eventing system, ingesting all tasks performed within a small action or long running request. This ie where correlation is especially handy.</p>"},{"location":"logging/#structure","title":"Structure","text":"<p>All log entries include comprehensive execution metadata. Field availability depends on execution context and outcome.</p>"},{"location":"logging/#core-fields","title":"Core Fields","text":"Field Description Example <code>severity</code> Log level <code>INFO</code>, <code>WARN</code>, <code>ERROR</code> <code>timestamp</code> ISO 8601 execution time <code>2022-07-17T18:43:15.000000</code> <code>pid</code> Process ID <code>3784</code>"},{"location":"logging/#task-information","title":"Task Information","text":"Field Description Example <code>index</code> Execution sequence position <code>0</code>, <code>1</code>, <code>2</code> <code>chain_id</code> Unique execution chain ID <code>018c2b95-b764-7615...</code> <code>type</code> Execution unit type <code>Task</code>, <code>Workflow</code> <code>class</code> Task class name <code>GenerateInvoiceTask</code> <code>id</code> Unique task instance ID <code>018c2b95-b764-7615...</code> <code>tags</code> Custom categorization <code>[\"billing\", \"financial\"]</code>"},{"location":"logging/#execution-data","title":"Execution Data","text":"Field Description Example <code>state</code> Lifecycle state <code>complete</code>, <code>interrupted</code> <code>status</code> Business outcome <code>success</code>, <code>skipped</code>, <code>failed</code> <code>outcome</code> Final classification <code>success</code>, <code>interrupted</code> <code>metadata</code> Custom task data <code>{order_id: 123, amount: 99.99}</code>"},{"location":"logging/#failure-chain","title":"Failure Chain","text":"Field Description <code>reason</code> Reason given for the stoppage <code>caused</code> Cause exception details <code>caused_failure</code> Original failing task details <code>threw_failure</code> Task that propagated the failure"},{"location":"logging/#usage","title":"Usage","text":"<p>Tasks have access to the frameworks logger.</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  def work\n    logger.debug { \"Activated feature flags: #{Features.active_flags}\" }\n    # Your logic here...\n    logger.info(\"Subscription processed\")\n  end\nend\n</code></pre>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Middleware provides Rack-style wrappers around task execution for cross-cutting concerns like authentication, logging, caching, and error handling.</p> <p>Check out the Getting Started docs for global configuration.</p>"},{"location":"middlewares/#order","title":"Order","text":"<p>Middleware executes in a nested fashion, creating an onion-like execution pattern:</p> <p>Note</p> <p>Middleware executes in the order they are registered, with the first registered middleware being the outermost wrapper.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  register :middleware, AuditMiddleware         # 1st: outermost wrapper\n  register :middleware, AuthorizationMiddleware # 2nd: middle wrapper\n  register :middleware, CacheMiddleware         # 3rd: innermost wrapper\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Execution flow:\n# 1. AuditMiddleware (before)\n# 2.   AuthorizationMiddleware (before)\n# 3.     CacheMiddleware (before)\n# 4.       [task execution]\n# 5.     CacheMiddleware (after)\n# 6.   AuthorizationMiddleware (after)\n# 7. AuditMiddleware (after)\n</code></pre>"},{"location":"middlewares/#declarations","title":"Declarations","text":""},{"location":"middlewares/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple middleware logic:</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Proc\n  register :middleware, proc do |task, options, &amp;block|\n    result = block.call\n    Analytics.track(result.status)\n    result\n  end\n\n  # Lambda\n  register :middleware, -&gt;(task, options, &amp;block) {\n    result = block.call\n    Analytics.track(result.status)\n    result\n  }\nend\n</code></pre>"},{"location":"middlewares/#class-or-module","title":"Class or Module","text":"<p>For complex middleware logic, use classes or modules:</p> <pre><code>class TelemetryMiddleware\n  def call(task, options)\n    result = yield\n    Telemetry.record(result.status)\n  ensure\n    result # Always return result\n  end\nend\n\nclass ProcessCampaign &lt; CMDx::Task\n  # Class or Module\n  register :middleware, TelemetryMiddleware\n\n  # Instance\n  register :middleware, TelemetryMiddleware.new\n\n  # With options\n  register :middleware, MonitoringMiddleware, service_key: ENV[\"MONITORING_KEY\"]\n  register :middleware, MonitoringMiddleware.new(ENV[\"MONITORING_KEY\"])\nend\n</code></pre>"},{"location":"middlewares/#removals","title":"Removals","text":"<p>Class and Module based declarations can be removed at a global and task level.</p> <p>Warning</p> <p>Only one removal operation is allowed per <code>deregister</code> call. Multiple removals require separate calls.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Class or Module (no instances)\n  deregister :middleware, TelemetryMiddleware\nend\n</code></pre>"},{"location":"middlewares/#built-in","title":"Built-in","text":""},{"location":"middlewares/#timeout","title":"Timeout","text":"<p>Ensures task execution doesn't exceed a specified time limit:</p> <pre><code>class ProcessReport &lt; CMDx::Task\n  # Default timeout: 3 seconds\n  register :middleware, CMDx::Middlewares::Timeout\n\n  # Seconds (takes Numeric, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, seconds: :max_processing_time\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, unless: -&gt; { self.class.name.include?(\"Quick\") }\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def max_processing_time\n    Rails.env.production? ? 2 : 10\n  end\nend\n\n# Slow task\nresult = ProcessReport.execute\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failure\"\nresult.reason   #=&gt; \"[CMDx::TimeoutError] execution exceeded 3 seconds\"\nresult.cause    #=&gt; &lt;CMDx::TimeoutError&gt;\nresult.metadata #=&gt; { limit: 3 }\n</code></pre>"},{"location":"middlewares/#correlate","title":"Correlate","text":"<p>Tags tasks with a global correlation ID for distributed tracing:</p> <pre><code>class ProcessExport &lt; CMDx::Task\n  # Default correlation ID generation\n  register :middleware, CMDx::Middlewares::Correlate\n\n  # Seconds (takes Object, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, id: proc { |task| task.context.session_id }\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, if: :correlation_enabled?\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def correlation_enabled?\n    ENV[\"CORRELATION_ENABLED\"] == \"true\"\n  end\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { correlation_id: \"550e8400-e29b-41d4-a716-446655440000\" }\n</code></pre>"},{"location":"middlewares/#runtime","title":"Runtime","text":"<p>The runtime middleware tags tasks with how long it took to execute the task. The calculation uses a monotonic clock and the time is returned in milliseconds.</p> <pre><code>class PerformanceMonitoringCheck\n  def call(task)\n    task.context.tenant.monitoring_enabled?\n  end\nend\n\nclass ProcessExport &lt; CMDx::Task\n  # Default timeout is 3 seconds\n  register :middleware, CMDx::Middlewares::Runtime\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Runtime, if: PerformanceMonitoringCheck\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { runtime: 1247 } (ms)\n</code></pre>"},{"location":"tips_and_tricks/","title":"Tips and Tricks","text":"<p>This guide covers advanced patterns and optimization techniques for getting the most out of CMDx in production applications.</p>"},{"location":"tips_and_tricks/#project-organization","title":"Project Organization","text":""},{"location":"tips_and_tricks/#directory-structure","title":"Directory Structure","text":"<p>Create a well-organized command structure for maintainable applications:</p> <pre><code>/app/\n\u2514\u2500\u2500 /tasks/\n    \u251c\u2500\u2500 /invoices/\n    \u2502   \u251c\u2500\u2500 calculate_tax.rb\n    \u2502   \u251c\u2500\u2500 validate_invoice.rb\n    \u2502   \u251c\u2500\u2500 send_invoice.rb\n    \u2502   \u2514\u2500\u2500 process_invoice.rb # workflow\n    \u251c\u2500\u2500 /reports/\n    \u2502   \u251c\u2500\u2500 generate_pdf.rb\n    \u2502   \u251c\u2500\u2500 compile_data.rb\n    \u2502   \u251c\u2500\u2500 export_csv.rb\n    \u2502   \u2514\u2500\u2500 create_reports.rb # workflow\n    \u251c\u2500\u2500 application_task.rb # base class\n    \u251c\u2500\u2500 authenticate_session.rb\n    \u2514\u2500\u2500 activate_account.rb\n</code></pre>"},{"location":"tips_and_tricks/#naming-conventions","title":"Naming Conventions","text":"<p>Follow consistent naming patterns for clarity and maintainability:</p> <pre><code># Verb + Noun\nclass ExportData &lt; CMDx::Task; end\nclass CompressFile &lt; CMDx::Task; end\nclass ValidateSchema &lt; CMDx::Task; end\n\n# Use present tense verbs for actions\nclass GenerateToken &lt; CMDx::Task; end      # \u2713 Good\nclass GeneratingToken &lt; CMDx::Task; end    # \u274c Avoid\nclass TokenGeneration &lt; CMDx::Task; end    # \u274c Avoid\n</code></pre>"},{"location":"tips_and_tricks/#story-telling","title":"Story Telling","text":"<p>Consider using descriptive methods to express the task\u2019s flow, rather than concentrating all logic inside the <code>work</code> method.</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    charge_payment_method\n    assign_to_warehouse\n    send_notification\n  end\n\n  private\n\n  def charge_payment_method\n    order.primary_payment_method.charge!\n  end\n\n  def assign_to_warehouse\n    order.ready_for_shipping!\n  end\n\n  def send_notification\n    if order.products_out_of_stock?\n      OrderMailer.pending(order).deliver\n    else\n      OrderMailer.preparing(order).deliver\n    end\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#style-guide","title":"Style Guide","text":"<p>Follow a style pattern for consistent task design:</p> <pre><code>class ExportReport &lt; CMDx::Task\n\n  # 1. Register functions\n  register :middleware, CMDx::Middlewares::Correlate\n  register :validator, :format, FormatValidator\n\n  # 2. Define callbacks\n  before_execution :find_report\n  on_complete :track_export_metrics, if: -&gt;(task) { Current.tenant.analytics? }\n\n  # 3. Declare attributes\n  attributes :user_id\n  required :report_id\n  optional :format_type\n\n  # 4. Define work method\n  def work\n    report.compile!\n    report.export!\n\n    context.exported_at = Time.now\n  end\n\n  # TIP: Favor private business logic to reduce the surface of the public API.\n  private\n\n  # 5. Build helper functions\n  def find_report\n    @report ||= Report.find(report_id)\n  end\n\n  def track_export_metrics\n    Analytics.increment(:report_exported)\n  end\n\nend\n</code></pre>"},{"location":"tips_and_tricks/#attribute-options","title":"Attribute Options","text":"<p>Use Rails <code>with_options</code> to reduce duplication and improve readability:</p> <pre><code>class ConfigureCompany &lt; CMDx::Task\n  # Apply common options to multiple attributes\n  with_options(type: :string, presence: true) do\n    attributes :website, format: { with: URI::DEFAULT_PARSER.make_regexp(%w[http https]) }\n    required :company_name, :industry\n    optional :description, format: { with: /\\A[\\w\\s\\-\\.,!?]+\\z/ }\n  end\n\n  # Nested attributes with shared prefix\n  required :headquarters do\n    with_options(prefix: :hq_) do\n      attributes :street, :city, :zip_code, type: :string\n      required :country, type: :string, inclusion: { in: VALID_COUNTRIES }\n      optional :region, type: :string\n    end\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#advanced-examples","title":"Advanced Examples","text":"<ul> <li>Active Record Query Tagging</li> <li>Paper Trail Whatdunnit</li> </ul>"},{"location":"workflows/","title":"Workflows","text":"<p>Workflow orchestrates sequential execution of multiple tasks in a linear pipeline. Workflows provide a declarative DSL for composing complex business logic from individual task components, with support for conditional execution, context propagation, and configurable halt behavior.</p>"},{"location":"workflows/#declarations","title":"Declarations","text":"<p>Tasks execute sequentially in declaration order (FIFO). The workflow context propagates to each task, allowing access to data from previous executions.</p> <p>Important</p> <p>Do NOT define a <code>work</code> method in workflow tasks. The included module automatically provides the execution logic.</p>"},{"location":"workflows/#task","title":"Task","text":"<pre><code>class OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateUserProfile\n  task SetupAccountPreferences\n\n  tasks SendWelcomeEmail, SendWelcomeSms, CreateDashboard\nend\n</code></pre> <p>Tip</p> <p>Execute tasks in parallel via the cmdx-parallel gem.</p>"},{"location":"workflows/#group","title":"Group","text":"<p>Group related tasks for better organization and shared configuration:</p> <p>Important</p> <p>Settings and conditionals for a group apply to all tasks within that group.</p> <pre><code>class ContentModerationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Screening phase\n  tasks ScanForProfanity, CheckForSpam, ValidateImages, breakpoints: [\"skipped\"]\n\n  # Review phase\n  tasks ApplyFilters, ScoreContent, FlagSuspicious\n\n  # Decision phase\n  tasks PublishContent, QueueForReview, NotifyModerators\nend\n</code></pre>"},{"location":"workflows/#conditionals","title":"Conditionals","text":"<p>Conditionals support multiple syntaxes for flexible execution control:</p> <pre><code>class ContentAccessCheck\n  def call(task)\n    task.context.user.can?(:publish_content)\n  end\nend\n\nclass OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # If and/or Unless\n  task SendWelcomeEmail, if: :email_configured?, unless: :email_disabled?\n\n  # Proc\n  task SendWelcomeEmail, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Premium\") }\n\n  # Lambda\n  task SendWelcomeEmail, if: proc { context.features_enabled? }\n\n  # Class or Module\n  task SendWelcomeEmail, unless: ContentAccessCheck\n\n  # Instance\n  task SendWelcomeEmail, if: ContentAccessCheck.new\n\n  # Conditional applies to all tasks of this declaration group\n  tasks SendWelcomeEmail, CreateDashboard, SetupTutorial, if: :email_configured?\n\n  private\n\n  def email_configured?\n    context.user.email_address == true\n  end\n\n  def email_disabled?\n    context.user.communication_preference == :disabled\n  end\nend\n</code></pre>"},{"location":"workflows/#halt-behavior","title":"Halt Behavior","text":"<p>By default skipped tasks are considered no-op executions and does not stop workflow execution. This is configurable via global and task level breakpoint settings. Task and group configurations can be used together within a workflow.</p> <pre><code>class AnalyticsWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CollectMetrics      # If fails \u2192 workflow stops\n  task FilterOutliers      # If skipped \u2192 workflow continues\n  task GenerateDashboard   # Only runs if no failures occurred\nend\n</code></pre>"},{"location":"workflows/#task-configuration","title":"Task Configuration","text":"<p>Configure halt behavior for the entire workflow:</p> <pre><code>class SecurityWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Halt on both failed and skipped results\n  settings(workflow_breakpoints: [\"skipped\", \"failed\"])\n\n  task PerformSecurityScan\n  task ValidateSecurityRules\nend\n\nclass OptionalTasksWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Never halt, always continue\n  settings(breakpoints: [])\n\n  task TryBackupData\n  task TryCleanupLogs\n  task TryOptimizeCache\nend\n</code></pre>"},{"location":"workflows/#group-configuration","title":"Group Configuration","text":"<p>Different task groups can have different halt behavior:</p> <pre><code>class SubscriptionWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateSubscription, ValidatePayment, workflow_breakpoints: [\"skipped\", \"failed\"]\n\n  # Never halt, always continue\n  task SendConfirmationEmail, UpdateBilling, breakpoints: []\nend\n</code></pre>"},{"location":"workflows/#nested-workflows","title":"Nested Workflows","text":"<p>Workflows can task other workflows for hierarchical composition:</p> <pre><code>class EmailPreparationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateRecipients\n  task CompileTemplate\nend\n\nclass EmailDeliveryWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks SendEmails, TrackDeliveries\nend\n\nclass CompleteEmailWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task EmailPreparationWorkflow\n  task EmailDeliveryWorkflow, if: proc { context.preparation_successful? }\n  task GenerateDeliveryReport\nend\n</code></pre>"},{"location":"workflows/#parallel-execution","title":"Parallel Execution","text":"<p>Parallel task execution leverages the Parallel gem, which automatically detects the number of available processors to maximize concurrent task execution.</p> <p>Important</p> <p>Context cannot be modified during parallel execution. Ensure that all required data is preloaded into the context before parallelization begins.</p> <pre><code>class SendWelcomeNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Default options (dynamically calculated to available processors)\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel\n\n  # Fix number of threads\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_threads: 2\n\n  # Fix number of forked processes\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_processes: 2\n\n  # NOTE: Reactors are not supported\nend\n</code></pre>"},{"location":"workflows/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx workflow tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:workflow SendNotifications\n</code></pre> <p>This creates a new workflow task file with the basic structure:</p> <pre><code># app/tasks/send_notifications.rb\nclass SendNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks Task1, Task2\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + pluralized noun for workflow task names, eg: <code>SendNotifications</code>, <code>DownloadFiles</code>, <code>ValidateDocuments</code></p>"},{"location":"attributes/coercions/","title":"Attributes - Coercions","text":"<p>Attribute coercions automatically convert task arguments to expected types, ensuring type safety while providing flexible input handling. Coercions transform raw input values into the specified types, supporting simple conversions like string-to-integer and complex operations like JSON parsing.</p> <p>Check out the Getting Started docs for global configuration.</p>"},{"location":"attributes/coercions/#usage","title":"Usage","text":"<p>Define attribute types to enable automatic coercion:</p> <pre><code>class ParseMetrics &lt; CMDx::Task\n  # Coerce into a symbol\n  attribute :measurement_type, type: :symbol\n\n  # Coerce into a rational fallback to big decimal\n  attribute :value, type: [:rational, :big_decimal]\n\n  # Coerce with options\n  attribute :recorded_at, type: :date, strptime: \"%m-%d-%Y\"\n\n  def work\n    measurement_type #=&gt; :temperature\n    recorded_at      #=&gt; &lt;Date 2024-01-23&gt;\n    value            #=&gt; 98.6 (Float)\n  end\nend\n\nParseMetrics.execute(\n  measurement_type: \"temperature\",\n  recorded_at: \"01-23-2020\",\n  value: \"98.6\"\n)\n</code></pre> <p>Tip</p> <p>Specify multiple coercion types for attributes that could be a variety of value formats. CMDx attempts each type in order until one succeeds.</p>"},{"location":"attributes/coercions/#built-in-coercions","title":"Built-in Coercions","text":"Type Options Description Examples <code>:array</code> Array conversion with JSON support <code>\"val\"</code> \u2192 <code>[\"val\"]</code><code>\"[1,2,3]\"</code> \u2192 <code>[1, 2, 3]</code> <code>:big_decimal</code> <code>:precision</code> High-precision decimal <code>\"123.456\"</code> \u2192 <code>BigDecimal(\"123.456\")</code> <code>:boolean</code> Boolean with text patterns <code>\"yes\"</code> \u2192 <code>true</code>, <code>\"no\"</code> \u2192 <code>false</code> <code>:complex</code> Complex numbers <code>\"1+2i\"</code> \u2192 <code>Complex(1, 2)</code> <code>:date</code> <code>:strptime</code> Date objects <code>\"2024-01-23\"</code> \u2192 <code>Date.new(2024, 1, 23)</code> <code>:datetime</code> <code>:strptime</code> DateTime objects <code>\"2024-01-23 10:30\"</code> \u2192 <code>DateTime.new(2024, 1, 23, 10, 30)</code> <code>:float</code> Floating-point numbers <code>\"123.45\"</code> \u2192 <code>123.45</code> <code>:hash</code> Hash conversion with JSON support <code>'{\"a\":1}'</code> \u2192 <code>{\"a\" =&gt; 1}</code> <code>:integer</code> Integer with hex/octal support <code>\"0xFF\"</code> \u2192 <code>255</code>, <code>\"077\"</code> \u2192 <code>63</code> <code>:rational</code> Rational numbers <code>\"1/2\"</code> \u2192 <code>Rational(1, 2)</code> <code>:string</code> String conversion <code>123</code> \u2192 <code>\"123\"</code> <code>:symbol</code> Symbol conversion <code>\"abc\"</code> \u2192 <code>:abc</code> <code>:time</code> <code>:strptime</code> Time objects <code>\"10:30:00\"</code> \u2192 <code>Time.new(2024, 1, 23, 10, 30)</code>"},{"location":"attributes/coercions/#declarations","title":"Declarations","text":"<p>Important</p> <p>Coercions must raise a CMDx::CoercionError and its message is used as part of the fault reason and metadata.</p>"},{"location":"attributes/coercions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple coercion logic:</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  # Proc\n  register :callback, :geolocation, proc do |value, options = {}|\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  end\n\n  # Lambda\n  register :callback, :geolocation, -&gt;(value, options = {}) {\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/coercions/#class-or-module","title":"Class or Module","text":"<p>Register custom coercion logic for specialized type handling:</p> <pre><code>class GeolocationCoercion\n  def self.call(value, options = {})\n    Geolocation(value)\n  rescue StandardError\n    raise CMDx::CoercionError, \"could not convert into a geolocation\"\n  end\nend\n\nclass TransformCoordinates &lt; CMDx::Task\n  register :coercion, :geolocation, GeolocationCoercion\n\n  attribute :latitude, type: :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#removals","title":"Removals","text":"<p>Remove custom coercions when no longer needed:</p> <p>Warning</p> <p>Only one removal operation is allowed per <code>deregister</code> call. Multiple removals require separate calls.</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  deregister :coercion, :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#error-handling","title":"Error Handling","text":"<p>Coercion failures provide detailed error information including attribute paths, attempted types, and specific failure reasons:</p> <pre><code>class AnalyzePerformance &lt; CMDx::Task\n  attribute  :iterations, type: :integer\n  attribute  :score, type: [:float, :big_decimal]\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = AnalyzePerformance.execute(\n  iterations: \"not-a-number\",\n  score: \"invalid-float\"\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"iterations could not coerce into an integer. score could not coerce into one of: float, big_decimal.\",\n                #       messages: {\n                #         iterations: [\"could not coerce into an integer\"],\n                #         score: [\"could not coerce into one of: float, big_decimal\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/defaults/","title":"Attributes - Defaults","text":"<p>Attribute defaults provide fallback values when arguments are not provided or resolve to <code>nil</code>. Defaults ensure tasks have sensible values for optional attributes while maintaining flexibility for callers to override when needed.</p>"},{"location":"attributes/defaults/#declarations","title":"Declarations","text":"<p>Defaults apply when attributes are not provided or resolve to <code>nil</code>. They work seamlessly with coercion, validation, and nested attributes.</p>"},{"location":"attributes/defaults/#static-values","title":"Static Values","text":"<pre><code>class OptimizeDatabase &lt; CMDx::Task\n  attribute :strategy, default: :incremental\n  attribute :level, default: \"basic\"\n  attribute :notify_admin, default: true\n  attribute :timeout_minutes, default: 30\n  attribute :indexes, default: []\n  attribute :options, default: {}\n\n  def work\n    strategy        #=&gt; :incremental\n    level           #=&gt; \"basic\"\n    notify_admin    #=&gt; true\n    timeout_minutes #=&gt; 30\n    indexes         #=&gt; []\n    options         #=&gt; {}\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic default values:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :granularity, default: :default_granularity\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def default_granularity\n    Current.user.premium? ? \"hourly\" : \"daily\"\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic default values:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, default: proc { Current.tenant.cache_duration || 24 }\n\n  # Lambda\n  attribute :compression, default: -&gt; { Current.tenant.premium? ? \"gzip\" : \"none\" }\nend\n</code></pre>"},{"location":"attributes/defaults/#coercions-and-validations","title":"Coercions and Validations","text":"<p>Defaults are subject to the same coercion and validation rules as provided values, ensuring consistency and catching configuration errors early.</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, default: \"7\", type: :integer\n\n  # Validations\n  optional :frequency, default: \"daily\", inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/definitions/","title":"Attributes - Definitions","text":"<p>Attributes define the interface between task callers and implementation, enabling automatic validation, type coercion, and method generation. They provide a contract to verify that task execution arguments match expected requirements and structure.</p>"},{"location":"attributes/definitions/#declarations","title":"Declarations","text":"<p>Tip</p> <p>Prefer using the <code>required</code> and <code>optional</code> alias for <code>attributes</code> for brevity and to clearly signal intent.</p>"},{"location":"attributes/definitions/#optional","title":"Optional","text":"<p>Optional attributes return <code>nil</code> when not provided.</p> <pre><code>class ScheduleEvent &lt; CMDx::Task\n  attribute :title\n  attributes :duration, :location\n\n  # Alias for attributes (preferred)\n  optional :description\n  optional :visibility, :attendees\n\n  def work\n    title       #=&gt; \"Team Standup\"\n    duration    #=&gt; 30\n    location    #=&gt; nil\n    description #=&gt; nil\n    visibility  #=&gt; nil\n    attendees   #=&gt; [\"alice@company.com\", \"bob@company.com\"]\n  end\nend\n\n# Attributes passed as keyword arguments\nScheduleEvent.execute(\n  title: \"Team Standup\",\n  duration: 30,\n  attendees: [\"alice@company.com\", \"bob@company.com\"]\n)\n</code></pre>"},{"location":"attributes/definitions/#required","title":"Required","text":"<p>Required attributes must be provided in call arguments or task execution will fail.</p> <pre><code>class PublishArticle &lt; CMDx::Task\n  attribute :title, required: true\n  attributes :content, :author_id, required: true\n\n  # Alias for attributes =&gt; required: true (preferred)\n  required :category\n  required :status, :tags\n\n  def work\n    title     #=&gt; \"Getting Started with Ruby\"\n    content   #=&gt; \"This is a comprehensive guide...\"\n    author_id #=&gt; 42\n    category  #=&gt; \"programming\"\n    status    #=&gt; :published\n    tags      #=&gt; [\"ruby\", \"beginner\"]\n  end\nend\n\n# Attributes passed as keyword arguments\nPublishArticle.execute(\n  title: \"Getting Started with Ruby\",\n  content: \"This is a comprehensive guide...\",\n  author_id: 42,\n  category: \"programming\",\n  status: :published,\n  tags: [\"ruby\", \"beginner\"]\n)\n</code></pre>"},{"location":"attributes/definitions/#sources","title":"Sources","text":"<p>Attributes delegate to accessible objects within the task. The default source is <code>:context</code>, but any accessible method or object can serve as an attribute source.</p>"},{"location":"attributes/definitions/#context","title":"Context","text":"<pre><code>class BackupDatabase &lt; CMDx::Task\n  # Default source is :context\n  required :database_name\n  optional :compression_level\n\n  # Explicitly specify context source\n  attribute :backup_path, source: :context\n\n  def work\n    database_name     #=&gt; context.database_name\n    backup_path       #=&gt; context.backup_path\n    compression_level #=&gt; context.compression_level\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  attributes :host, :credentials, source: :database_config\n\n  # Access from declared attributes\n  attribute :connection_string, source: :credentials\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def database_config\n    @database_config ||= DatabaseConfig.find(context.database_name)\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  # Proc\n  attribute :timestamp, source: proc { Time.current }\n\n  # Lambda\n  attribute :server, source: -&gt; { Current.server }\nend\n</code></pre>"},{"location":"attributes/definitions/#class-or-module","title":"Class or Module","text":"<p>For complex source logic, use classes or modules:</p> <pre><code>class DatabaseResolver\n  def self.call(task)\n    Database.find(task.context.database_name)\n  end\nend\n\nclass BackupDatabase &lt; CMDx::Task\n  # Class or Module\n  attribute :schema, source: DatabaseResolver\n\n  # Instance\n  attribute :metadata, source: DatabaseResolver.new\nend\n</code></pre>"},{"location":"attributes/definitions/#nesting","title":"Nesting","text":"<p>Nested attributes enable complex attribute structures where child attributes automatically inherit their parent as the source. This allows validation and access of structured data.</p> <p>Note</p> <p>All options available to top-level attributes are available to nested attributes, eg: naming, coercions, and validations</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  # Required parent with required children\n  required :network_config do\n    required :hostname, :port, :protocol, :subnet\n    optional :load_balancer\n    attribute :firewall_rules\n  end\n\n  # Optional parent with conditional children\n  optional :ssl_config do\n    required :certificate_path, :private_key # Only required if ssl_config provided\n    optional :enable_http2, prefix: true\n  end\n\n  # Multi-level nesting\n  attribute :monitoring do\n    required :provider\n\n    optional :alerting do\n      required :threshold_percentage\n      optional :notification_channel\n    end\n  end\n\n  def work\n    network_config   #=&gt; { hostname: \"api.company.com\" ... }\n    hostname         #=&gt; \"api.company.com\"\n    load_balancer    #=&gt; nil\n  end\nend\n\nConfigureServer.execute(\n  server_id: \"srv-001\",\n  network_config: {\n    hostname: \"api.company.com\",\n    port: 443,\n    protocol: \"https\",\n    subnet: \"10.0.1.0/24\",\n    firewall_rules: \"allow_web_traffic\"\n  },\n  monitoring: {\n    provider: \"datadog\",\n    alerting: {\n      threshold_percentage: 85.0,\n      notification_channel: \"slack\"\n    }\n  }\n)\n</code></pre> <p>Important</p> <p>Child attributes are only required when their parent attribute is provided, enabling flexible optional structures.</p>"},{"location":"attributes/definitions/#error-handling","title":"Error Handling","text":"<p>Attribute validation failures result in structured error information with details about each failed attribute.</p> <p>Note</p> <p>Nested attributes are only ever evaluated when the parent attribute is available and valid.</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  required :server_id, :environment\n  required :network_config do\n    required :hostname, :port\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Missing required top-level attributes\nresult = ConfigureServer.execute(server_id: \"srv-001\")\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"environment is required. network_config is required.\",\n                #       messages: {\n                #         environment: [\"is required\"],\n                #         network_config: [\"is required\"]\n                #       }\n                #     }\n                #   }\n\n# Missing required nested attributes\nresult = ConfigureServer.execute(\n  server_id: \"srv-001\",\n  environment: \"production\",\n  network_config: { hostname: \"api.company.com\" } # Missing port\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"port is required.\",\n                #       messages: {\n                #         port: [\"is required\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/naming/","title":"Attributes - Naming","text":"<p>Attribute naming provides method name customization to prevent conflicts and enable flexible attribute access patterns. When attributes share names with existing methods or when multiple attributes from different sources have the same name, affixing ensures clean method resolution within tasks.</p> <p>Note</p> <p>Affixing modifies only the generated accessor method names within tasks.</p>"},{"location":"attributes/naming/#prefix","title":"Prefix","text":"<p>Adds a prefix to the generated accessor method name.</p> <pre><code>class GenerateReport &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :template, prefix: true\n\n  # Static\n  attribute :format, prefix: \"report_\"\n\n  def work\n    context_template #=&gt; \"monthly_sales\"\n    report_format    #=&gt; \"pdf\"\n  end\nend\n\n# Attributes passed as original attribute names\nGenerateReport.execute(template: \"monthly_sales\", format: \"pdf\")\n</code></pre>"},{"location":"attributes/naming/#suffix","title":"Suffix","text":"<p>Adds a suffix to the generated accessor method name.</p> <pre><code>class DeployApplication &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :branch, suffix: true\n\n  # Static\n  attribute :version, suffix: \"_tag\"\n\n  def work\n    branch_context #=&gt; \"main\"\n    version_tag    #=&gt; \"v1.2.3\"\n  end\nend\n\n# Attributes passed as original attribute names\nDeployApplication.execute(branch: \"main\", version: \"v1.2.3\")\n</code></pre>"},{"location":"attributes/naming/#as","title":"As","text":"<p>Completely renames the generated accessor method.</p> <pre><code>class ScheduleMaintenance &lt; CMDx::Task\n  attribute :scheduled_at, as: :when\n\n  def work\n    when #=&gt; &lt;DateTime&gt;\n  end\nend\n\n# Attributes passed as original attribute names\nScheduleMaintenance.execute(scheduled_at: DateTime.new(2024, 12, 15, 2, 0, 0))\n</code></pre>"},{"location":"attributes/transformations/","title":"Attributes - Transformations","text":"<p>Transformations allow you to modify attribute values after they are derived and coerced from their source but before any validations. This enables data normalization, formatting, and conditional processing within the attribute pipeline.</p>"},{"location":"attributes/transformations/#declarations","title":"Declarations","text":""},{"location":"attributes/transformations/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic value transformations:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :options, transform: :compact_blank\nend\n</code></pre>"},{"location":"attributes/transformations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic value transformations:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, transform: proc { |v| v * 2 }\n\n  # Lambda\n  attribute :compression, transform: -&gt;(v) { v.to_s.upcase.strip[0..2]  }\nend\n</code></pre>"},{"location":"attributes/transformations/#class-or-module","title":"Class or Module","text":"<p>Use any object that responds to <code>call</code> for reusable transformation logic:</p> <pre><code>class EmailNormalizer\n  def call(value)\n    value.to_s.downcase.strip\n  end\nend\n\nclass ProcessContacts &lt; CMDx::Task\n  # Class or Module\n  attribute :email, transform: EmailNormalizer\n\n  # Instance\n  attribute :email, transform: EmailNormalizer.new\nend\n</code></pre>"},{"location":"attributes/transformations/#validations","title":"Validations","text":"<p>Transformed values are subject to the same validation rules as untransformed values, ensuring consistency and catching configuration errors early.</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, type: :integer, transform: proc { |v| v.clamp(1, 5) }\n\n  # Validations\n  optional :frequency, transform: :downcase, inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/validations/","title":"Attributes - Validations","text":"<p>Attribute validations ensure task arguments meet specified requirements before execution begins. Validations run after coercions and provide declarative rules for data integrity, supporting both built-in validators and custom validation logic.</p> <p>Check out the Getting Started docs for global configuration.</p>"},{"location":"attributes/validations/#usage","title":"Usage","text":"<p>Define validation rules on attributes to enforce data requirements:</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  # Required field with presence validation\n  attribute :user_id, presence: true\n\n  # String with length constraints\n  attribute :preferences, length: { minimum: 10, maximum: 500 }\n\n  # Numeric range validation\n  attribute :tier_level, inclusion: { in: 1..5 }\n\n  # Format validation for email\n  attribute :contact_email, format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    user_id       #=&gt; \"98765\"\n    preferences   #=&gt; \"Send weekly digest emails\"\n    tier_level    #=&gt; 3\n    contact_email #=&gt; \"user@company.com\"\n  end\nend\n\nProcessSubscription.execute(\n  user_id: \"98765\",\n  preferences: \"Send weekly digest emails\",\n  tier_level: 3,\n  contact_email: \"user@company.com\"\n)\n</code></pre> <p>Tip</p> <p>Validations run after coercions, so you can validate the final coerced values rather than raw input.</p>"},{"location":"attributes/validations/#built-in-validators","title":"Built-in Validators","text":""},{"location":"attributes/validations/#common-options","title":"Common Options","text":"<p>This list of options is available to all validators:</p> Option Description <code>:allow_nil</code> Skip validation when value is <code>nil</code> <code>:if</code> Symbol, proc, lambda, or callable determining when to validate <code>:unless</code> Symbol, proc, lambda, or callable determining when to skip validation <code>:message</code> Custom error message for validation failures"},{"location":"attributes/validations/#exclusion","title":"Exclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :status, exclusion: { in: %w[recalled archived] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of forbidden values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value exclusions <code>:in_message</code> Custom message for range-based exclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#format","title":"Format","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :sku, format: /\\A[A-Z]{3}-[0-9]{4}\\z/\n\n  attribute :sku, format: { with: /\\A[A-Z]{3}-[0-9]{4}\\z/ }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>regexp</code> Alias for :with option <code>:with</code> Regex pattern that the value must match <code>:without</code> Regex pattern that the value must not match"},{"location":"attributes/validations/#inclusion","title":"Inclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :availability, inclusion: { in: %w[available limited] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of allowed values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value inclusions <code>:in_message</code> Custom message for range-based inclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#length","title":"Length","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :title, length: { within: 5..100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the length must fall within (inclusive) <code>:not_within</code> Range that the length must not fall within <code>:in</code> Alias for :within <code>:not_in</code> Range that the length must not fall within <code>:min</code> Minimum allowed length <code>:max</code> Maximum allowed length <code>:is</code> Exact required length <code>:is_not</code> Length that is not allowed <code>:within_message</code> Custom message for within/range validations <code>:in_message</code> Custom message for :in validation <code>:not_within_message</code> Custom message for not_within validation <code>:not_in_message</code> Custom message for not_in validation <code>:min_message</code> Custom message for minimum length validation <code>:max_message</code> Custom message for maximum length validation <code>:is_message</code> Custom message for exact length validation <code>:is_not_message</code> Custom message for is_not validation"},{"location":"attributes/validations/#numeric","title":"Numeric","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :word_count, numeric: { min: 100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the value must fall within (inclusive) <code>:not_within</code> Range that the value must not fall within <code>:in</code> Alias for :within option <code>:not_in</code> Alias for :not_within option <code>:min</code> Minimum allowed value (inclusive, &gt;=) <code>:max</code> Maximum allowed value (inclusive, &lt;=) <code>:is</code> Exact value that must match <code>:is_not</code> Value that must not match <code>:within_message</code> Custom message for range validations <code>:not_within_message</code> Custom message for exclusion validations <code>:min_message</code> Custom message for minimum validation <code>:max_message</code> Custom message for maximum validation <code>:is_message</code> Custom message for exact match validation <code>:is_not_message</code> Custom message for exclusion validation"},{"location":"attributes/validations/#presence","title":"Presence","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :content, presence: true\n\n  attribute :content, presence: { message: \"cannot be blank\" }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>true</code> Ensures value is not nil, empty string, or whitespace"},{"location":"attributes/validations/#declarations","title":"Declarations","text":"<p>Important</p> <p>Custom validators must raise a <code>CMDx::ValidationError</code> and its message is used as part of the fault reason and metadata.</p>"},{"location":"attributes/validations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple validation logic:</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  # Proc\n  register :validator, :api_key, proc do |value, options = {}|\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\n\n  # Lambda\n  register :validator, :api_key, -&gt;(value, options = {}) {\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/validations/#class-or-module","title":"Class or Module","text":"<p>Register custom validation logic for specialized requirements:</p> <pre><code>class ApiKeyValidator\n  def self.call(value, options = {})\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\nend\n\nclass SetupApplication &lt; CMDx::Task\n  register :validator, :api_key, ApiKeyValidator\n\n  attribute :access_key, api_key: true\nend\n</code></pre>"},{"location":"attributes/validations/#removals","title":"Removals","text":"<p>Remove custom validators when no longer needed:</p> <p>Warning</p> <p>Only one removal operation is allowed per <code>deregister</code> call. Multiple removals require separate calls.</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  deregister :validator, :api_key\nend\n</code></pre>"},{"location":"attributes/validations/#error-handling","title":"Error Handling","text":"<p>Validation failures provide detailed error information including attribute paths, validation rules, and specific failure reasons:</p> <pre><code>class CreateProject &lt; CMDx::Task\n  attribute :project_name, presence: true, length: { minimum: 3, maximum: 50 }\n  attribute :budget, numeric: { greater_than: 1000, less_than: 1000000 }\n  attribute :priority, inclusion: { in: [:low, :medium, :high] }\n  attribute :contact_email, format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = CreateProject.execute(\n  project_name: \"AB\",           # Too short\n  budget: 500,                  # Too low\n  priority: :urgent,            # Not in allowed list\n  contact_email: \"invalid-email\"    # Invalid format\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"project_name is too short (minimum is 3 characters). budget must be greater than 1000. priority is not included in the list. contact_email is invalid.\",\n                #       messages: {\n                #         project_name: [\"is too short (minimum is 3 characters)\"],\n                #         budget: [\"must be greater than 1000\"],\n                #         priority: [\"is not included in the list\"],\n                #         contact_email: [\"is invalid\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"basics/chain/","title":"Basics - Chain","text":"<p>Chains automatically group related task executions within a thread, providing unified tracking, correlation, and execution context management. Each thread maintains its own chain through thread-local storage, eliminating the need for manual coordination.</p>"},{"location":"basics/chain/#management","title":"Management","text":"<p>Each thread maintains its own chain context through thread-local storage, providing automatic isolation without manual coordination.</p> <p>Warning</p> <p>Chain operations are thread-local. Never share chain references across threads as this can lead to race conditions and data corruption.</p> <pre><code># Thread A\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch1.csv\")\n  result.chain.id    #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nend\n\n# Thread B (completely separate chain)\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch2.csv\")\n  result.chain.id    #=&gt; \"z3a42b95-c821-7892-b156-dd7c921fe2a3\"\nend\n\n# Access current thread's chain\nCMDx::Chain.current  #=&gt; Returns current chain or nil\nCMDx::Chain.clear    #=&gt; Clears current thread's chain\n</code></pre>"},{"location":"basics/chain/#links","title":"Links","text":"<p>Every task execution automatically creates or joins the current thread's chain:</p> <p>Important</p> <p>Chain creation is automatic and transparent. You don't need to manually manage chain lifecycle.</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    # First task creates new chain\n    result1 = ValidateHeaders.execute(file_path: context.file_path)\n    result1.chain.id           #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\n    result1.chain.results.size #=&gt; 1\n\n    # Second task joins existing chain\n    result2 = SendNotification.execute(to: \"admin@company.com\")\n    result2.chain.id == result1.chain.id  #=&gt; true\n    result2.chain.results.size            #=&gt; 2\n\n    # Both results reference the same chain\n    result1.chain.results == result2.chain.results #=&gt; true\n  end\nend\n</code></pre>"},{"location":"basics/chain/#inheritance","title":"Inheritance","text":"<p>When tasks call subtasks within the same thread, all executions automatically inherit the current chain, creating a unified execution trail.</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    context.dataset = Dataset.find(context.dataset_id)\n\n    # Subtasks automatically inherit current chain\n    ValidateSchema.execute\n    TransformData.execute!(context)\n    SaveToDatabase.execute(dataset_id: context.dataset_id)\n  end\nend\n\nresult = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# All tasks share the same chain\nchain.results.size #=&gt; 4 (main task + 3 subtasks)\nchain.results.map { |r| r.task.class }\n#=&gt; [ImportDataset, ValidateSchema, TransformData, SaveToDatabase]\n</code></pre>"},{"location":"basics/chain/#structure","title":"Structure","text":"<p>Chains provide comprehensive execution information with state delegation:</p> <p>Important</p> <p>Chain state always reflects the first (outer-most) task result, not individual subtask outcomes. Subtasks maintain their own success/failure states.</p> <pre><code>result = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# Chain identification\nchain.id      #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nchain.results #=&gt; Array of all results in execution order\n\n# State delegation (from first/outer-most result)\nchain.state   #=&gt; \"complete\"\nchain.status  #=&gt; \"success\"\nchain.outcome #=&gt; \"success\"\n\n# Access individual results\nchain.results.each_with_index do |result, index|\n  puts \"#{index}: #{result.task.class} - #{result.status}\"\nend\n</code></pre>"},{"location":"basics/context/","title":"Basics - Context","text":"<p>Task context provides flexible data storage, access, and sharing within task execution. It serves as the primary data container for all task inputs, intermediate results, and outputs.</p>"},{"location":"basics/context/#assigning-data","title":"Assigning Data","text":"<p>Context is automatically populated with all inputs passed to a task. All keys are normalized to symbols for consistent access:</p> <pre><code># Direct execution\nCalculateShipping.execute(weight: 2.5, destination: \"CA\")\n\n# Instance creation\nCalculateShipping.new(weight: 2.5, \"destination\" =&gt; \"CA\")\n</code></pre> <p>Important</p> <p>String keys are automatically converted to symbols. Use symbols for consistency in your code.</p>"},{"location":"basics/context/#accessing-data","title":"Accessing Data","text":"<p>Context provides multiple access patterns with automatic nil safety:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Method style access (preferred)\n    weight = context.weight\n    destination = context.destination\n\n    # Hash style access\n    service_type = context[:service_type]\n    options = context[\"options\"]\n\n    # Safe access with defaults\n    rush_delivery = context.fetch!(:rush_delivery, false)\n    carrier = context.dig(:options, :carrier)\n\n    # Shorter alias\n    cost = ctx.weight * ctx.rate_per_pound  # ctx aliases context\n  end\nend\n</code></pre> <p>Important</p> <p>Accessing undefined context attributes returns <code>nil</code> instead of raising errors, enabling graceful handling of optional attributes.</p>"},{"location":"basics/context/#modifying-context","title":"Modifying Context","text":"<p>Context supports dynamic modification during task execution:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Direct assignment\n    context.carrier = Carrier.find_by(code: context.carrier_code)\n    context.package = Package.new(weight: context.weight)\n    context.calculated_at = Time.now\n\n    # Hash-style assignment\n    context[:status] = \"calculating\"\n    context[\"tracking_number\"] = \"SHIP#{SecureRandom.hex(6)}\"\n\n    # Conditional assignment\n    context.insurance_included ||= false\n\n    # Batch updates\n    context.merge!(\n      status: \"completed\",\n      shipping_cost: calculate_cost,\n      estimated_delivery: Time.now + 3.days\n    )\n\n    # Remove sensitive data\n    context.delete!(:credit_card_token)\n  end\n\n  private\n\n  def calculate_cost\n    base_rate = context.weight * context.rate_per_pound\n    base_rate + (base_rate * context.tax_percentage)\n  end\nend\n</code></pre> <p>Tip</p> <p>Use context for both input values and intermediate results. This creates natural data flow through your task execution pipeline.</p>"},{"location":"basics/context/#data-sharing","title":"Data Sharing","text":"<p>Context enables seamless data flow between related tasks in complex workflows:</p> <pre><code># During execution\nclass CalculateShipping &lt; CMDx::Task\n  def work\n    # Validate shipping data\n    validation_result = ValidateAddress.execute(context)\n\n    # Via context\n    CalculateInsurance.execute(context)\n\n    # Via result\n    NotifyShippingCalculated.execute(validation_result)\n\n    # Context now contains accumulated data from all tasks\n    context.address_validated    #=&gt; true (from validation)\n    context.insurance_calculated #=&gt; true (from insurance)\n    context.notification_sent    #=&gt; true (from notification)\n  end\nend\n\n# After execution\nresult = CalculateShipping.execute(destination: \"New York, NY\")\n\nCreateShippingLabel.execute(result)\n</code></pre>"},{"location":"basics/execution/","title":"Basics - Execution","text":"<p>Task execution in CMDx provides two distinct methods that handle success and halt scenarios differently. Understanding when to use each method is crucial for proper error handling and control flow in your application workflows.</p>"},{"location":"basics/execution/#methods-overview","title":"Methods Overview","text":"<p>Tasks are single-use objects. Once executed, they are frozen and cannot be executed again. Create a new instance for subsequent executions.</p> Method Returns Exceptions Use Case <code>execute</code> Always returns <code>CMDx::Result</code> Never raises Predictable result handling <code>execute!</code> Returns <code>CMDx::Result</code> on success Raises <code>CMDx::Fault</code> when skipped or failed Exception-based control flow"},{"location":"basics/execution/#non-bang-execution","title":"Non-bang Execution","text":"<p>The <code>execute</code> method always returns a <code>CMDx::Result</code> object regardless of execution outcome. This is the preferred method for most use cases.</p> <p>Any unhandled exceptions will be caught and returned as a task failure.</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Check execution state\nresult.success?         #=&gt; true/false\nresult.failed?          #=&gt; true/false\nresult.skipped?         #=&gt; true/false\n\n# Access result data\nresult.context.email    #=&gt; \"user@example.com\"\nresult.state            #=&gt; \"complete\"\nresult.status           #=&gt; \"success\"\n</code></pre>"},{"location":"basics/execution/#bang-execution","title":"Bang Execution","text":"<p>The bang <code>execute!</code> method raises a <code>CMDx::Fault</code> based exception when tasks fail or are skipped, and returns a <code>CMDx::Result</code> object only on success.</p> <p>It raises any unhandled non-fault exceptions caused during execution.</p> Exception Raised When <code>CMDx::FailFault</code> Task execution fails <code>CMDx::SkipFault</code> Task execution is skipped <p>Important</p> <p><code>execute!</code> behavior depends on the <code>task_breakpoints</code> or <code>workflow_breakpoints</code> configuration. By default, it raises exceptions only on failures.</p> <pre><code>begin\n  result = CreateAccount.execute!(email: \"user@example.com\")\n  SendWelcomeEmail.execute(result.context)\nrescue CMDx::FailFault =&gt; e\n  ScheduleAccountRetryJob.perform_later(e.result.context.email)\nrescue CMDx::SkipFault =&gt; e\n  Rails.logger.info(\"Account creation skipped: #{e.result.reason}\")\nrescue Exception =&gt; e\n  ErrorTracker.capture(unhandled_exception: e)\nend\n</code></pre>"},{"location":"basics/execution/#direct-instantiation","title":"Direct Instantiation","text":"<p>Tasks can be instantiated directly for advanced use cases, testing, and custom execution patterns:</p> <pre><code># Direct instantiation\ntask = CreateAccount.new(email: \"user@example.com\", send_welcome: true)\n\n# Access properties before execution\ntask.id                      #=&gt; \"abc123...\" (unique task ID)\ntask.context.email           #=&gt; \"user@example.com\"\ntask.context.send_welcome    #=&gt; true\ntask.result.state            #=&gt; \"initialized\"\ntask.result.status           #=&gt; \"success\"\n\n# Manual execution\ntask.execute\n# or\ntask.execute!\n\ntask.result.success?         #=&gt; true/false\n</code></pre>"},{"location":"basics/execution/#result-details","title":"Result Details","text":"<p>The <code>Result</code> object provides comprehensive execution information:</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Execution metadata\nresult.id           #=&gt; \"abc123...\"  (unique execution ID)\nresult.task         #=&gt; CreateAccount instance (frozen)\nresult.chain        #=&gt; Task execution chain\n\n# Context and metadata\nresult.context      #=&gt; Context with all task data\nresult.metadata     #=&gt; Hash with execution metadata\n</code></pre>"},{"location":"basics/setup/","title":"Basics - Setup","text":"<p>Tasks are the core building blocks of CMDx, encapsulating business logic within structured, reusable objects. Each task represents a unit of work with automatic attribute validation, error handling, and execution tracking.</p>"},{"location":"basics/setup/#structure","title":"Structure","text":"<p>Tasks inherit from <code>CMDx::Task</code> and require only a <code>work</code> method:</p> <pre><code>class ValidateDocument &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>An exception will be raised if a work method is not defined.</p> <pre><code>class IncompleteTask &lt; CMDx::Task\n  # No `work` method defined\nend\n\nIncompleteTask.execute #=&gt; raises CMDx::UndefinedMethodError\n</code></pre>"},{"location":"basics/setup/#inheritance","title":"Inheritance","text":"<p>All configuration options are inheritable by any child classes. Create a base class to share common configuration across tasks:</p> <pre><code>class ApplicationTask &lt; CMDx::Task\n  register :middleware, SecurityMiddleware\n\n  before_execution :initialize_request_tracking\n\n  attribute :session_id\n\n  private\n\n  def initialize_request_tracking\n    context.tracking_id ||= SecureRandom.uuid\n  end\nend\n\nclass SyncInventory &lt; ApplicationTask\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"basics/setup/#lifecycle","title":"Lifecycle","text":"<p>Tasks follow a predictable call pattern with specific states and statuses:</p> <p>Caution</p> <p>Tasks are single-use objects. Once executed, they are frozen and cannot be executed again.</p> Stage State Status Description Instantiation <code>initialized</code> <code>success</code> Task created with context Validation <code>executing</code> <code>success</code>/<code>failed</code> Attributes validated Execution <code>executing</code> <code>success</code>/<code>failed</code>/<code>skipped</code> <code>work</code> method runs Completion <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Result finalized Freezing <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Task becomes immutable"},{"location":"interruptions/exceptions/","title":"Interruptions - Exceptions","text":"<p>CMDx provides robust exception handling that differs between the <code>execute</code> and <code>execute!</code> methods. Understanding how unhandled exceptions are processed is crucial for building reliable task execution flows and implementing proper error handling strategies.</p>"},{"location":"interruptions/exceptions/#exception-handling","title":"Exception Handling","text":"<p>Important</p> <p>When designing tasks try not to <code>raise</code> your own exceptions directly, instead use <code>skip!</code> or <code>fail!</code> to signal intent clearly.</p>"},{"location":"interruptions/exceptions/#non-bang-execution","title":"Non-bang execution","text":"<p>The <code>execute</code> method captures all unhandled exceptions and converts them to failed results, ensuring predictable behavior and consistent result processing.</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nresult = CompressDocument.execute(document_id: \"unknown-doc-id\")\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.failed?  #=&gt; true\nresult.reason   #=&gt; \"[ActiveRecord::NotFoundError] record not found\"\nresult.cause    #=&gt; &lt;ActiveRecord::NotFoundError&gt;\n</code></pre> <p>Note</p> <p>The <code>exception_handler</code> setting only works with non-bang execution as it catches all exceptions preventing them from reaching your apps global error handler.</p>"},{"location":"interruptions/exceptions/#bang-execution","title":"Bang execution","text":"<p>The <code>execute!</code> method allows unhandled exceptions to propagate, enabling standard Ruby exception handling while respecting CMDx fault configuration.</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nbegin\n  CompressDocument.execute!(document_id: \"unknown-doc-id\")\nrescue ActiveRecord::NotFoundError =&gt; e\n  puts \"Handle exception: #{e.message}\"\nend\n</code></pre>"},{"location":"interruptions/faults/","title":"Interruptions - Faults","text":"<p>Faults are exception mechanisms that halt task execution via <code>skip!</code> and <code>fail!</code> methods. When tasks execute with the <code>execute!</code> method, fault exceptions matching the task's interruption status are raised, enabling sophisticated exception handling and control flow patterns.</p>"},{"location":"interruptions/faults/#fault-types","title":"Fault Types","text":"Type Triggered By Use Case <code>CMDx::Fault</code> Base class Catch-all for any interruption <code>CMDx::SkipFault</code> <code>skip!</code> method Optional processing, early returns <code>CMDx::FailFault</code> <code>fail!</code> method Validation errors, processing failures <p>Important</p> <p>All fault exceptions inherit from <code>CMDx::Fault</code> and provide access to the complete task execution context including result, task, context, and chain information.</p>"},{"location":"interruptions/faults/#fault-handling","title":"Fault Handling","text":"<pre><code>begin\n  ProcessTicket.execute!(ticket_id: 456)\nrescue CMDx::SkipFault =&gt; e\n  logger.info \"Ticket processing skipped: #{e.message}\"\n  schedule_retry(e.context.ticket_id)\nrescue CMDx::FailFault =&gt; e\n  logger.error \"Ticket processing failed: #{e.message}\"\n  notify_admin(e.context.assigned_agent, e.result.metadata[:error_code])\nrescue CMDx::Fault =&gt; e\n  logger.warn \"Ticket processing interrupted: #{e.message}\"\n  rollback_changes\nend\n</code></pre>"},{"location":"interruptions/faults/#data-access","title":"Data Access","text":"<p>Faults provide comprehensive access to execution context, eg:</p> <pre><code>begin\n  LicenseActivation.execute!(license_key: key, machine_id: machine)\nrescue CMDx::Fault =&gt; e\n  # Result information\n  e.result.state     #=&gt; \"interrupted\"\n  e.result.status    #=&gt; \"failed\" or \"skipped\"\n  e.result.reason    #=&gt; \"License key already activated\"\n\n  # Task information\n  e.task.class       #=&gt; &lt;LicenseActivation&gt;\n  e.task.id          #=&gt; \"abc123...\"\n\n  # Context data\n  e.context.license_key #=&gt; \"ABC-123-DEF\"\n  e.context.machine_id  #=&gt; \"[FILTERED]\"\n\n  # Chain information\n  e.chain.id         #=&gt; \"def456...\"\n  e.chain.size       #=&gt; 3\nend\n</code></pre>"},{"location":"interruptions/faults/#advanced-matching","title":"Advanced Matching","text":""},{"location":"interruptions/faults/#task-specific-matching","title":"Task-Specific Matching","text":"<p>Use <code>for?</code> to handle faults only from specific task classes, enabling targeted exception handling in complex workflows.</p> <pre><code>begin\n  DocumentWorkflow.execute!(document_data: data)\nrescue CMDx::FailFault.for?(FormatValidator, ContentProcessor) =&gt; e\n  # Handle only document-related failures\n  retry_with_alternate_parser(e.context)\nrescue CMDx::SkipFault.for?(VirusScanner, ContentFilter) =&gt; e\n  # Handle security-related skips\n  quarantine_for_review(e.context.document_id)\nend\n</code></pre>"},{"location":"interruptions/faults/#custom-logic-matching","title":"Custom Logic Matching","text":"<pre><code>begin\n  ReportGenerator.execute!(report: report_data)\nrescue CMDx::Fault.matches? { |f| f.context.data_size &gt; 10_000 } =&gt; e\n  escalate_large_dataset_failure(e)\nrescue CMDx::FailFault.matches? { |f| f.result.metadata[:attempt_count] &gt; 3 } =&gt; e\n  abandon_report_generation(e)\nrescue CMDx::Fault.matches? { |f| f.result.metadata[:error_type] == \"memory\" } =&gt; e\n  increase_memory_and_retry(e)\nend\n</code></pre>"},{"location":"interruptions/faults/#fault-propagation","title":"Fault Propagation","text":"<p>Use <code>throw!</code> to propagate failures while preserving fault context and maintaining the error chain for debugging.</p>"},{"location":"interruptions/faults/#basic-propagation","title":"Basic Propagation","text":"<pre><code>class ReportGenerator &lt; CMDx::Task\n  def work\n    # Throw if skipped or failed\n    validation_result = DataValidator.execute(context)\n    throw!(validation_result)\n\n    # Only throw if skipped\n    check_permissions = CheckPermissions.execute(context)\n    throw!(check_permissions) if check_permissions.skipped?\n\n    # Only throw if failed\n    data_result = DataProcessor.execute(context)\n    throw!(data_result) if data_result.failed?\n\n    # Continue processing\n    generate_report\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#additional-metadata","title":"Additional Metadata","text":"<pre><code>class BatchProcessor &lt; CMDx::Task\n  def work\n    step_result = FileValidation.execute(context)\n\n    if step_result.failed?\n      throw!(step_result, {\n        batch_stage: \"validation\",\n        can_retry: true,\n        next_step: \"file_repair\"\n      })\n    end\n\n    continue_batch\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#chain-analysis","title":"Chain Analysis","text":"<p>Results provide methods to analyze fault propagation and identify original failure sources in complex execution chains.</p> <pre><code>result = DocumentWorkflow.execute(invalid_data)\n\nif result.failed?\n  # Trace the original failure\n  original = result.caused_failure\n  if original\n    puts \"Original failure: #{original.task.class.name}\"\n    puts \"Reason: #{original.reason}\"\n  end\n\n  # Find what propagated the failure\n  thrower = result.threw_failure\n  puts \"Propagated by: #{thrower.task.class.name}\" if thrower\n\n  # Analyze failure type\n  case\n  when result.caused_failure?\n    puts \"This task was the original source\"\n  when result.threw_failure?\n    puts \"This task propagated a failure\"\n  when result.thrown_failure?\n    puts \"This task failed due to propagation\"\n  end\nend\n</code></pre>"},{"location":"interruptions/halt/","title":"Interruptions - Halt","text":"<p>Halting stops task execution with explicit intent signaling. Tasks provide two primary halt methods that control execution flow and result in different outcomes.</p>"},{"location":"interruptions/halt/#skipping","title":"Skipping","text":"<p><code>skip!</code> communicates that the task is to be intentionally bypassed. This represents a controlled, intentional interruption where the task determines that execution is not necessary or appropriate.</p> <p>Important</p> <p>Skipping is a no-op, not a failure or error and are considered successful outcomes.</p> <pre><code>class ProcessInventory &lt; CMDx::Task\n  def work\n    # Without a reason\n    skip! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    # With a reason\n    skip!(\"Warehouse closed\") unless Time.now.hour.between?(8, 18)\n\n    inventory = Inventory.find(context.inventory_id)\n\n    if inventory.already_counted?\n      skip!(\"Inventory already counted today\")\n    else\n      inventory.count!\n    end\n  end\nend\n\nresult = ProcessInventory.execute(inventory_id: 456)\n\n# Executed\nresult.status #=&gt; \"skipped\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Warehouse closed\"\n</code></pre>"},{"location":"interruptions/halt/#failing","title":"Failing","text":"<p><code>fail!</code> communicates that the task encountered an impediment that prevents successful completion. This represents controlled failure where the task explicitly determines that execution cannot continue.</p> <pre><code>class ProcessRefund &lt; CMDx::Task\n  def work\n    # Without a reason\n    fail! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    refund = Refund.find(context.refund_id)\n\n    # With a reason\n    if refund.expired?\n      fail!(\"Refund period has expired\")\n    elsif !refund.amount.positive?\n      fail!(\"Refund amount must be positive\")\n    else\n      refund.process!\n    end\n  end\nend\n\nresult = ProcessRefund.execute(refund_id: 789)\n\n# Executed\nresult.status #=&gt; \"failed\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Refund period has expired\"\n</code></pre>"},{"location":"interruptions/halt/#metadata-enrichment","title":"Metadata Enrichment","text":"<p>Both halt methods accept metadata to provide additional context about the interruption. Metadata is stored as a hash and becomes available through the result object.</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    license = License.find(context.license_id)\n\n    if license.already_renewed?\n      # Without metadata\n      skip!(\"License already renewed\")\n    end\n\n    unless license.renewal_eligible?\n      # With metadata\n      fail!(\n        \"License not eligible for renewal\",\n        error_code: \"LICENSE.NOT_ELIGIBLE\",\n        retry_after: Time.current + 30.days\n      )\n    end\n\n    process_renewal\n  end\nend\n\nresult = ProcessRenewal.execute(license_id: 567)\n\n# Without metadata\nresult.metadata #=&gt; {}\n\n# With metadata\nresult.metadata #=&gt; {\n                #     error_code: \"LICENSE.NOT_ELIGIBLE\",\n                #     retry_after: &lt;Time 30 days from now&gt;\n                #   }\n</code></pre>"},{"location":"interruptions/halt/#state-transitions","title":"State Transitions","text":"<p>Halt methods trigger specific state and status transitions:</p> Method State Status Outcome <code>skip!</code> <code>interrupted</code> <code>skipped</code> <code>good? = true</code>, <code>bad? = true</code> <code>fail!</code> <code>interrupted</code> <code>failed</code> <code>good? = false</code>, <code>bad? = true</code> <pre><code>result = ProcessRenewal.execute(license_id: 567)\n\n# State information\nresult.state        #=&gt; \"interrupted\"\nresult.status       #=&gt; \"skipped\" or \"failed\"\nresult.interrupted? #=&gt; true\nresult.complete?    #=&gt; false\n\n# Outcome categorization\nresult.good?        #=&gt; true for skipped, false for failed\nresult.bad?         #=&gt; true for both skipped and failed\n</code></pre>"},{"location":"interruptions/halt/#execution-behavior","title":"Execution Behavior","text":"<p>Halt methods behave differently depending on the call method used:</p>"},{"location":"interruptions/halt/#non-bang-execution","title":"Non-bang execution","text":"<p>Returns result object without raising exceptions:</p> <pre><code>result = ProcessRefund.execute(refund_id: 789)\n\ncase result.status\nwhen \"success\"\n  puts \"Refund processed: $#{result.context.refund.amount}\"\nwhen \"skipped\"\n  puts \"Refund skipped: #{result.reason}\"\nwhen \"failed\"\n  puts \"Refund failed: #{result.reason}\"\n  handle_refund_error(result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#bang-execution","title":"Bang execution","text":"<p>Raises exceptions for halt conditions based on <code>task_breakpoints</code> configuration:</p> <pre><code>begin\n  result = ProcessRefund.execute!(refund_id: 789)\n  puts \"Success: Refund processed\"\nrescue CMDx::SkipFault =&gt; e\n  puts \"Skipped: #{e.message}\"\nrescue CMDx::FailFault =&gt; e\n  puts \"Failed: #{e.message}\"\n  handle_refund_failure(e.result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#best-practices","title":"Best Practices","text":"<p>Always try to provide a <code>reason</code> when using halt methods. This provides clear context for debugging and creates meaningful exception messages.</p> <pre><code># Good: Clear, specific reason\nskip!(\"Document processing paused for compliance review\")\nfail!(\"File format not supported by processor\", code: \"FORMAT_UNSUPPORTED\")\n\n# Acceptable: Generic, non-specific reason\nskip!(\"Paused\")\nfail!(\"Unsupported\")\n\n# Bad: Default, cannot determine reason\nskip! #=&gt; \"Unspecified\"\nfail! #=&gt; \"Unspecified\"\n</code></pre>"},{"location":"interruptions/halt/#manual-errors","title":"Manual Errors","text":"<p>There are rare cases where you need to manually assign errors.</p> <p>Important</p> <p>Keep in mind you will still need to initiate a fault if a stoppage of work is required.</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    if document.nonrenewable?\n      errors.add(:document, \"not renewable\")\n      fail!(\"document could not be renewed\")\n    else\n      document.renew!\n    end\n  end\nend\n</code></pre>"},{"location":"outcomes/result/","title":"Outcomes - Result","text":"<p>The result object is the comprehensive return value of task execution, providing complete information about the execution outcome, state, timing, and any data produced during the task lifecycle. Results serve as the primary interface for inspecting task execution outcomes and chaining task operations.</p>"},{"location":"outcomes/result/#result-attributes","title":"Result Attributes","text":"<p>Every result provides access to essential execution information:</p> <p>Important</p> <p>Result objects are immutable after task execution completes and reflect the final state.</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Object data\nresult.task     #=&gt; &lt;BuildApplication&gt;\nresult.context  #=&gt; &lt;CMDx::Context&gt;\nresult.chain    #=&gt; &lt;CMDx::Chain&gt;\n\n# Execution data\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\n\n# Fault data\nresult.reason   #=&gt; \"Build tool not found\"\nresult.cause    #=&gt; &lt;CMDx::FailFault&gt;\nresult.metadata #=&gt; { error_code: \"BUILD_TOOL.NOT_FOUND\" }\n</code></pre>"},{"location":"outcomes/result/#lifecycle-information","title":"Lifecycle Information","text":"<p>Results provide comprehensive methods for checking execution state and status:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# State predicates (execution lifecycle)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\nresult.executed?    #=&gt; true (execution finished)\n\n# Status predicates (execution outcome)\nresult.success?     #=&gt; true (successful execution)\nresult.failed?      #=&gt; false (no failure)\nresult.skipped?     #=&gt; false (not skipped)\n\n# Outcome categorization\nresult.good?        #=&gt; true (success or skipped)\nresult.bad?         #=&gt; false (skipped or failed)\n</code></pre>"},{"location":"outcomes/result/#outcome-analysis","title":"Outcome Analysis","text":"<p>Results provide unified outcome determination depending on the fault causal chain:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\nresult.outcome #=&gt; \"success\" (state and status)\n</code></pre>"},{"location":"outcomes/result/#chain-analysis","title":"Chain Analysis","text":"<p>Use these methods to trace the root cause of faults or trace the cause points.</p> <pre><code>result = DeploymentWorkflow.execute(app_name: \"webapp\")\n\nif result.failed?\n  # Find the original cause of failure\n  if original_failure = result.caused_failure\n    puts \"Root cause: #{original_failure.task.class.name}\"\n    puts \"Reason: #{original_failure.reason}\"\n  end\n\n  # Find what threw the failure to this result\n  if throwing_task = result.threw_failure\n    puts \"Failure source: #{throwing_task.task.class.name}\"\n    puts \"Reason: #{throwing_task.reason}\"\n  end\n\n  # Failure classification\n  result.caused_failure?  #=&gt; true if this result was the original cause\n  result.threw_failure?   #=&gt; true if this result threw a failure\n  result.thrown_failure?  #=&gt; true if this result received a thrown failure\nend\n</code></pre>"},{"location":"outcomes/result/#index-and-position","title":"Index and Position","text":"<p>Results track their position within execution chains:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Position in execution sequence\nresult.index #=&gt; 0 (first task in chain)\n\n# Access via chain\nresult.chain.results[result.index] == result #=&gt; true\n</code></pre>"},{"location":"outcomes/result/#block-yield","title":"Block Yield","text":"<p>Implement conditional logic using a block expression that yields a result for complete encapsulation.</p> <pre><code>BuildApplication.execute(version: \"1.2.3\") do |result|\n  if result.success?\n    notify_deployment_ready(result)\n  elsif result.failed?\n    handle_build_failure(result)\n  else\n    log_skip_reason(result)\n  end\nend\n</code></pre>"},{"location":"outcomes/result/#handlers","title":"Handlers","text":"<p>Use result handlers for clean, functional-style conditional logic. Handlers return the result object, enabling method chaining and fluent interfaces.</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Status-based handlers\nresult\n  .handle_success { |result| notify_deployment_ready(result) }\n  .handle_failed { |result| handle_build_failure(result) }\n  .handle_skipped { |result| log_skip_reason(result) }\n\n# State-based handlers\nresult\n  .handle_complete { |result| update_build_status(result) }\n  .handle_interrupted { |result| cleanup_partial_artifacts(result) }\n\n# Outcome-based handlers\nresult\n  .handle_good { |result| increment_success_counter(result) }\n  .handle_bad { |result| alert_operations_team(result) }\n</code></pre>"},{"location":"outcomes/result/#pattern-matching","title":"Pattern Matching","text":"<p>Results support Ruby's pattern matching through array and hash deconstruction:</p> <p>Important</p> <p>Pattern matching requires Ruby 3.0+</p>"},{"location":"outcomes/result/#array-pattern","title":"Array Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin [\"complete\", \"success\"]\n  redirect_to build_success_page\nin [\"interrupted\", \"failed\"]\n  retry_build_with_backoff(result)\nin [\"interrupted\", \"skipped\"]\n  log_skip_and_continue\nend\n</code></pre>"},{"location":"outcomes/result/#hash-pattern","title":"Hash Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin { state: \"complete\", status: \"success\" }\n  celebrate_build_success\nin { status: \"failed\", metadata: { retryable: true } }\n  schedule_build_retry(result)\nin { bad: true, metadata: { reason: String =&gt; reason } }\n  escalate_build_error(\"Build failed: #{reason}\")\nend\n</code></pre>"},{"location":"outcomes/result/#pattern-guards","title":"Pattern Guards","text":"<pre><code>case result\nin { status: \"failed\", metadata: { attempts: n } } if n &lt; 3\n  retry_build_with_delay(result, n * 2)\nin { status: \"failed\", metadata: { attempts: n } } if n &gt;= 3\n  mark_build_permanently_failed(result)\nin { runtime: time } if time &gt; performance_threshold\n  investigate_build_performance(result)\nend\n</code></pre>"},{"location":"outcomes/states/","title":"Outcomes - States","text":"<p>States represent the execution lifecycle condition of task execution, tracking the progress of tasks through their complete execution journey. States provide insight into where a task is in its lifecycle and enable lifecycle-based decision making and monitoring.</p>"},{"location":"outcomes/states/#definitions","title":"Definitions","text":"State Description <code>initialized</code> Task created but execution not yet started. Default state for new tasks. <code>executing</code> Task is actively running its business logic. Transient state during execution. <code>complete</code> Task finished execution successfully without any interruption or halt. <code>interrupted</code> Task execution was stopped due to a fault, exception, or explicit halt. <p>State-Status combinations:</p> State Status Meaning <code>initialized</code> <code>success</code> Task created, not yet executed <code>executing</code> <code>success</code> Task currently running <code>complete</code> <code>success</code> Task finished successfully <code>complete</code> <code>skipped</code> Task finished by skipping execution <code>interrupted</code> <code>failed</code> Task stopped due to failure <code>interrupted</code> <code>skipped</code> Task stopped by skip condition"},{"location":"outcomes/states/#transitions","title":"Transitions","text":"<p>Caution</p> <p>States are automatically managed during task execution and should never be modified manually. State transitions are handled internally by the CMDx framework.</p> <pre><code># Valid state transition flow\ninitialized \u2192 executing \u2192 complete    (successful execution)\ninitialized \u2192 executing \u2192 interrupted (skipped/failed execution)\n</code></pre>"},{"location":"outcomes/states/#predicates","title":"Predicates","text":"<p>Use state predicates to check the current execution lifecycle:</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state checks\nresult.initialized? #=&gt; false (after execution)\nresult.executing?   #=&gt; false (after execution)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\n\n# State categorization\nresult.executed?    #=&gt; true (complete OR interrupted)\n</code></pre>"},{"location":"outcomes/states/#handlers","title":"Handlers","text":"<p>Use state-based handlers for lifecycle event handling. The <code>on_executed</code> handler is particularly useful for cleanup operations that should run regardless of success, skipped, or failure.</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state handlers\nresult\n  .handle_complete { |result| send_upload_notification(result) }\n  .handle_interrupted { |result| cleanup_temp_files(result) }\n  .handle_executed { |result| log_upload_metrics(result) }\n</code></pre>"},{"location":"outcomes/statuses/","title":"Outcomes - Statuses","text":"<p>Statuses represent the business outcome of task execution logic, indicating how the task's business logic concluded. Statuses differ from execution states by focusing on the business outcome rather than the technical execution lifecycle. Understanding statuses is crucial for implementing proper business logic branching and error handling.</p>"},{"location":"outcomes/statuses/#definitions","title":"Definitions","text":"Status Description <code>success</code> Task execution completed successfully with expected business outcome. Default status for all tasks. <code>skipped</code> Task intentionally stopped execution because conditions weren't met or continuation was unnecessary. <code>failed</code> Task stopped execution due to business rule violations, validation errors, or exceptions."},{"location":"outcomes/statuses/#transitions","title":"Transitions","text":"<p>Important</p> <p>Status transitions are unidirectional and final. Once a task is marked as skipped or failed, it cannot return to success status. Design your business logic accordingly.</p> <pre><code># Valid status transitions\nsuccess \u2192 skipped    # via skip!\nsuccess \u2192 failed     # via fail! or exception\n\n# Invalid transitions (will raise errors)\nskipped \u2192 success    # \u274c Cannot transition\nskipped \u2192 failed     # \u274c Cannot transition\nfailed \u2192 success     # \u274c Cannot transition\nfailed \u2192 skipped     # \u274c Cannot transition\n</code></pre>"},{"location":"outcomes/statuses/#predicates","title":"Predicates","text":"<p>Use status predicates to check execution outcomes:</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status checks\nresult.success? #=&gt; true/false\nresult.skipped? #=&gt; true/false\nresult.failed?  #=&gt; true/false\n\n# Outcome categorization\nresult.good?    #=&gt; true if success OR skipped\nresult.bad?     #=&gt; true if skipped OR failed (not success)\n</code></pre>"},{"location":"outcomes/statuses/#handlers","title":"Handlers","text":"<p>Use status-based handlers for business logic branching. The <code>on_good</code> and <code>on_bad</code> handlers are particularly useful for handling success/skip vs failed outcomes respectively.</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status handlers\nresult\n  .handle_success { |result| mark_notification_sent(result) }\n  .handle_skipped { |result| log_notification_skipped(result) }\n  .handle_failed { |result| queue_retry_notification(result) }\n\n# Outcome-based handlers\nresult\n  .handle_good { |result| update_message_stats(result) }\n  .handle_bad { |result| track_delivery_failure(result) }\n</code></pre>"}]}