{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CMDx","text":"<p>Build business logic that's powerful, predictable, and maintainable.</p> <p> </p> <p>Say goodbye to messy service objects. CMDx (pronounced \"Command X\") helps you design business logic with clarity and consistency\u2014build faster, debug easier, and ship with confidence.</p> <p>Note</p> <p>Documentation reflects the latest code on <code>main</code>. For version-specific documentation, please refer to the <code>docs/</code> directory within that version's tag.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Ruby: MRI 3.1+ or JRuby 9.4+.</li> </ul> <p>CMDx works with any Ruby framework. Rails support is built-in, but it's framework-agnostic at its core.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>gem install cmdx\n\n# - or -\n\nbundle add cmdx\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Build powerful business logic in four simple steps:</p>"},{"location":"#1-compose","title":"1. Compose","text":"Full Featured TaskMinimum Viable Task <pre><code>class AnalyzeMetrics &lt; CMDx::Task\n  register :middleware, CMDx::Middlewares::Correlate, id: -&gt; { Current.request_id }\n\n  on_success :track_analysis_completion!\n\n  required :dataset_id, type: :integer, numeric: { min: 1 }\n  optional :analysis_type, default: \"standard\"\n\n  def work\n    if dataset.nil?\n      fail!(\"Dataset not found\", code: 404)\n    elsif dataset.unprocessed?\n      skip!(\"Dataset not ready for analysis\")\n    else\n      context.result = PValueAnalyzer.execute(dataset:, analysis_type:)\n      context.analyzed_at = Time.now\n\n      SendAnalyzedEmail.execute(user_id: Current.account.manager_id)\n    end\n  end\n\n  private\n\n  def dataset\n    @dataset ||= Dataset.find_by(id: dataset_id)\n  end\n\n  def track_analysis_completion!\n    dataset.update!(analysis_result_id: context.result.id)\n  end\nend\n</code></pre> <pre><code>class SendAnalyzedEmail &lt; CMDx::Task\n  def work\n    user = User.find(context.user_id)\n    MetricsMailer.analyzed(user).deliver_now\n  end\nend\n</code></pre>"},{"location":"#2-execute","title":"2. Execute","text":"<pre><code>result = AnalyzeMetrics.execute(\n  dataset_id: 123,\n  \"analysis_type\" =&gt; \"advanced\"\n)\n</code></pre>"},{"location":"#3-react","title":"3. React","text":"<pre><code>if result.success?\n  puts \"Metrics analyzed at #{result.context.analyzed_at}\"\nelsif result.skipped?\n  puts \"Skipping analyzation due to: #{result.reason}\"\nelsif result.failed?\n  puts \"Analyzation failed due to: #{result.reason} with code #{result.metadata[:code]}\"\nend\n</code></pre>"},{"location":"#4-observe","title":"4. Observe","text":"<pre><code>I, [2022-07-17T18:42:37.000000 #3784] INFO -- CMDx:\nindex=1 chain_id=\"018c2b95-23j4-2kj3-32kj-3n4jk3n4jknf\" type=\"Task\" class=\"SendAnalyzedEmail\" state=\"complete\" status=\"success\" metadata={runtime: 347}\n\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"AnalyzeMetrics\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n</code></pre> <p>Ready to dive in? Check out the Getting Started guide to learn more.</p>"},{"location":"#ecosystem","title":"Ecosystem","text":"<ul> <li>cmdx-rspec - RSpec test matchers</li> </ul> <p>For backwards compatibility of certain functionality:</p> <ul> <li>cmdx-i18n - 85+ translations, <code>v1.5.0</code> - <code>v1.6.2</code></li> <li>cmdx-parallel - Parallel workflow tasks, <code>v1.6.1</code> - <code>v1.6.2</code></li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Bug reports and pull requests are welcome at https://github.com/drexed/cmdx. We're committed to fostering a welcoming, collaborative community. Please follow our code of conduct.</p>"},{"location":"#license","title":"License","text":"<p>The gem is available as open source under the terms of the MIT License.</p>"},{"location":"callbacks/","title":"Callbacks","text":"<p>Run custom logic at specific points during task execution. Callbacks have full access to task context and results, making them perfect for logging, notifications, cleanup, and more.</p> <p>See Global Configuration for framework-wide callback setup.</p> <p>Important</p> <p>Callbacks execute in declaration order (FIFO). Multiple callbacks of the same type run sequentially.</p>"},{"location":"callbacks/#available-callbacks","title":"Available Callbacks","text":"<p>Callbacks execute in a predictable lifecycle order:</p> <pre><code>1. before_validation           # Pre-validation setup\n2. before_execution            # Prepare for execution\n\n# --- Task#work executes ---\n\n3. on_[complete|interrupted]   # State-based (execution lifecycle)\n4. on_executed                 # Always runs after work completes\n5. on_[success|skipped|failed] # Status-based (business outcome)\n6. on_[good|bad]               # Outcome-based (success/skip vs fail)\n</code></pre>"},{"location":"callbacks/#declarations","title":"Declarations","text":""},{"location":"callbacks/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for simple callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  before_execution :find_reservation\n\n  # Batch declarations (works for any type)\n  on_complete :notify_guest, :update_availability\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def find_reservation\n    @reservation ||= Reservation.find(context.reservation_id)\n  end\n\n  def notify_guest\n    GuestNotifier.call(context.guest, result)\n  end\n\n  def update_availability\n    AvailabilityService.update(context.room_ids, result)\n  end\nend\n</code></pre>"},{"location":"callbacks/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for inline callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Proc\n  on_interrupted proc { ReservationSystem.pause! }\n\n  # Lambda\n  on_complete -&gt; { ReservationSystem.resume! }\nend\n</code></pre>"},{"location":"callbacks/#class-or-module","title":"Class or Module","text":"<p>Implement reusable callback logic in dedicated modules and classes:</p> <pre><code>class BookingConfirmationCallback\n  def call(task)\n    if task.result.success?\n      MessagingApi.send_confirmation(task.context.guest)\n    else\n      MessagingApi.send_issue_alert(task.context.manager)\n    end\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # Class or Module\n  on_success BookingConfirmationCallback\n\n  # Instance\n  on_interrupted BookingConfirmationCallback.new\nend\n</code></pre>"},{"location":"callbacks/#conditional-execution","title":"Conditional Execution","text":"<p>Control callback execution with conditional logic:</p> <pre><code>class MessagingPermissionCheck\n  def call(task)\n    task.context.guest.can?(:receive_messages)\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # If and/or Unless\n  before_execution :notify_guest, if: :messaging_enabled?, unless: :messaging_blocked?\n\n  # Proc\n  on_failure :increment_failure, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Legacy\") }\n\n  # Lambda\n  on_success :ping_housekeeping, if: proc { context.rooms_need_cleaning? }\n\n  # Class or Module\n  on_complete :send_confirmation, unless: MessagingPermissionCheck\n\n  # Instance\n  on_complete :send_confirmation, if: MessagingPermissionCheck.new\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def messaging_enabled?\n    context.guest.messaging_preference == true\n  end\n\n  def messaging_blocked?\n    context.guest.communication_status == :blocked\n  end\nend\n</code></pre>"},{"location":"callbacks/#callback-removal","title":"Callback Removal","text":"<p>Remove unwanted callbacks dynamically:</p> <p>Important</p> <p>Each <code>deregister</code> call removes one callback. Use multiple calls for batch removals.</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Symbol\n  deregister :callback, :before_execution, :notify_guest\n\n  # Class or Module (no instances)\n  deregister :callback, :on_complete, BookingConfirmationCallback\nend\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>Configure CMDx to customize framework behavior, register components, and control execution flow through global defaults with task-level overrides.</p>"},{"location":"configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>CMDx uses a straightforward two-tier configuration system:</p> <ol> <li>Global Configuration \u2014 Framework-wide defaults</li> <li>Task Settings \u2014 Class-level overrides using <code>settings</code></li> </ol> <p>Important</p> <p>Task settings take precedence over global config. Settings are inherited from parent classes and can be overridden in subclasses.</p>"},{"location":"configuration/#global-configuration","title":"Global Configuration","text":"<p>Configure framework-wide defaults that apply to all tasks. These settings come with sensible defaults out of the box.</p>"},{"location":"configuration/#breakpoints","title":"Breakpoints","text":"<p>Control when <code>execute!</code> raises a <code>CMDx::Fault</code> based on task status.</p> <pre><code>CMDx.configure do |config|\n  config.task_breakpoints = \"failed\" # String or Array[String]\nend\n</code></pre> <p>For workflows, configure which statuses halt the execution pipeline:</p> <pre><code>CMDx.configure do |config|\n  config.workflow_breakpoints = [\"skipped\", \"failed\"]\nend\n</code></pre>"},{"location":"configuration/#rollback","title":"Rollback","text":"<p>Control when a <code>rollback</code> of task execution is called.</p> <pre><code>CMDx.configure do |config|\n  config.rollback_on = [\"failed\"] # String or Array[String]\nend\n</code></pre>"},{"location":"configuration/#backtraces","title":"Backtraces","text":"<p>Enable detailed backtraces for non-fault exceptions to improve debugging. Optionally clean up stack traces to remove framework noise.</p> <p>Note</p> <p>In Rails environments, <code>backtrace_cleaner</code> defaults to <code>Rails.backtrace_cleaner.clean</code>.</p> <pre><code>CMDx.configure do |config|\n  # Truthy\n  config.backtrace = true\n\n  # Via callable (must respond to `call(backtrace)`)\n  config.backtrace_cleaner = AdvanceCleaner.new\n\n  # Via proc or lambda\n  config.backtrace_cleaner = -&gt;(backtrace) { backtrace[0..5] }\nend\n</code></pre>"},{"location":"configuration/#exception-handlers","title":"Exception Handlers","text":"<p>Register handlers that run when non-fault exceptions occur.</p> <p>Tip</p> <p>Use exception handlers to send errors to your APM of choice.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, exception)`)\n  config.exception_handler = NewRelicReporter\n\n  # Via proc or lambda\n  config.exception_handler = proc do |task, exception|\n    APMService.report(exception, extra_data: { task: task.name, id: task.id })\n  end\nend\n</code></pre>"},{"location":"configuration/#logging","title":"Logging","text":"<pre><code>CMDx.configure do |config|\n  config.logger = CustomLogger.new($stdout)\nend\n</code></pre>"},{"location":"configuration/#middlewares","title":"Middlewares","text":"<p>See the Middlewares docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, options)`)\n  config.middlewares.register CMDx::Middlewares::Timeout\n\n  # Via proc or lambda\n  config.middlewares.register proc { |task, options|\n    start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    result = yield\n    end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    Rails.logger.debug { \"task completed in #{((end_time - start_time) * 1000).round(2)}ms\" }\n    result\n  }\n\n  # With options\n  config.middlewares.register AuditTrailMiddleware, service_name: \"document_processor\"\n\n  # Remove middleware\n  config.middlewares.deregister CMDx::Middlewares::Timeout\nend\n</code></pre> <p>Note</p> <p>Middlewares are executed in registration order. Each middleware wraps the next, creating an execution chain around task logic.</p>"},{"location":"configuration/#callbacks","title":"Callbacks","text":"<p>See the Callbacks docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via method\n  config.callbacks.register :before_execution, :initialize_user_session\n\n  # Via callable (must respond to `call(task)`)\n  config.callbacks.register :on_success, LogUserActivity\n\n  # Via proc or lambda\n  config.callbacks.register :on_complete, proc { |task|\n    execution_time = task.metadata[:runtime]\n    Metrics.timer(\"task.execution_time\", execution_time, tags: [\"task:#{task.class.name.underscore}\"])\n  }\n\n  # With options\n  config.callbacks.register :on_failure, :send_alert_notification, if: :critical_task?\n\n  # Remove callback\n  config.callbacks.deregister :on_success, LogUserActivity\nend\n</code></pre>"},{"location":"configuration/#coercions","title":"Coercions","text":"<p>See the Attributes - Coercions docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.coercions.register :currency, CurrencyCoercion\n\n  # Via method (must match signature `def coordinates_coercion(value, options)`)\n  config.coercions.register :coordinates, :coordinates_coercion\n\n  # Via proc or lambda\n  config.coercions.register :tag_list, proc { |value, options|\n    delimiter = options[:delimiter] || ','\n    max_tags = options[:max_tags] || 50\n\n    tags = value.to_s.split(delimiter).map(&amp;:strip).reject(&amp;:empty?)\n    tags.first(max_tags)\n  }\n\n  # Remove coercion\n  config.coercions.deregister :currency\nend\n</code></pre>"},{"location":"configuration/#validators","title":"Validators","text":"<p>See the Attributes - Validations docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.validators.register :username, UsernameValidator\n\n  # Via method (must match signature `def url_validator(value, options)`)\n  config.validators.register :url, :url_validator\n\n  # Via proc or lambda\n  config.validators.register :access_token, proc { |value, options|\n    expected_prefix = options[:prefix] || \"tok_\"\n    minimum_length = options[:min_length] || 40\n\n    value.start_with?(expected_prefix) &amp;&amp; value.length &gt;= minimum_length\n  }\n\n  # Remove validator\n  config.validators.deregister :username\nend\n</code></pre>"},{"location":"configuration/#task-configuration","title":"Task Configuration","text":""},{"location":"configuration/#settings","title":"Settings","text":"<p>Override global configuration for specific tasks using <code>settings</code>:</p> <pre><code>class GenerateInvoice &lt; CMDx::Task\n  settings(\n    # Global configuration overrides\n    task_breakpoints: [\"failed\"],                # Breakpoint override\n    workflow_breakpoints: [],                    # Breakpoint override\n    backtrace: true,                             # Toggle backtrace\n    backtrace_cleaner: -&gt;(bt) { bt[0..5] },      # Backtrace cleaner\n    logger: CustomLogger.new($stdout),           # Custom logger\n\n    # Task configuration settings\n    breakpoints: [\"failed\"],                     # Contextual pointer for :task_breakpoints and :workflow_breakpoints\n    log_level: :info,                            # Log level override\n    log_formatter: CMDx::LogFormatters::Json.new # Log formatter override\n    tags: [\"billing\", \"financial\"],              # Logging tags\n    deprecated: true,                            # Task deprecations\n    retries: 3,                                  # Non-fault exception retries\n    retry_on: [External::ApiError],              # List of exceptions to retry on\n    retry_jitter: 1,                             # Space between retry iteration, eg: current retry num + 1\n    rollback_on: [\"failed\", \"skipped\"],          # Rollback on override\n  )\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Important</p> <p>Retries reuse the same context. By default, all <code>StandardError</code> exceptions (including faults) are retried unless you specify <code>retry_on</code> option for specific matches.</p>"},{"location":"configuration/#registrations","title":"Registrations","text":"<p>Register or deregister middlewares, callbacks, coercions, and validators for specific tasks:</p> <pre><code>class SendCampaignEmail &lt; CMDx::Task\n  # Middlewares\n  register :middleware, CMDx::Middlewares::Timeout\n  deregister :middleware, AuditTrailMiddleware\n\n  # Callbacks\n  register :callback, :on_complete, proc { |task|\n    runtime = task.metadata[:runtime]\n    Analytics.track(\"email_campaign.sent\", runtime, tags: [\"task:#{task.class.name}\"])\n  }\n  deregister :callback, :before_execution, :initialize_user_session\n\n  # Coercions\n  register :coercion, :currency, CurrencyCoercion\n  deregister :coercion, :coordinates\n\n  # Validators\n  register :validator, :username, :username_validator\n  deregister :validator, :url\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"configuration/#configuration-management","title":"Configuration Management","text":""},{"location":"configuration/#access","title":"Access","text":"<pre><code># Global configuration access\nCMDx.configuration.logger               #=&gt; &lt;Logger instance&gt;\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"]\nCMDx.configuration.middlewares.registry #=&gt; [&lt;Middleware&gt;, ...]\n\n# Task configuration access\nclass ProcessUpload &lt; CMDx::Task\n  settings(tags: [\"files\", \"storage\"])\n\n  def work\n    self.class.settings[:logger] #=&gt; Global configuration value\n    self.class.settings[:tags]   #=&gt; Task configuration value =&gt; [\"files\", \"storage\"]\n  end\nend\n</code></pre>"},{"location":"configuration/#resetting","title":"Resetting","text":"<p>Warning</p> <p>Resetting affects your entire application. Use this primarily in test environments.</p> <pre><code># Reset to framework defaults\nCMDx.reset_configuration!\n\n# Verify reset\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"] (default)\nCMDx.configuration.middlewares.registry #=&gt; Empty registry\n\n# Commonly used in test setup (RSpec example)\nRSpec.configure do |config|\n  config.before(:each) do\n    CMDx.reset_configuration!\n  end\nend\n</code></pre>"},{"location":"deprecation/","title":"Task Deprecation","text":"<p>Manage legacy tasks gracefully with built-in deprecation support. Choose how to handle deprecated tasks\u2014log warnings for awareness, issue Ruby warnings for development, or prevent execution entirely.</p>"},{"location":"deprecation/#modes","title":"Modes","text":""},{"location":"deprecation/#raise","title":"Raise","text":"<p>Prevent task execution completely. Perfect for tasks that must no longer run.</p> <p>Warning</p> <p>Use <code>:raise</code> mode carefully\u2014it will break existing workflows immediately.</p> <pre><code>class ProcessObsoleteAPI &lt; CMDx::Task\n  settings(deprecated: :raise)\n\n  def work\n    # Will never execute...\n  end\nend\n\nresult = ProcessObsoleteAPI.execute\n#=&gt; raises CMDx::DeprecationError: \"ProcessObsoleteAPI usage prohibited\"\n</code></pre>"},{"location":"deprecation/#log","title":"Log","text":"<p>Allow execution while tracking deprecation in logs. Ideal for gradual migrations.</p> <pre><code>class ProcessLegacyFormat &lt; CMDx::Task\n  settings(deprecated: :log)\n\n  # Same\n  settings(deprecated: true)\n\n  def work\n    # Executes but logs deprecation warning...\n  end\nend\n\nresult = ProcessLegacyFormat.execute\nresult.successful? #=&gt; true\n\n# Deprecation warning appears in logs:\n# WARN -- : DEPRECATED: ProcessLegacyFormat - migrate to replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#warn","title":"Warn","text":"<p>Issue Ruby warnings visible during development and testing. Keeps production logs clean while alerting developers.</p> <pre><code>class ProcessOldData &lt; CMDx::Task\n  settings(deprecated: :warn)\n\n  def work\n    # Executes but emits Ruby warning...\n  end\nend\n\nresult = ProcessOldData.execute\nresult.successful? #=&gt; true\n\n# Ruby warning appears in stderr:\n# [ProcessOldData] DEPRECATED: migrate to a replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#declarations","title":"Declarations","text":""},{"location":"deprecation/#symbol-or-string","title":"Symbol or String","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecated: :raise)\n\n  # String\n  settings(deprecated: \"warn\")\nend\n</code></pre>"},{"location":"deprecation/#boolean-or-nil","title":"Boolean or Nil","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Deprecates with default :log mode\n  settings(deprecated: true)\n\n  # Skips deprecation\n  settings(deprecated: false)\n  settings(deprecated: nil)\nend\n</code></pre>"},{"location":"deprecation/#method","title":"Method","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecated: :deprecated?)\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def deprecated?\n    Time.now.year &gt; 2024 ? :raise : false\n  end\nend\n</code></pre>"},{"location":"deprecation/#proc-or-lambda","title":"Proc or Lambda","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Proc\n  settings(deprecated: proc { Rails.env.development? ? :raise : :log })\n\n  # Lambda\n  settings(deprecated: -&gt; { Current.tenant.legacy_mode? ? :warn : :raise })\nend\n</code></pre>"},{"location":"deprecation/#class-or-module","title":"Class or Module","text":"<pre><code>class OutdatedTaskDeprecator\n  def call(task)\n    task.class.name.include?(\"Outdated\")\n  end\nend\n\nclass OutdatedConnector &lt; CMDx::Task\n  # Class or Module\n  settings(deprecated: OutdatedTaskDeprecator)\n\n  # Instance\n  settings(deprecated: OutdatedTaskDeprecator.new)\nend\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>CMDx is a Ruby framework for building maintainable, observable business logic through composable command objects. It brings structure, consistency, and powerful developer tools to your business processes.</p> <p>Common challenges:</p> <ul> <li>Inconsistent service object patterns across your codebase</li> <li>Black boxes make debugging a nightmare</li> <li>Fragile error handling erodes confidence</li> </ul> <p>What you get:</p> <ul> <li>Consistent, standardized architecture</li> <li>Built-in flow control and error handling</li> <li>Composable, reusable workflows</li> <li>Comprehensive logging for observability</li> <li>Attribute validation with type coercions</li> <li>Sensible defaults and developer-friendly APIs</li> </ul>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Add CMDx to your Gemfile:</p> <pre><code>gem install cmdx\n\n# - or -\n\nbundle add cmdx\n</code></pre>"},{"location":"getting_started/#configuration","title":"Configuration","text":"<p>For Rails applications, run the following command to generate a global configuration file in <code>config/initializers/cmdx.rb</code>.</p> <pre><code>rails generate cmdx:install\n</code></pre> <p>If not using Rails, manually copy the configuration file.</p>"},{"location":"getting_started/#the-cero-pattern","title":"The CERO Pattern","text":"<p>CMDx embraces the Compose, Execute, React, Observe (CERO, pronounced \"zero\") pattern\u2014a simple yet powerful approach to building reliable business logic.</p>"},{"location":"getting_started/#compose","title":"Compose","text":"<p>Build reusable, single-responsibility tasks with typed attributes, validation, and callbacks. Tasks can be chained together in workflows to create complex business processes from simple building blocks.</p> <pre><code>class AnalyzeMetrics &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"getting_started/#execute","title":"Execute","text":"<p>Invoke tasks with a consistent API that always returns a result object. Execution automatically handles validation, type coercion, error handling, and logging. Arguments are validated and coerced before your task logic runs.</p> <pre><code># Without args\nresult = AnalyzeMetrics.execute\n\n# With args\nresult = AnalyzeMetrics.execute(model: \"blackbox\", \"sensitivity\" =&gt; 3)\n</code></pre>"},{"location":"getting_started/#react","title":"React","text":"<p>Every execution returns a result object with a clear outcome. Check the result's state (<code>success?</code>, <code>failed?</code>, <code>skipped?</code>) and access returned values, error messages, and metadata to make informed decisions.</p> <pre><code>if result.success?\n  # Handle success\nelsif result.skipped?\n  # Handle skipped\nelsif result.failed?\n  # Handle failed\nend\n</code></pre>"},{"location":"getting_started/#observe","title":"Observe","text":"<p>Every task execution generates structured logs with execution chains, runtime metrics, and contextual metadata. Logs can be automatically correlated using chain IDs, making it easy to trace complex workflows and debug issues.</p> <pre><code>I, [2022-07-17T18:42:37.000000 #3784] INFO -- CMDx:\nindex=1 chain_id=\"018c2b95-23j4-2kj3-32kj-3n4jk3n4jknf\" type=\"Task\" class=\"SendAnalyzedEmail\" state=\"complete\" status=\"success\" metadata={runtime: 347}\n\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"AnalyzeMetrics\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n</code></pre>"},{"location":"getting_started/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:task ModerateBlogPost\n</code></pre> <p>This creates a new task file with the basic structure:</p> <pre><code># app/tasks/moderate_blog_post.rb\nclass ModerateBlogPost &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + noun for task names, eg: <code>ModerateBlogPost</code>, <code>ScheduleAppointment</code>, <code>ValidateDocument</code></p>"},{"location":"getting_started/#type-safety","title":"Type safety","text":"<p>CMDx includes built-in RBS (Ruby Type Signature) inline annotations throughout the codebase, providing type information for static analysis and editor support.</p> <ul> <li>Type checking \u2014 Catch type errors before runtime using tools like Steep or TypeProf</li> <li>Better IDE support \u2014 Enhanced autocomplete, navigation, and inline documentation</li> <li>Self-documenting code \u2014 Clear method signatures and return types</li> <li>Refactoring confidence \u2014 Type-aware refactoring reduces bugs</li> </ul>"},{"location":"internationalization/","title":"Internationalization (i18n)","text":"<p>CMDx supports 90+ languages out of the box for all error messages, validations, coercions, and faults. Error messages automatically adapt to the current <code>I18n.locale</code>, making it easy to build applications for global audiences.</p>"},{"location":"internationalization/#usage","title":"Usage","text":"<p>All error messages are automatically localized based on your current locale:</p> <pre><code>class ProcessQuote &lt; CMDx::Task\n  attribute :price, type: :float\n\n  def work\n    # Your logic here...\n  end\nend\n\nI18n.with_locale(:fr) do\n  result = ProcessQuote.execute(price: \"invalid\")\n  result.metadata[:messages][:price] #=&gt; [\"impossible de contraindre en float\"]\nend\n</code></pre>"},{"location":"internationalization/#configuration","title":"Configuration","text":"<p>CMDx uses the <code>I18n</code> gem for localization. In Rails, locales load automatically.</p>"},{"location":"internationalization/#copy-locale-files","title":"Copy Locale Files","text":"<p>Copy locale files to your Rails application's <code>config/locales</code> directory:</p> <pre><code>rails generate cmdx:locale [LOCALE]\n\n# Eg: generate french locale\nrails generate cmdx:locale fr\n</code></pre>"},{"location":"internationalization/#available-locales","title":"Available Locales","text":"<ul> <li>af - Afrikaans</li> <li>ar - Arabic</li> <li>az - Azerbaijani</li> <li>be - Belarusian</li> <li>bg - Bulgarian</li> <li>bn - Bengali</li> <li>bs - Bosnian</li> <li>ca - Catalan</li> <li>cnr - Montenegrin</li> <li>cs - Czech</li> <li>cy - Welsh</li> <li>da - Danish</li> <li>de - German</li> <li>dz - Dzongkha</li> <li>el - Greek</li> <li>en - English</li> <li>eo - Esperanto</li> <li>es - Spanish</li> <li>et - Estonian</li> <li>eu - Basque</li> <li>fa - Persian</li> <li>fi - Finnish</li> <li>fr - French</li> <li>fy - Western Frisian</li> <li>gd - Scottish Gaelic</li> <li>gl - Galician</li> <li>he - Hebrew</li> <li>hi - Hindi</li> <li>hr - Croatian</li> <li>hu - Hungarian</li> <li>hy - Armenian</li> <li>id - Indonesian</li> <li>is - Icelandic</li> <li>it - Italian</li> <li>ja - Japanese</li> <li>ka - Georgian</li> <li>kk - Kazakh</li> <li>km - Khmer</li> <li>kn - Kannada</li> <li>ko - Korean</li> <li>lb - Luxembourgish</li> <li>lo - Lao</li> <li>lt - Lithuanian</li> <li>lv - Latvian</li> <li>mg - Malagasy</li> <li>mk - Macedonian</li> <li>ml - Malayalam</li> <li>mn - Mongolian</li> <li>mr-IN - Marathi (India)</li> <li>ms - Malay</li> <li>nb - Norwegian Bokm\u00e5l</li> <li>ne - Nepali</li> <li>nl - Dutch</li> <li>nn - Norwegian Nynorsk</li> <li>oc - Occitan</li> <li>or - Odia</li> <li>pa - Punjabi</li> <li>pl - Polish</li> <li>pt - Portuguese</li> <li>rm - Romansh</li> <li>ro - Romanian</li> <li>ru - Russian</li> <li>sc - Sardinian</li> <li>sk - Slovak</li> <li>sl - Slovenian</li> <li>sq - Albanian</li> <li>sr - Serbian</li> <li>st - Southern Sotho</li> <li>sv - Swedish</li> <li>sw - Swahili</li> <li>ta - Tamil</li> <li>te - Telugu</li> <li>th - Thai</li> <li>tl - Tagalog</li> <li>tr - Turkish</li> <li>tt - Tatar</li> <li>ug - Uyghur</li> <li>uk - Ukrainian</li> <li>ur - Urdu</li> <li>uz - Uzbek</li> <li>vi - Vietnamese</li> <li>wo - Wolof</li> <li>zh-CN - Chinese (Simplified)</li> <li>zh-HK - Chinese (Hong Kong)</li> <li>zh-TW - Chinese (Traditional)</li> <li>zh-YUE - Chinese (Yue)</li> </ul>"},{"location":"logging/","title":"Logging","text":"<p>CMDx automatically logs every task execution with structured data, making debugging and monitoring effortless. Choose from multiple formatters to match your logging infrastructure.</p>"},{"location":"logging/#formatters","title":"Formatters","text":"<p>Choose the format that works best for your logging system:</p> Formatter Use Case Output Style <code>Line</code> Traditional logging Single-line format <code>Json</code> Structured systems Compact JSON <code>KeyValue</code> Log parsing <code>key=value</code> pairs <code>Logstash</code> ELK stack JSON with @version/@timestamp <code>Raw</code> Minimal output Message content only <p>Sample output:</p> <pre><code>&lt;!-- Success (INFO level) --&gt;\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- GenerateInvoice:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"GenerateInvoice\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n\n&lt;!-- Skipped (WARN level) --&gt;\nW, [2022-07-17T18:43:15.000000 #3784] WARN -- ValidateCustomer:\nindex=1 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"ValidateCustomer\" state=\"interrupted\" status=\"skipped\" reason=\"Customer already validated\"\n\n&lt;!-- Failed (ERROR level) --&gt;\nE, [2022-07-17T18:43:15.000000 #3784] ERROR -- CalculateTax:\nindex=2 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"CalculateTax\"  state=\"interrupted\" status=\"failed\" metadata={error_code: \"TAX_SERVICE_UNAVAILABLE\"}\n\n&lt;!-- Failed Chain --&gt;\nE, [2022-07-17T18:43:15.000000 #3784] ERROR -- BillingWorkflow:\nindex=3 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"BillingWorkflow\"  state=\"interrupted\" status=\"failed\" caused_failure={index: 2, class: \"CalculateTax\", status: \"failed\"} threw_failure={index: 1, class: \"ValidateCustomer\", status: \"failed\"}\n</code></pre> <p>Tip</p> <p>Use logging as a low-level event stream to track all tasks in a request. Combine with correlation for powerful distributed tracing.</p>"},{"location":"logging/#structure","title":"Structure","text":"<p>Every log entry includes rich metadata. Available fields depend on execution context and outcome.</p>"},{"location":"logging/#core-fields","title":"Core Fields","text":"Field Description Example <code>severity</code> Log level <code>INFO</code>, <code>WARN</code>, <code>ERROR</code> <code>timestamp</code> ISO 8601 execution time <code>2022-07-17T18:43:15.000000</code> <code>pid</code> Process ID <code>3784</code>"},{"location":"logging/#task-information","title":"Task Information","text":"Field Description Example <code>index</code> Execution sequence position <code>0</code>, <code>1</code>, <code>2</code> <code>chain_id</code> Unique execution chain ID <code>018c2b95-b764-7615...</code> <code>type</code> Execution unit type <code>Task</code>, <code>Workflow</code> <code>class</code> Task class name <code>GenerateInvoiceTask</code> <code>id</code> Unique task instance ID <code>018c2b95-b764-7615...</code> <code>tags</code> Custom categorization <code>[\"billing\", \"financial\"]</code>"},{"location":"logging/#execution-data","title":"Execution Data","text":"Field Description Example <code>state</code> Lifecycle state <code>complete</code>, <code>interrupted</code> <code>status</code> Business outcome <code>success</code>, <code>skipped</code>, <code>failed</code> <code>outcome</code> Final classification <code>success</code>, <code>interrupted</code> <code>metadata</code> Custom task data <code>{order_id: 123, amount: 99.99}</code>"},{"location":"logging/#failure-chain","title":"Failure Chain","text":"Field Description <code>reason</code> Reason given for the stoppage <code>caused</code> Cause exception details <code>caused_failure</code> Original failing task details <code>threw_failure</code> Task that propagated the failure"},{"location":"logging/#usage","title":"Usage","text":"<p>Access the framework logger directly within tasks:</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  def work\n    logger.debug { \"Activated feature flags: #{Features.active_flags}\" }\n    # Your logic here...\n    logger.info(\"Subscription processed\")\n  end\nend\n</code></pre>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Wrap task execution with middleware for cross-cutting concerns like authentication, caching, timeouts, and monitoring. Think Rack middleware, but for your business logic.</p> <p>See Global Configuration for framework-wide setup.</p>"},{"location":"middlewares/#execution-order","title":"Execution Order","text":"<p>Middleware wraps task execution in layers, like an onion:</p> <p>Note</p> <p>First registered = outermost wrapper. They execute in registration order.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  register :middleware, AuditMiddleware         # 1st: outermost wrapper\n  register :middleware, AuthorizationMiddleware # 2nd: middle wrapper\n  register :middleware, CacheMiddleware         # 3rd: innermost wrapper\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Execution flow:\n# 1. AuditMiddleware (before)\n# 2.   AuthorizationMiddleware (before)\n# 3.     CacheMiddleware (before)\n# 4.       [task execution]\n# 5.     CacheMiddleware (after)\n# 6.   AuthorizationMiddleware (after)\n# 7. AuditMiddleware (after)\n</code></pre>"},{"location":"middlewares/#declarations","title":"Declarations","text":""},{"location":"middlewares/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple middleware logic:</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Proc\n  register :middleware, proc do |task, options, &amp;block|\n    result = block.call\n    Analytics.track(result.status)\n    result\n  end\n\n  # Lambda\n  register :middleware, -&gt;(task, options, &amp;block) {\n    result = block.call\n    Analytics.track(result.status)\n    result\n  }\nend\n</code></pre>"},{"location":"middlewares/#class-or-module","title":"Class or Module","text":"<p>For complex middleware logic, use classes or modules:</p> <pre><code>class TelemetryMiddleware\n  def call(task, options)\n    result = yield\n    Telemetry.record(result.status)\n  ensure\n    result # Always return result\n  end\nend\n\nclass ProcessCampaign &lt; CMDx::Task\n  # Class or Module\n  register :middleware, TelemetryMiddleware\n\n  # Instance\n  register :middleware, TelemetryMiddleware.new\n\n  # With options\n  register :middleware, MonitoringMiddleware, service_key: ENV[\"MONITORING_KEY\"]\n  register :middleware, MonitoringMiddleware.new(ENV[\"MONITORING_KEY\"])\nend\n</code></pre>"},{"location":"middlewares/#removals","title":"Removals","text":"<p>Remove class or module-based middleware globally or per-task:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one middleware. Use multiple calls for batch removals.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Class or Module (no instances)\n  deregister :middleware, TelemetryMiddleware\nend\n</code></pre>"},{"location":"middlewares/#built-in","title":"Built-in","text":""},{"location":"middlewares/#timeout","title":"Timeout","text":"<p>Prevent tasks from running too long:</p> <pre><code>class ProcessReport &lt; CMDx::Task\n  # Default timeout: 3 seconds\n  register :middleware, CMDx::Middlewares::Timeout\n\n  # Seconds (takes Numeric, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, seconds: :max_processing_time\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, unless: -&gt; { self.class.name.include?(\"Quick\") }\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def max_processing_time\n    Rails.env.production? ? 2 : 10\n  end\nend\n\n# Slow task\nresult = ProcessReport.execute\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failure\"\nresult.reason   #=&gt; \"[CMDx::TimeoutError] execution exceeded 3 seconds\"\nresult.cause    #=&gt; &lt;CMDx::TimeoutError&gt;\nresult.metadata #=&gt; { limit: 3 }\n</code></pre>"},{"location":"middlewares/#correlate","title":"Correlate","text":"<p>Add correlation IDs for distributed tracing and request tracking:</p> <pre><code>class ProcessExport &lt; CMDx::Task\n  # Default correlation ID generation\n  register :middleware, CMDx::Middlewares::Correlate\n\n  # Seconds (takes Object, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, id: proc { |task| task.context.session_id }\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, if: :correlation_enabled?\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def correlation_enabled?\n    ENV[\"CORRELATION_ENABLED\"] == \"true\"\n  end\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { correlation_id: \"550e8400-e29b-41d4-a716-446655440000\" }\n</code></pre>"},{"location":"middlewares/#runtime","title":"Runtime","text":"<p>Track task execution time in milliseconds using a monotonic clock:</p> <pre><code>class PerformanceMonitoringCheck\n  def call(task)\n    task.context.tenant.monitoring_enabled?\n  end\nend\n\nclass ProcessExport &lt; CMDx::Task\n  # Default timeout is 3 seconds\n  register :middleware, CMDx::Middlewares::Runtime\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Runtime, if: PerformanceMonitoringCheck\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { runtime: 1247 } (ms)\n</code></pre>"},{"location":"retries/","title":"Retries","text":"<p>CMDx provides automatic retry functionality for tasks that encounter transient failures. This is essential for handling temporary issues like network timeouts, rate limits, or database locks without manual intervention.</p>"},{"location":"retries/#basic-usage","title":"Basic Usage","text":"<p>Configure retries upto n attempts without any delay.</p> <pre><code>class FetchExternalData &lt; CMDx::Task\n  settings retries: 3\n\n  def work\n    response = HTTParty.get(\"https://api.example.com/data\")\n    context.data = response.parsed_response\n  end\nend\n</code></pre> <p>When an exception occurs during execution, CMDx automatically retries up to the configured limit. Each retry attempt is logged at the <code>warn</code> level with retry metadata. If all retries are exhausted, the task fails with the original exception.</p>"},{"location":"retries/#selective-retries","title":"Selective Retries","text":"<p>By default, CMDx retries on <code>StandardError</code> and its subclasses. Narrow this to specific exception types:</p> <pre><code>class ProcessPayment &lt; CMDx::Task\n  settings retries: 5, retry_on: [Stripe::RateLimitError, Net::ReadTimeout]\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Important</p> <p>Only exceptions matching the <code>retry_on</code> configuration will trigger retries. Uncaught exceptions immediately fail the task.</p>"},{"location":"retries/#retry-jitter","title":"Retry Jitter","text":"<p>Add delays between retry attempts to avoid overwhelming external services or to implement exponential backoff strategies.</p>"},{"location":"retries/#fixed-value","title":"Fixed Value","text":"<p>Use a numeric value to calculate linear delay (<code>jitter * current_retry</code>):</p> <pre><code>class ImportRecords &lt; CMDx::Task\n  settings retries: 3, retry_jitter: 0.5\n\n  def work\n    # Delays: 0s, 0.5s (retry 1), 1.0s (retry 2), 1.5s (retry 3)\n    context.records = ExternalAPI.fetch_records\n  end\nend\n</code></pre>"},{"location":"retries/#symbol-references","title":"Symbol References","text":"<p>Define an instance method for custom delay logic:</p> <pre><code>class SyncInventory &lt; CMDx::Task\n  settings retries: 5, retry_jitter: :exponential_backoff\n\n  def work\n    context.inventory = InventoryAPI.sync\n  end\n\n  private\n\n  def exponential_backoff(current_retry)\n    2 ** current_retry # 2s, 4s, 8s, 16s, 32s\n  end\nend\n</code></pre>"},{"location":"retries/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Pass a proc for inline delay calculations:</p> <pre><code>class PollJobStatus &lt; CMDx::Task\n  # Proc\n  settings retries: 10, retry_jitter: proc { |retry_count| [retry_count * 0.5, 5.0].min }\n\n  # Lambda\n  settings retries: 10, retry_jitter: -&gt;(retry_count) { [retry_count * 0.5, 5.0].min }\n\n  def work\n    # Delays: 0.5s, 1.0s, 1.5s, 2.0s, 2.5s, 3.0s, 3.5s, 4.0s, 4.5s, 5.0s (capped)\n    context.status = JobAPI.check_status(context.job_id)\n  end\nend\n</code></pre>"},{"location":"retries/#class-or-module","title":"Class or Module","text":"<p>Implement reusable delay logic in dedicated modules and classes:</p> <pre><code>class ExponentialBackoff\n  def call(task, retry_count)\n    base_delay = task.context.base_delay || 1.0\n    [base_delay * (2 ** retry_count), 60.0].min\n  end\nend\n\nclass FetchUserProfile &lt; CMDx::Task\n  # Class or Module\n  settings retries: 4, retry_jitter: ExponentialBackoff\n\n  # Instance\n  settings retries: 4, retry_jitter: ExponentialBackoff.new\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/","title":"Tips and Tricks","text":"<p>Best practices, patterns, and techniques to build maintainable CMDx applications.</p>"},{"location":"tips_and_tricks/#project-organization","title":"Project Organization","text":""},{"location":"tips_and_tricks/#directory-structure","title":"Directory Structure","text":"<p>Create a well-organized command structure for maintainable applications:</p> <pre><code>/app/\n\u2514\u2500\u2500 /tasks/\n    \u251c\u2500\u2500 /invoices/\n    \u2502   \u251c\u2500\u2500 calculate_tax.rb\n    \u2502   \u251c\u2500\u2500 validate_invoice.rb\n    \u2502   \u251c\u2500\u2500 send_invoice.rb\n    \u2502   \u2514\u2500\u2500 process_invoice.rb # workflow\n    \u251c\u2500\u2500 /reports/\n    \u2502   \u251c\u2500\u2500 generate_pdf.rb\n    \u2502   \u251c\u2500\u2500 compile_data.rb\n    \u2502   \u251c\u2500\u2500 export_csv.rb\n    \u2502   \u2514\u2500\u2500 create_reports.rb # workflow\n    \u251c\u2500\u2500 application_task.rb # base class\n    \u251c\u2500\u2500 authenticate_session.rb\n    \u2514\u2500\u2500 activate_account.rb\n</code></pre>"},{"location":"tips_and_tricks/#naming-conventions","title":"Naming Conventions","text":"<p>Follow consistent naming patterns for clarity and maintainability:</p> <pre><code># Verb + Noun\nclass ExportData &lt; CMDx::Task; end\nclass CompressFile &lt; CMDx::Task; end\nclass ValidateSchema &lt; CMDx::Task; end\n\n# Use present tense verbs for actions\nclass GenerateToken &lt; CMDx::Task; end      # \u2713 Good\nclass GeneratingToken &lt; CMDx::Task; end    # \u274c Avoid\nclass TokenGeneration &lt; CMDx::Task; end    # \u274c Avoid\n</code></pre>"},{"location":"tips_and_tricks/#story-telling","title":"Story Telling","text":"<p>Break down complex logic into descriptive methods that read like a narrative:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    charge_payment_method\n    assign_to_warehouse\n    send_notification\n  end\n\n  private\n\n  def charge_payment_method\n    order.primary_payment_method.charge!\n  end\n\n  def assign_to_warehouse\n    order.ready_for_shipping!\n  end\n\n  def send_notification\n    if order.products_out_of_stock?\n      OrderMailer.pending(order).deliver\n    else\n      OrderMailer.preparing(order).deliver\n    end\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#style-guide","title":"Style Guide","text":"<p>Follow this order for consistent, readable tasks:</p> <pre><code>class ExportReport &lt; CMDx::Task\n\n  # 1. Register functions\n  register :middleware, CMDx::Middlewares::Correlate\n  register :validator, :format, FormatValidator\n\n  # 2. Define callbacks\n  before_execution :find_report\n  on_complete :track_export_metrics, if: -&gt;(task) { Current.tenant.analytics? }\n\n  # 3. Declare attributes\n  attributes :user_id\n  required :report_id\n  optional :format_type\n\n  # 4. Define work method\n  def work\n    report.compile!\n    report.export!\n\n    context.exported_at = Time.now\n  end\n\n  # TIP: Favor private business logic to reduce the surface of the public API.\n  private\n\n  # 5. Build helper functions\n  def find_report\n    @report ||= Report.find(report_id)\n  end\n\n  def track_export_metrics\n    Analytics.increment(:report_exported)\n  end\n\nend\n</code></pre>"},{"location":"tips_and_tricks/#attribute-options","title":"Attribute Options","text":"<p>Use <code>with_options</code> to reduce duplication:</p> <pre><code>class ConfigureCompany &lt; CMDx::Task\n  # Apply common options to multiple attributes\n  with_options(type: :string, presence: true) do\n    attributes :website, format: { with: URI::DEFAULT_PARSER.make_regexp(%w[http https]) }\n    required :company_name, :industry\n    optional :description, format: { with: /\\A[\\w\\s\\-\\.,!?]+\\z/ }\n  end\n\n  # Nested attributes with shared prefix\n  required :headquarters do\n    with_options(prefix: :hq_) do\n      attributes :street, :city, :zip_code, type: :string\n      required :country, type: :string, inclusion: { in: VALID_COUNTRIES }\n      optional :region, type: :string\n    end\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#useful-examples","title":"Useful Examples","text":"<ul> <li>Active Record Query Tagging</li> <li>Paper Trail Whatdunnit</li> <li>Sidekiq Async Execution</li> <li>Stoplight Circuit Breaker</li> </ul>"},{"location":"workflows/","title":"Workflows","text":"<p>Compose multiple tasks into powerful, sequential pipelines. Workflows provide a declarative way to build complex business processes with conditional execution, shared context, and flexible error handling.</p>"},{"location":"workflows/#declarations","title":"Declarations","text":"<p>Tasks run in declaration order (FIFO), sharing a common context across the pipeline.</p> <p>Warning</p> <p>Don't define a <code>work</code> method in workflows\u2014the module handles execution automatically.</p>"},{"location":"workflows/#task","title":"Task","text":"<pre><code>class OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateUserProfile\n  task SetupAccountPreferences\n\n  tasks SendWelcomeEmail, SendWelcomeSms, CreateDashboard\nend\n</code></pre> <p>Tip</p> <p>Execute tasks in parallel via the cmdx-parallel gem.</p>"},{"location":"workflows/#group","title":"Group","text":"<p>Group related tasks to share configuration:</p> <p>Important</p> <p>Settings and conditionals apply to all tasks in the group.</p> <pre><code>class ContentModerationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Screening phase\n  tasks ScanForProfanity, CheckForSpam, ValidateImages, breakpoints: [\"skipped\"]\n\n  # Review phase\n  tasks ApplyFilters, ScoreContent, FlagSuspicious\n\n  # Decision phase\n  tasks PublishContent, QueueForReview, NotifyModerators\nend\n</code></pre>"},{"location":"workflows/#conditionals","title":"Conditionals","text":"<p>Conditionals support multiple syntaxes for flexible execution control:</p> <pre><code>class ContentAccessCheck\n  def call(task)\n    task.context.user.can?(:publish_content)\n  end\nend\n\nclass OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # If and/or Unless\n  task SendWelcomeEmail, if: :email_configured?, unless: :email_disabled?\n\n  # Proc\n  task SendWelcomeEmail, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Premium\") }\n\n  # Lambda\n  task SendWelcomeEmail, if: proc { context.features_enabled? }\n\n  # Class or Module\n  task SendWelcomeEmail, unless: ContentAccessCheck\n\n  # Instance\n  task SendWelcomeEmail, if: ContentAccessCheck.new\n\n  # Conditional applies to all tasks of this declaration group\n  tasks SendWelcomeEmail, CreateDashboard, SetupTutorial, if: :email_configured?\n\n  private\n\n  def email_configured?\n    context.user.email_address == true\n  end\n\n  def email_disabled?\n    context.user.communication_preference == :disabled\n  end\nend\n</code></pre>"},{"location":"workflows/#halt-behavior","title":"Halt Behavior","text":"<p>By default, skipped tasks don't stop the workflow\u2014they're treated as no-ops. Configure breakpoints globally or per-task to customize this behavior.</p> <pre><code>class AnalyticsWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CollectMetrics      # If fails \u2192 workflow stops\n  task FilterOutliers      # If skipped \u2192 workflow continues\n  task GenerateDashboard   # Only runs if no failures occurred\nend\n</code></pre>"},{"location":"workflows/#task-configuration","title":"Task Configuration","text":"<p>Configure halt behavior for the entire workflow:</p> <pre><code>class SecurityWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Halt on both failed and skipped results\n  settings(workflow_breakpoints: [\"skipped\", \"failed\"])\n\n  task PerformSecurityScan\n  task ValidateSecurityRules\nend\n\nclass OptionalTasksWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Never halt, always continue\n  settings(breakpoints: [])\n\n  task TryBackupData\n  task TryCleanupLogs\n  task TryOptimizeCache\nend\n</code></pre>"},{"location":"workflows/#group-configuration","title":"Group Configuration","text":"<p>Different task groups can have different halt behavior:</p> <pre><code>class SubscriptionWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateSubscription, ValidatePayment, workflow_breakpoints: [\"skipped\", \"failed\"]\n\n  # Never halt, always continue\n  task SendConfirmationEmail, UpdateBilling, breakpoints: []\nend\n</code></pre>"},{"location":"workflows/#nested-workflows","title":"Nested Workflows","text":"<p>Build hierarchical workflows by composing workflows within workflows:</p> <pre><code>class EmailPreparationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateRecipients\n  task CompileTemplate\nend\n\nclass EmailDeliveryWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks SendEmails, TrackDeliveries\nend\n\nclass CompleteEmailWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task EmailPreparationWorkflow\n  task EmailDeliveryWorkflow, if: proc { context.preparation_successful? }\n  task GenerateDeliveryReport\nend\n</code></pre>"},{"location":"workflows/#parallel-execution","title":"Parallel Execution","text":"<p>Run tasks concurrently using the Parallel gem. It automatically uses all available processors for maximum throughput.</p> <p>Warning</p> <p>Context is read-only during parallel execution. Load all required data beforehand.</p> <pre><code>class SendWelcomeNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Default options (dynamically calculated to available processors)\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel\n\n  # Fix number of threads\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_threads: 2\n\n  # Fix number of forked processes\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_processes: 2\n\n  # NOTE: Reactors are not supported\nend\n</code></pre>"},{"location":"workflows/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx workflow tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:workflow SendNotifications\n</code></pre> <p>This creates a new workflow task file with the basic structure:</p> <pre><code># app/tasks/send_notifications.rb\nclass SendNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks Task1, Task2\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + pluralized noun for workflow task names, eg: <code>SendNotifications</code>, <code>DownloadFiles</code>, <code>ValidateDocuments</code></p>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the complete API reference documentation for CMDx, generated from YARD documentation.</p>"},{"location":"api/#main-module","title":"Main Module","text":"<ul> <li>CMDx - Main module and entry point</li> </ul>"},{"location":"api/#core-classes","title":"Core Classes","text":"<ul> <li>CMDx::Task - Base class for all tasks</li> <li>CMDx::Workflow - Workflow composition module</li> <li>CMDx::Result - Execution result object</li> <li>CMDx::Context - Context object for data sharing</li> <li>CMDx::Chain - Execution chain tracking</li> <li>CMDx::Executor - Task executor</li> <li>CMDx::Pipeline - Workflow pipeline executor</li> </ul>"},{"location":"api/#configuration","title":"Configuration","text":"<ul> <li>CMDx::Configuration - Global configuration</li> </ul>"},{"location":"api/#attributes","title":"Attributes","text":"<ul> <li>CMDx::Attribute - Attribute definition</li> <li>CMDx::AttributeValue - Attribute value handling</li> <li>CMDx::AttributeRegistry - Attribute registry</li> </ul>"},{"location":"api/#coercions","title":"Coercions","text":"<ul> <li>CMDx::Coercions - Coercion module</li> <li>CMDx::CoercionRegistry - Coercion registry</li> </ul> <p>See individual coercion classes in CMDx::Coercions for specific type conversions.</p>"},{"location":"api/#validators","title":"Validators","text":"<ul> <li>CMDx::Validators - Validator module</li> <li>CMDx::ValidatorRegistry - Validator registry</li> </ul> <p>See individual validator classes in CMDx::Validators for specific validation rules.</p>"},{"location":"api/#middlewares","title":"Middlewares","text":"<ul> <li>CMDx::Middlewares - Middleware module</li> <li>CMDx::MiddlewareRegistry - Middleware registry</li> </ul> <p>See individual middleware classes in CMDx::Middlewares for specific middleware implementations.</p>"},{"location":"api/#callbacks","title":"Callbacks","text":"<ul> <li>CMDx::CallbackRegistry - Callback registry</li> </ul>"},{"location":"api/#logging","title":"Logging","text":"<ul> <li>CMDx::LogFormatters - Log formatter module</li> </ul> <p>See individual formatter classes in CMDx::LogFormatters for specific log formats.</p>"},{"location":"api/#utilities","title":"Utilities","text":"<ul> <li>CMDx::Utils - Utility module</li> <li>CMDx::Locale - Internationalization support</li> <li>CMDx::Identifier - ID generation</li> <li>CMDx::Deprecator - Deprecation handling</li> </ul>"},{"location":"api/#errors-and-faults","title":"Errors and Faults","text":"<ul> <li>CMDx::Errors - Error collection</li> <li>CMDx::Fault - Base fault class</li> </ul>"},{"location":"api/CMDx/","title":"Module: CMDx","text":"<p>Extended by: CMDx</p>"},{"location":"api/CMDx/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/#configuration","title":"configuration()","text":"<p>Returns the global configuration instance, creating it if it doesn't exist. @return [Configuration] the global configuration instance</p> <p>@example <pre><code>config = CMDx.configuration\nconfig.middlewares # =&gt; #&lt;MiddlewareRegistry&gt;\n```## configure() [](#method-c-configure)\nConfigures CMDx using a block that receives the configuration instance.\n**@param** [Proc] the configuration block\n\n**@raise** [ArgumentError] when no block is provided\n\n**@return** [Configuration] the configured configuration instance\n\n**@yield** [Configuration] the configuration instance to configure\n\n\n**@example**\n```ruby\nCMDx.configure do |config|\n  config.task_breakpoints = [\"failed\", \"skipped\"]\n  config.logger.level = Logger::DEBUG\nend\n```## gem_path() [](#method-c-gem_path)\nReturns the path to the CMDx gem.\n**@return** [Pathname] the path to the CMDx gem\n\n\n**@example**\n```ruby\nCMDx.gem_path # =&gt; Pathname.new(\"/path/to/cmdx\")\n```## reset_configuration!() [](#method-c-reset_configuration!)\nResets the global configuration to a new instance with default values.\n**@return** [Configuration] the new configuration instance\n\n\n**@example**\n```ruby\nCMDx.reset_configuration!\n# Configuration is now reset to defaults\n</code></pre></p>"},{"location":"api/CMDx/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/#configuration_1","title":"configuration()","text":"<p>Returns the global configuration instance, creating it if it doesn't exist.</p> <p>@return [Configuration] the global configuration instance</p> <p>@example <pre><code>config = CMDx.configuration\nconfig.middlewares # =&gt; #&lt;MiddlewareRegistry&gt;\n```## configure() [](#method-i-configure)\nConfigures CMDx using a block that receives the configuration instance.\n\n**@param** [Proc] the configuration block\n\n**@raise** [ArgumentError] when no block is provided\n\n**@return** [Configuration] the configured configuration instance\n\n**@yield** [Configuration] the configuration instance to configure\n\n\n**@example**\n```ruby\nCMDx.configure do |config|\n  config.task_breakpoints = [\"failed\", \"skipped\"]\n  config.logger.level = Logger::DEBUG\nend\n```## gem_path() [](#method-i-gem_path)\nReturns the path to the CMDx gem.\n\n**@return** [Pathname] the path to the CMDx gem\n\n\n**@example**\n```ruby\nCMDx.gem_path # =&gt; Pathname.new(\"/path/to/cmdx\")\n```## reset_configuration!() [](#method-i-reset_configuration!)\nResets the global configuration to a new instance with default values.\n\n**@return** [Configuration] the new configuration instance\n\n\n**@example**\n```ruby\nCMDx.reset_configuration!\n# Configuration is now reset to defaults\n</code></pre></p>"},{"location":"api/Cmdx_/","title":"Module: Cmdx","text":""},{"location":"api/CMDx/Attribute/","title":"Class: CMDx::Attribute","text":"<p>Inherits: Object</p> <p>Represents a configurable attribute within a CMDx task. Attributes define the data structure and validation rules for task parameters. They can be nested to create complex hierarchical data structures.</p>"},{"location":"api/CMDx/Attribute/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Attribute/#buildnames-options","title":"build(names , *options )","text":"<p>Builds multiple attributes with the same configuration. @param [Array] The names of the attributes to create <p>@param [Hash] Configuration options for the attributes</p> <p>@raise [ArgumentError] When no names are provided or :as is used with multiple attributes</p> <p>@return [Array] Array of created attributes <p>@yield [self] Block to configure nested attributes</p> <p>@example <pre><code>Attribute.build(:first_name, :last_name, required: true, types: String)\n```## optional(*names , **options ) [](#method-c-optional)\nCreates optional attributes (not required).\n**@param** [Array&lt;Symbol, String&gt;] The names of the attributes to create\n\n**@param** [Hash] Configuration options for the attributes\n\n**@return** [Array&lt;Attribute&gt;] Array of created optional attributes\n\n**@yield** [self] Block to configure nested attributes\n\n\n**@example**\n```ruby\nAttribute.optional(:description, :tags, types: String)\n```## required(*names , **options ) [](#method-c-required)\nCreates required attributes.\n**@param** [Array&lt;Symbol, String&gt;] The names of the attributes to create\n\n**@param** [Hash] Configuration options for the attributes\n\n**@return** [Array&lt;Attribute&gt;] Array of created required attributes\n\n**@yield** [self] Block to configure nested attributes\n\n\n**@example**\n```ruby\nAttribute.required(:id, :name, types: [Integer, String])\n```# Attributes\n## children[RW] [](#attribute-i-children)\nReturns the child attributes for nested structures.\n\n**@return** [Array&lt;Attribute&gt;] Array of child attributes\n\n\n**@example**\n```ruby\nattribute.children # =&gt; [#&lt;Attribute @name=:street&gt;, #&lt;Attribute @name=:city&gt;]\n```## name[RW] [](#attribute-i-name)\nReturns the name of this attribute.\n\n**@return** [Symbol] The attribute name\n\n\n**@example**\n```ruby\nattribute.name # =&gt; :user_id\n```## options[RW] [](#attribute-i-options)\nReturns the configuration options for this attribute.\n\n**@return** [Hash{Symbol =&gt; Object}] Configuration options hash\n\n\n**@example**\n```ruby\nattribute.options # =&gt; { required: true, default: 0 }\n```## parent[RW] [](#attribute-i-parent)\nReturns the parent attribute if this is a nested attribute.\n\n**@return** [Attribute, nil] The parent attribute, or nil if root-level\n\n\n**@example**\n```ruby\nattribute.parent # =&gt; #&lt;Attribute @name=:address&gt;\n```## task[RW] [](#attribute-i-task)\nReturns the task instance associated with this attribute.\n\n**@return** [CMDx::Task] The task instance\n\n\n**@example**\n```ruby\nattribute.task.context[:user_id] # =&gt; 42\n```## types[RW] [](#attribute-i-types)\nReturns the expected type(s) for this attribute's value.\n\n**@return** [Array&lt;Class&gt;] Array of expected type classes\n\n\n**@example**\n```ruby\nattribute.types # =&gt; [Integer, String]\n</code></pre></p>"},{"location":"api/CMDx/Attribute/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Attribute/#define_and_verify_tree","title":"define_and_verify_tree()","text":"<p>Defines and verifies the entire attribute tree including nested children.</p>"},{"location":"api/CMDx/Attribute/#initializename-options","title":"initialize(name, options{})","text":"<p>Creates a new attribute with the specified name and configuration.</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Symbol, String] The name of the attribute</p> <p>@param [Hash] Configuration options for the attribute</p> <p>@return [Attribute] a new instance of Attribute</p> <p>@yield [self] Block to configure nested attributes</p> <p>@example <pre><code>Attribute.new(:user_id, required: true, types: [Integer, String]) do\n  required :name, types: String\n  optional :email, types: String\nend\n```## method_name() [](#method-i-method_name)\nGenerates the method name for accessing this attribute.\n\n**@return** [Symbol] The method name for the attribute\n\n\n**@example**\n```ruby\nattribute.method_name # =&gt; :user_name\n```## required?() [](#method-i-required?)\nChecks if the attribute is required.\n\n**@return** [Boolean] true if the attribute is required, false otherwise\n\n\n**@example**\n```ruby\nattribute.required? # =&gt; true\n```## source() [](#method-i-source)\nDetermines the source of the attribute value.\n\n**@return** [Symbol] The source identifier for the attribute value\n\n\n**@example**\n```ruby\nattribute.source # =&gt; :context\n</code></pre></p>"},{"location":"api/CMDx/AttributeRegistry/","title":"Class: CMDx::AttributeRegistry","text":"<p>Inherits: Object</p> <p>Manages a collection of attributes for task definition and verification. The registry provides methods to register, deregister, and process attributes in a hierarchical structure, supporting nested attribute definitions.</p>"},{"location":"api/CMDx/AttributeRegistry/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/AttributeRegistry/#registryrw","title":"registry[RW]","text":"<p>Returns the collection of registered attributes.</p> <p>@return [Array] Array of registered attributes <p>@example <pre><code>registry.registry # =&gt; [#&lt;Attribute @name=:name&gt;, #&lt;Attribute @name=:email&gt;]\n</code></pre></p>"},{"location":"api/CMDx/AttributeRegistry/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/AttributeRegistry/#define_and_verifytask","title":"define_and_verify(task)","text":"<p>Associates all registered attributes with a task and verifies their definitions. This method is called during task setup to establish attribute-task relationships and validate the attribute hierarchy.</p> <p>@param [Task] The task to associate with all attributes</p>"},{"location":"api/CMDx/AttributeRegistry/#deregisternames","title":"deregister(names)","text":"<p>Removes attributes from the registry by name. Supports hierarchical attribute removal by matching the entire attribute tree.</p> <p>@param [Symbol, String, Array] Name(s) of attributes to remove <p>@return [AttributeRegistry] Self for method chaining</p> <p>@example <pre><code>registry.deregister(:name)\nregistry.deregister(['name1', 'name2'])\n```## dup() [](#method-i-dup)\nCreates a duplicate of this registry with copied attributes.\n\n**@return** [AttributeRegistry] A new registry with duplicated attributes\n\n\n**@example**\n```ruby\nnew_registry = registry.dup\n```## initialize(registry[]) [](#method-i-initialize)\nCreates a new attribute registry with an optional initial collection.\n\n**@param** [Array&lt;Attribute&gt;] Initial attributes to register\n\n**@return** [AttributeRegistry] A new registry instance\n\n\n**@example**\n```ruby\nregistry = AttributeRegistry.new\nregistry = AttributeRegistry.new([attr1, attr2])\n```## register(attributes) [](#method-i-register)\nRegisters one or more attributes to the registry.\n\n**@param** [Attribute, Array&lt;Attribute&gt;] Attribute(s) to register\n\n**@return** [AttributeRegistry] Self for method chaining\n\n\n**@example**\n```ruby\nregistry.register(attribute)\nregistry.register([attr1, attr2])\n</code></pre></p>"},{"location":"api/CMDx/AttributeValue/","title":"Class: CMDx::AttributeValue","text":"<p>Inherits: Object</p> <p>Extended by: Forwardable</p> <p>Manages the value lifecycle for a single attribute within a task. Handles value sourcing, derivation, coercion, and validation through a coordinated pipeline that ensures data integrity and type safety.</p>"},{"location":"api/CMDx/AttributeValue/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/AttributeValue/#attributerw","title":"attribute[RW]","text":"<p>Returns the attribute managed by this value handler.</p> <p>@return [Attribute] The attribute instance</p> <p>@example <pre><code>attr_value.attribute.name # =&gt; :user_id\n</code></pre></p>"},{"location":"api/CMDx/AttributeValue/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/AttributeValue/#generate","title":"generate()","text":"<p>Generates the attribute value through the complete pipeline: sourcing, derivation, coercion, and storage.</p> <p>@return [Object, nil] The generated value or nil if generation failed</p> <p>@example <pre><code>attr_value.generate # =&gt; 42\n```## initialize(attribute) [](#method-i-initialize)\nCreates a new attribute value manager for the given attribute.\n\n**@param** [Attribute] The attribute to manage values for\n\n**@return** [AttributeValue] a new instance of AttributeValue\n\n\n**@example**\n```ruby\nattr = Attribute.new(:user_id, required: true)\nattr_value = AttributeValue.new(attr)\n```## validate() [](#method-i-validate)\nValidates the current attribute value against configured validators.\n\n**@raise** [ValidationError] When validation fails (handled internally)\n\n\n**@example**\n```ruby\nattr_value.validate\n# Validates value against :presence, :format, etc.\n```## value() [](#method-i-value)\nRetrieves the current value for this attribute from the task's attributes.\n\n**@return** [Object, nil] The current attribute value or nil if not set\n\n\n**@example**\n```ruby\nattr_value.value # =&gt; \"john_doe\"\n</code></pre></p>"},{"location":"api/CMDx/CallbackRegistry/","title":"Class: CMDx::CallbackRegistry","text":"<p>Inherits: Object</p> <p>Registry for managing callbacks that can be executed at various points during task execution.</p> <p>Callbacks are organized by type and can be registered with optional conditions and options. Each callback type represents a specific execution phase or outcome.</p>"},{"location":"api/CMDx/CallbackRegistry/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/CallbackRegistry/#registryrw","title":"registry[RW]","text":"<p>Returns the internal registry of callbacks organized by type.</p> <p>@return [Hash{Symbol =&gt; Set}] Hash mapping callback types to their registered callables <p>@example <pre><code>registry.registry # =&gt; { before_execution: #&lt;Set: [[[:validate], {}]]&gt; }\n</code></pre></p>"},{"location":"api/CMDx/CallbackRegistry/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/CallbackRegistry/#deregistertype-callables-options-block","title":"deregister(type, callables, *options, &amp;block)","text":"<p>Removes one or more callables for a specific callback type</p> <p>@param [Symbol] The callback type from TYPES</p> <p>@param [Array&lt;#call&gt;] Callable objects to remove</p> <p>@param [Hash] Options that were used during registration</p> <p>@param [Proc] Optional block to remove</p> <p>@return [CallbackRegistry] self for method chaining</p> <p>@example <pre><code>registry.deregister(:before_execution, :validate_inputs)\n```## dup() [](#method-i-dup)\nCreates a deep copy of the registry with duplicated callable sets\n\n**@return** [CallbackRegistry] A new instance with duplicated registry contents\n\n## initialize(registry{}) [](#method-i-initialize)\n\n**@param** [Hash] Initial registry hash, defaults to empty\n\n**@return** [CallbackRegistry] a new instance of CallbackRegistry\n\n## invoke(type, task) [](#method-i-invoke)\nInvokes all registered callbacks for a given type\n\n**@param** [Symbol] The callback type to invoke\n\n**@param** [Task] The task instance to pass to callbacks\n\n**@raise** [TypeError] When type is not a valid callback type\n\n\n**@example**\n```ruby\nregistry.invoke(:before_execution, task)\n```## register(type, *callables, **options, &amp;block) [](#method-i-register)\nRegisters one or more callables for a specific callback type\n\n**@option** [] \n\n**@option** [] \n\n**@param** [Symbol] The callback type from TYPES\n\n**@param** [Array&lt;#call&gt;] Callable objects to register\n\n**@param** [Hash] Options to pass to the callback\n\n**@param** [Proc] Optional block to register as a callable\n\n**@raise** [ArgumentError] When type is not a valid callback type\n\n**@return** [CallbackRegistry] self for method chaining\n\n\n**@example**\n```ruby\nregistry.register(:before_execution, :validate_inputs)\n</code></pre> @example <pre><code>registry.register(:on_success, if: { status: :completed }) do |task|\n  task.log(\"Success callback executed\")\nend\n</code></pre></p>"},{"location":"api/CMDx/Chain/","title":"Class: CMDx::Chain","text":"<p>Inherits: Object</p> <p>Extended by: Forwardable</p> <p>Manages a collection of task execution results in a thread-safe manner. Chains provide a way to track related task executions and their outcomes within the same execution context.</p>"},{"location":"api/CMDx/Chain/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Chain/#buildresult","title":"build(result )","text":"<p>Builds or extends the current chain by adding a result. Creates a new chain if none exists, otherwise appends to the current one. @param [Result] The task execution result to add</p> <p>@raise [TypeError] If result is not a CMDx::Result instance</p> <p>@return [Chain] The current chain (newly created or existing)</p> <p>@example <pre><code>result = task.execute\nchain = Chain.build(result)\nputs \"Chain size: #{chain.size}\"\n```## clear() [](#method-c-clear)\nClears the current chain for the current thread.\n**@return** [nil] Always returns nil\n\n\n**@example**\n```ruby\nChain.clear\n```## current() [](#method-c-current)\nRetrieves the current chain for the current thread.\n**@return** [Chain, nil] The current chain or nil if none exists\n\n\n**@example**\n```ruby\nchain = Chain.current\nif chain\n  puts \"Current chain: #{chain.id}\"\nend\n```## current=(chain ) [](#method-c-current=)\nSets the current chain for the current thread.\n**@param** [Chain] The chain to set as current\n\n**@return** [Chain] The set chain\n\n\n**@example**\n```ruby\nChain.current = my_chain\n```# Attributes\n## id[RW] [](#attribute-i-id)\nReturns the unique identifier for this chain.\n\n**@return** [String] The chain identifier\n\n\n**@example**\n```ruby\nchain.id # =&gt; \"abc123xyz\"\n```## results[RW] [](#attribute-i-results)\nReturns the collection of execution results in this chain.\n\n**@return** [Array&lt;Result&gt;] Array of task results\n\n\n**@example**\n```ruby\nchain.results # =&gt; [#&lt;Result&gt;, #&lt;Result&gt;]\n</code></pre></p>"},{"location":"api/CMDx/Chain/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Chain/#initialize","title":"initialize()","text":"<p>Creates a new chain with a unique identifier and empty results collection.</p> <p>@return [Chain] A new chain instance</p>"},{"location":"api/CMDx/Chain/#to_h","title":"to_h()","text":"<p>Converts the chain to a hash representation.</p> <p>@option [] </p> <p>@option [] </p> <p>@param [Hash] a customizable set of options</p> <p>@return [Hash] Hash containing chain id and serialized results</p> <p>@example <pre><code>chain_hash = chain.to_h\nputs chain_hash[:id]\nputs chain_hash[:results].size\n```## to_s() [](#method-i-to_s)\nConverts the chain to a string representation.\n\n**@return** [String] Formatted string representation of the chain\n\n\n**@example**\n```ruby\nputs chain.to_s\n</code></pre></p>"},{"location":"api/CMDx/CoercionRegistry/","title":"Class: CMDx::CoercionRegistry","text":"<p>Inherits: Object</p> <p>Registry for managing type coercion handlers.</p> <p>Provides a centralized way to register, deregister, and execute type coercions for various data types including arrays, numbers, dates, and other primitives.</p>"},{"location":"api/CMDx/CoercionRegistry/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/CoercionRegistry/#registryrw","title":"registry[RW]","text":"<p>Returns the internal registry mapping coercion types to handler classes.</p> <p>@return [Hash{Symbol =&gt; Class}] Hash of coercion type names to coercion classes</p> <p>@example <pre><code>registry.registry # =&gt; { integer: Coercions::Integer, boolean: Coercions::Boolean }\n</code></pre></p>"},{"location":"api/CMDx/CoercionRegistry/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/CoercionRegistry/#coercetype-task-value-options","title":"coerce(type, task, value, options{})","text":"<p>Coerce a value to the specified type using the registered handler.</p> <p>@param [Symbol] the type to coerce to</p> <p>@param [Object] the task context for the coercion</p> <p>@param [Object] the value to coerce</p> <p>@param [Hash] additional options for the coercion</p> <p>@raise [TypeError] when the type is not registered</p> <p>@return [Object] the coerced value</p> <p>@example <pre><code>result = registry.coerce(:integer, task, \"42\")\nresult = registry.coerce(:boolean, task, \"true\", strict: true)\n```## deregister(name) [](#method-i-deregister)\nRemove a coercion handler for a type.\n\n**@param** [Symbol, String] the type name to deregister\n\n**@return** [CoercionRegistry] self for method chaining\n\n\n**@example**\n```ruby\nregistry.deregister(:custom_type)\nregistry.deregister(\"another_type\")\n```## dup() [](#method-i-dup)\nCreate a duplicate of this registry.\n\n**@return** [CoercionRegistry] a new instance with duplicated registry hash\n\n\n**@example**\n```ruby\nnew_registry = registry.dup\n```## initialize(registrynil) [](#method-i-initialize)\nInitialize a new coercion registry.\n\n**@param** [Hash&lt;Symbol, Class&gt;, nil] optional initial registry hash\n\n**@return** [CoercionRegistry] a new instance of CoercionRegistry\n\n\n**@example**\n```ruby\nregistry = CoercionRegistry.new\nregistry = CoercionRegistry.new(custom: CustomCoercion)\n```## register(name, coercion) [](#method-i-register)\nRegister a new coercion handler for a type.\n\n**@param** [Symbol, String] the type name to register\n\n**@param** [Class] the coercion class to handle this type\n\n**@return** [CoercionRegistry] self for method chaining\n\n\n**@example**\n```ruby\nregistry.register(:custom_type, CustomCoercion)\nregistry.register(\"another_type\", AnotherCoercion)\n</code></pre></p>"},{"location":"api/CMDx/Coercions/","title":"Module: CMDx::Coercions","text":""},{"location":"api/CMDx/Configuration/","title":"Class: CMDx::Configuration","text":"<p>Inherits: Object</p> <p>Configuration class that manages global settings for CMDx including middlewares, callbacks, coercions, validators, breakpoints, backtraces, and logging.</p>"},{"location":"api/CMDx/Configuration/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/Configuration/#backtracerw","title":"backtrace[RW]","text":"<p>Returns whether to log backtraces for failed tasks.</p> <p>@return [Boolean] true if backtraces should be logged</p> <p>@example <pre><code>config.backtrace = true\n```## backtrace_cleaner[RW] [](#attribute-i-backtrace_cleaner)\nReturns the proc used to clean backtraces before logging.\n\n**@return** [Proc, nil] The backtrace cleaner proc, or nil if not set\n\n\n**@example**\n```ruby\nconfig.backtrace_cleaner = -&gt;(bt) { bt.first(5) }\n```## callbacks[RW] [](#attribute-i-callbacks)\nReturns the callback registry for task lifecycle hooks.\n\n**@return** [CallbackRegistry] The callback registry\n\n\n**@example**\n```ruby\nconfig.callbacks.register(:before_execution, :log_start)\n```## coercions[RW] [](#attribute-i-coercions)\nReturns the coercion registry for type conversions.\n\n**@return** [CoercionRegistry] The coercion registry\n\n\n**@example**\n```ruby\nconfig.coercions.register(:custom, CustomCoercion)\n```## exception_handler[RW] [](#attribute-i-exception_handler)\nReturns the proc called when exceptions occur during execution.\n\n**@return** [Proc, nil] The exception handler proc, or nil if not set\n\n\n**@example**\n```ruby\nconfig.exception_handler = -&gt;(task, error) { Sentry.capture_exception(error) }\n```## logger[RW] [](#attribute-i-logger)\nReturns the logger instance for CMDx operations.\n\n**@return** [Logger] The logger instance\n\n\n**@example**\n```ruby\nconfig.logger.level = Logger::DEBUG\n```## middlewares[RW] [](#attribute-i-middlewares)\nReturns the middleware registry for task execution.\n\n**@return** [MiddlewareRegistry] The middleware registry\n\n\n**@example**\n```ruby\nconfig.middlewares.register(CustomMiddleware)\n```## rollback_on[RW] [](#attribute-i-rollback_on)\nReturns the statuses that trigger a task execution rollback.\n\n**@return** [Array&lt;String&gt;] Array of status names that trigger rollback\n\n\n**@example**\n```ruby\nconfig.rollback_on = [\"failed\", \"skipped\"]\n```## task_breakpoints[RW] [](#attribute-i-task_breakpoints)\nReturns the breakpoint statuses for task execution interruption.\n\n**@return** [Array&lt;String&gt;] Array of status names that trigger breakpoints\n\n\n**@example**\n```ruby\nconfig.task_breakpoints = [\"failed\", \"skipped\"]\n```## validators[RW] [](#attribute-i-validators)\nReturns the validator registry for attribute validation.\n\n**@return** [ValidatorRegistry] The validator registry\n\n\n**@example**\n```ruby\nconfig.validators.register(:email, EmailValidator)\n```## workflow_breakpoints[RW] [](#attribute-i-workflow_breakpoints)\nReturns the breakpoint statuses for workflow execution interruption.\n\n**@return** [Array&lt;String&gt;] Array of status names that trigger breakpoints\n\n\n**@example**\n```ruby\nconfig.workflow_breakpoints = [\"failed\", \"skipped\"]\n</code></pre></p>"},{"location":"api/CMDx/Configuration/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Configuration/#initialize","title":"initialize()","text":"<p>Initializes a new Configuration instance with default values.</p> <p>Creates new registry instances for middlewares, callbacks, coercions, and validators. Sets default breakpoints and configures a basic logger.</p> <p>@return [Configuration] a new Configuration instance</p> <p>@example <pre><code>config = Configuration.new\nconfig.middlewares.class # =&gt; MiddlewareRegistry\nconfig.task_breakpoints # =&gt; [\"failed\"]\n```## to_h() [](#method-i-to_h)\nConverts the configuration to a hash representation.\n\n**@return** [Hash&lt;Symbol, Object&gt;] hash containing all configuration values\n\n\n**@example**\n```ruby\nconfig = Configuration.new\nconfig.to_h\n# =&gt; { middlewares: #&lt;MiddlewareRegistry&gt;, callbacks: #&lt;CallbackRegistry&gt;, ... }\n</code></pre></p>"},{"location":"api/CMDx/Context/","title":"Class: CMDx::Context","text":"<p>Inherits: Object</p> <p>Extended by: Forwardable</p> <p>A hash-like context object that provides a flexible way to store and access key-value pairs during task execution. Keys are automatically converted to symbols for consistency.</p> <p>The Context class extends Forwardable to delegate common hash methods and provides additional convenience methods for working with context data.</p>"},{"location":"api/CMDx/Context/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Context/#buildcontext","title":"build(context {})","text":"<p>Builds a Context instance, reusing existing unfrozen contexts when possible. @option [] </p> <p>@param [Context, Object] the context to build from</p> <p>@return [Context] a Context instance, either new or reused</p> <p>@example <pre><code>existing = Context.new(name: \"John\")\nbuilt = Context.build(existing) # reuses existing context\nbuilt.object_id == existing.object_id # =&gt; true\n```# Attributes\n## table[RW] [](#attribute-i-table)\nReturns the internal hash storing context data.\n\n**@return** [Hash{Symbol =&gt; Object}] The internal hash table\n\n\n**@example**\n```ruby\ncontext.table # =&gt; { name: \"John\", age: 30 }\n</code></pre></p>"},{"location":"api/CMDx/Context/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Context/#_1","title":"","text":"<p>Retrieves a value from the context by key.</p> <p>@param [String, Symbol] the key to retrieve</p> <p>@return [Object, nil] the value associated with the key, or nil if not found</p> <p>@example <pre><code>context = Context.new(name: \"John\")\ncontext[:name] # =&gt; \"John\"\ncontext[\"name\"] # =&gt; \"John\" (automatically converted to symbol)\n```## delete!(key) [](#method-i-delete!)\nDeletes a key-value pair from the context.\n\n**@param** [String, Symbol] the key to delete\n\n**@return** [Object, nil] the deleted value, or the block result if key not found\n\n**@yield** [key] a block to handle the case when key is not found\n\n\n**@example**\n```ruby\ncontext = Context.new(name: \"John\", age: 30)\ncontext.delete!(:age) # =&gt; 30\ncontext.delete!(:city) { |key| \"Key #{key} not found\" } # =&gt; \"Key city not found\"\n```## dig(key, *keys) [](#method-i-dig)\nDigs into nested structures using the given keys.\n\n**@param** [String, Symbol] the first key to dig with\n\n**@param** [Array&lt;String, Symbol&gt;] additional keys for deeper digging\n\n**@return** [Object, nil] the value found by digging, or nil if not found\n\n\n**@example**\n```ruby\ncontext = Context.new(user: {profile: {name: \"John\"}})\ncontext.dig(:user, :profile, :name) # =&gt; \"John\"\ncontext.dig(:user, :profile, :age) # =&gt; nil\n```## eql?(other) [](#method-i-eql?)\nCompares this context with another object for equality.\n\n**@param** [Object] the object to compare with\n\n**@return** [Boolean] true if other is a Context with the same data\n\n\n**@example**\n```ruby\ncontext1 = Context.new(name: \"John\")\ncontext2 = Context.new(name: \"John\")\ncontext1 == context2 # =&gt; true\n```## fetch(key) [](#method-i-fetch)\nFetches a value from the context by key, with optional default value.\n\n**@param** [String, Symbol] the key to fetch\n\n**@param** [Object] the default value if key is not found\n\n**@return** [Object] the value associated with the key, or the default/default block result\n\n**@yield** [key] a block to compute the default value\n\n\n**@example**\n```ruby\ncontext = Context.new(name: \"John\")\ncontext.fetch(:name) # =&gt; \"John\"\ncontext.fetch(:age, 25) # =&gt; 25\ncontext.fetch(:city) { |key| \"Unknown #{key}\" } # =&gt; \"Unknown city\"\n```## fetch_or_store(key, valuenil) [](#method-i-fetch_or_store)\nFetches a value from the context by key, or stores and returns a default value\nif not found.\n\n**@param** [String, Symbol] the key to fetch or store\n\n**@param** [Object] the default value to store if key is not found\n\n**@return** [Object] the existing value if key is found, otherwise the stored default value\n\n**@yield** [key] a block to compute the default value to store\n\n\n**@example**\n```ruby\ncontext = Context.new(name: \"John\")\ncontext.fetch_or_store(:name, \"Default\") # =&gt; \"John\" (existing value)\ncontext.fetch_or_store(:age, 25) # =&gt; 25 (stored and returned)\ncontext.fetch_or_store(:city) { |key| \"Unknown #{key}\" } # =&gt; \"Unknown city\" (stored and returned)\n```## initialize(args{}) [](#method-i-initialize)\nCreates a new Context instance from the given arguments.\n\n**@option** [] \n\n**@param** [Hash, Object] arguments to initialize the context with\n\n**@raise** [ArgumentError] when args doesn't respond to `to_h` or `to_hash`\n\n**@return** [Context] a new Context instance\n\n\n**@example**\n```ruby\ncontext = Context.new(name: \"John\", age: 30)\ncontext[:name] # =&gt; \"John\"\n```## key?(key) [](#method-i-key?)\nChecks if the context contains a specific key.\n\n**@param** [String, Symbol] the key to check\n\n**@return** [Boolean] true if the key exists in the context\n\n\n**@example**\n```ruby\ncontext = Context.new(name: \"John\")\ncontext.key?(:name) # =&gt; true\ncontext.key?(:age) # =&gt; false\n```## merge!(args{}) [](#method-i-merge!)\nMerges the given arguments into the current context, modifying it in place.\n\n**@option** [] \n\n**@param** [Hash, Object] arguments to merge into the context\n\n**@return** [Context] self for method chaining\n\n\n**@example**\n```ruby\ncontext = Context.new(name: \"John\")\ncontext.merge!(age: 30, city: \"NYC\")\ncontext.to_h # =&gt; {name: \"John\", age: 30, city: \"NYC\"}\n```## store(key, value) [](#method-i-store)\nStores a key-value pair in the context.\n\n**@param** [String, Symbol] the key to store\n\n**@param** [Object] the value to store\n\n**@return** [Object] the stored value\n\n\n**@example**\n```ruby\ncontext = Context.new\ncontext.store(:name, \"John\")\ncontext[:name] # =&gt; \"John\"\n```## to_s() [](#method-i-to_s)\nConverts the context to a string representation.\n\n**@return** [String] a formatted string representation of the context data\n\n\n**@example**\n```ruby\ncontext = Context.new(name: \"John\", age: 30)\ncontext.to_s # =&gt; \"name: John, age: 30\"\n</code></pre></p>"},{"location":"api/CMDx/Deprecator/","title":"Module: CMDx::Deprecator","text":"<p>Extended by: CMDx::Deprecator</p> <p>Handles deprecation warnings and restrictions for tasks.</p> <p>The Deprecator module provides functionality to restrict usage of deprecated tasks based on configuration settings. It supports different deprecation behaviors including warnings, logging, and errors.</p>"},{"location":"api/CMDx/Deprecator/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Deprecator/#restricttask","title":"restrict(task )","text":"<p>Restricts task usage based on deprecation settings. @option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Object] The task object to check for deprecation</p> <p>@param [Hash] a customizable set of options</p> <p>@raise [DeprecationError] When deprecation type is :raise or true</p> <p>@raise [RuntimeError] When deprecation type is unknown</p> <p>@example <pre><code>class MyTask\n  settings(deprecate: :warn)\nend\n\nMyTask.new # =&gt; [MyTask] DEPRECATED: migrate to a replacement or discontinue use\n</code></pre></p>"},{"location":"api/CMDx/Deprecator/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Deprecator/#restricttask_1","title":"restrict(task)","text":"<p>Restricts task usage based on deprecation settings.</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Object] The task object to check for deprecation</p> <p>@param [Hash] a customizable set of options</p> <p>@raise [DeprecationError] When deprecation type is :raise or true</p> <p>@raise [RuntimeError] When deprecation type is unknown</p> <p>@example <pre><code>class MyTask\n  settings(deprecate: :warn)\nend\n\nMyTask.new # =&gt; [MyTask] DEPRECATED: migrate to a replacement or discontinue use\n</code></pre></p>"},{"location":"api/CMDx/Errors/","title":"Class: CMDx::Errors","text":"<p>Inherits: Object</p> <p>Extended by: Forwardable</p> <p>Collection of validation and execution errors organized by attribute. Provides methods to add, query, and format error messages for different attributes in a task or workflow execution.</p>"},{"location":"api/CMDx/Errors/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/Errors/#messagesrw","title":"messages[RW]","text":"<p>Returns the internal hash of error messages by attribute.</p> <p>@return [Hash{Symbol =&gt; Set}] Hash mapping attribute names to error message sets <p>@example <pre><code>errors.messages # =&gt; { email: #&lt;Set: [\"must be valid\", \"is required\"]&gt; }\n</code></pre></p>"},{"location":"api/CMDx/Errors/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Errors/#addattribute-message","title":"add(attribute, message)","text":"<p>Add an error message for a specific attribute.</p> <p>@param [Symbol] The attribute name associated with the error</p> <p>@param [String] The error message to add</p> <p>@example <pre><code>errors = CMDx::Errors.new\nerrors.add(:email, \"must be valid format\")\nerrors.add(:email, \"cannot be blank\")\n```## for?(attribute) [](#method-i-for?)\nCheck if there are any errors for a specific attribute.\n\n**@param** [Symbol] The attribute name to check for errors\n\n**@return** [Boolean] true if the attribute has errors, false otherwise\n\n\n**@example**\n```ruby\nerrors.for?(:email) # =&gt; true\nerrors.for?(:name)  # =&gt; false\n```## full_messages() [](#method-i-full_messages)\nConvert errors to a hash format with arrays of full messages.\n\n**@return** [Hash{Symbol =&gt; Array&lt;String&gt;}] Hash with attribute keys and message arrays\n\n\n**@example**\n```ruby\nerrors.full_messages # =&gt; { email: [\"email must be valid format\", \"email cannot be blank\"] }\n```## initialize() [](#method-i-initialize)\nInitialize a new error collection.\n\n**@return** [Errors] a new instance of Errors\n\n## to_h() [](#method-i-to_h)\nConvert errors to a hash format with arrays of messages.\n\n**@return** [Hash{Symbol =&gt; Array&lt;String&gt;}] Hash with attribute keys and message arrays\n\n\n**@example**\n```ruby\nerrors.to_h # =&gt; { email: [\"must be valid format\", \"cannot be blank\"] }\n```## to_hash(fullfalse) [](#method-i-to_hash)\nConvert errors to a hash format with optional full messages.\n\n**@param** [Boolean] Whether to include full messages with attribute names\n\n**@return** [Hash{Symbol =&gt; Array&lt;String&gt;}] Hash with attribute keys and message arrays\n\n\n**@example**\n```ruby\nerrors.to_hash # =&gt; { email: [\"must be valid format\", \"cannot be blank\"] }\nerrors.to_hash(true) # =&gt; { email: [\"email must be valid format\", \"email cannot be blank\"] }\n```## to_s() [](#method-i-to_s)\nConvert errors to a human-readable string format.\n\n**@return** [String] Formatted error messages joined with periods\n\n\n**@example**\n```ruby\nerrors.to_s # =&gt; \"email must be valid format. email cannot be blank\"\n</code></pre></p>"},{"location":"api/CMDx/Executor/","title":"Class: CMDx::Executor","text":"<p>Inherits: Object</p> <p>Executes CMDx tasks with middleware support, error handling, and lifecycle management.</p> <p>The Executor class is responsible for orchestrating task execution, including pre-execution validation, execution with middleware, post-execution callbacks, and proper error handling for different types of failures.</p>"},{"location":"api/CMDx/Executor/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Executor/#executetask-raise-false","title":"execute(task , raise: false)","text":"<p>Executes a task with optional exception raising. @param [CMDx::Task] The task to execute</p> <p>@param [Boolean] Whether to raise exceptions (default: false)</p> <p>@raise [StandardError] When raise is true and execution fails</p> <p>@return [CMDx::Result] The execution result</p> <p>@example <pre><code>CMDx::Executor.execute(my_task)\nCMDx::Executor.execute(my_task, raise: true)\n```# Attributes\n## task[RW] [](#attribute-i-task)\nReturns the task being executed.\n\n**@return** [Task] The task instance\n\n\n**@example**\n```ruby\nexecutor.task.id # =&gt; \"abc123\"\n</code></pre></p>"},{"location":"api/CMDx/Executor/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Executor/#execute","title":"execute()","text":"<p>Executes the task with graceful error handling.</p> <p>@return [CMDx::Result] The execution result</p> <p>@example <pre><code>executor = CMDx::Executor.new(my_task)\nresult = executor.execute\n```## execute!() [](#method-i-execute!)\nExecutes the task with exception raising on failure.\n\n**@raise** [StandardError] When execution fails\n\n**@return** [CMDx::Result] The execution result\n\n\n**@example**\n```ruby\nexecutor = CMDx::Executor.new(my_task)\nresult = executor.execute!\n```## initialize(task) [](#method-i-initialize)\n\n**@param** [CMDx::Task] The task to execute\n\n**@return** [CMDx::Executor] A new executor instance\n\n\n**@example**\n```ruby\nexecutor = CMDx::Executor.new(my_task)\n</code></pre></p>"},{"location":"api/CMDx/Fault/","title":"Class: CMDx::Fault","text":"<p>Inherits: Error</p> <p>Extended by: Forwardable</p> <p>Base fault class for handling task execution failures and interruptions.</p> <p>Faults represent error conditions that occur during task execution, providing a structured way to handle and categorize different types of failures. Each fault contains a reference to the result object that caused the fault.</p>"},{"location":"api/CMDx/Fault/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Fault/#fortasks","title":"for?(*tasks )","text":"<p>Create a fault class that matches specific task types. @param [Array] array of task classes to match against <p>@return [Class] a new fault class that matches the specified tasks</p> <p>@example <pre><code>Fault.for?(UserTask, AdminUserTask)\n# =&gt; true if fault.task is a UserTask or AdminUserTask\n```## matches?(&amp;block ) [](#method-c-matches?)\nCreate a fault class that matches based on a custom block.\n**@param** [Proc] block that determines if a fault matches\n\n**@raise** [ArgumentError] if no block is provided\n\n**@return** [Class] a new fault class that matches based on the block\n\n\n**@example**\n```ruby\nFault.matches? { |fault| fault.result.metadata[:critical] }\n# =&gt; true if fault has critical metadata\n```# Attributes\n## result[RW] [](#attribute-i-result)\nReturns the result that caused this fault.\n\n**@return** [Result] The result instance\n\n\n**@example**\n```ruby\nfault.result.reason # =&gt; \"Validation failed\"\n</code></pre></p>"},{"location":"api/CMDx/Fault/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Fault/#initializeresult","title":"initialize(result)","text":"<p>Initialize a new fault with the given result.</p> <p>@param [Result] the result object that caused this fault</p> <p>@raise [ArgumentError] if result is nil or invalid</p> <p>@return [Fault] a new instance of Fault</p> <p>@example <pre><code>fault = Fault.new(task_result)\nfault.result.reason # =&gt; \"Task validation failed\"\n</code></pre></p>"},{"location":"api/CMDx/Identifier/","title":"Module: CMDx::Identifier","text":"<p>Extended by: CMDx::Identifier</p> <p>Generates unique identifiers for tasks, workflows, and other CMDx components.</p> <p>The Identifier module provides a consistent way to generate unique identifiers across the CMDx system, with fallback support for different Ruby versions.</p>"},{"location":"api/CMDx/Identifier/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Identifier/#generate","title":"generate()","text":"<p>Generates a unique identifier string. @raise [StandardError] If SecureRandom is unavailable or fails to generate an identifier</p> <p>@return [String] A unique identifier string (UUID v7 if available, otherwise UUID v4)</p> <p>@example <pre><code>CMDx::Identifier.generate\n# =&gt; \"01890b2c-1234-5678-9abc-def123456789\"\n</code></pre></p>"},{"location":"api/CMDx/Identifier/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Identifier/#generate_1","title":"generate()","text":"<p>Generates a unique identifier string.</p> <p>@raise [StandardError] If SecureRandom is unavailable or fails to generate an identifier</p> <p>@return [String] A unique identifier string (UUID v7 if available, otherwise UUID v4)</p> <p>@example <pre><code>CMDx::Identifier.generate\n# =&gt; \"01890b2c-1234-5678-9abc-def123456789\"\n</code></pre></p>"},{"location":"api/CMDx/InstallGenerator/","title":"Class: Cmdx::InstallGenerator","text":"<p>Inherits: Rails::Generators::Base</p> <p>Generates CMDx initializer file for Rails applications</p> <p>This generator creates a configuration initializer that sets up global CMDx settings for the Rails application. It copies a pre-configured initializer template to the standard Rails initializers directory.</p>"},{"location":"api/CMDx/InstallGenerator/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/InstallGenerator/#copy_initializer_file","title":"copy_initializer_file()","text":"<p>Copies the CMDx initializer template to the Rails application</p> <p>Creates a new initializer file at <code>config/initializers/cmdx.rb</code> containing the default CMDx configuration settings. This allows applications to customize global CMDx behavior through the standard Rails configuration pattern.</p> <p>@return [void] </p> <p>@example <pre><code>rails generate cmdx:install\n</code></pre> @example <pre><code>generator.copy_initializer_file\n# =&gt; Creates config/initializers/cmdx.rb\n</code></pre></p>"},{"location":"api/CMDx/Locale/","title":"Module: CMDx::Locale","text":"<p>Extended by: CMDx::Locale</p> <p>Provides internationalization and localization support for CMDx. Handles translation lookups with fallback to default English messages when I18n gem is not available.</p>"},{"location":"api/CMDx/Locale/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Locale/#translatekey-options","title":"translate(key , **options )","text":"<p>Translates a key to the current locale with optional interpolation. Falls back to English translations if I18n gem is unavailable. @option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [String, Symbol] The translation key (supports dot notation)</p> <p>@param [Hash] Translation options</p> <p>@raise [ArgumentError] When interpolation fails due to missing keys</p> <p>@return [String] The translated message</p> <p>@example <pre><code>Locale.translate(\"errors.invalid_input\")\n# =&gt; \"Invalid input provided\"\n</code></pre> @example <pre><code>Locale.translate(\"welcome.message\", name: \"John\")\n# =&gt; \"Welcome, John!\"\n</code></pre> @example <pre><code>Locale.translate(\"missing.key\", default: \"Custom fallback message\")\n# =&gt; \"Custom fallback message\"\n</code></pre></p>"},{"location":"api/CMDx/Locale/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Locale/#translatekey-options_1","title":"translate(key, **options)","text":"<p>Translates a key to the current locale with optional interpolation. Falls back to English translations if I18n gem is unavailable.</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [String, Symbol] The translation key (supports dot notation)</p> <p>@param [Hash] Translation options</p> <p>@raise [ArgumentError] When interpolation fails due to missing keys</p> <p>@return [String] The translated message</p> <p>@example <pre><code>Locale.translate(\"errors.invalid_input\")\n# =&gt; \"Invalid input provided\"\n</code></pre> @example <pre><code>Locale.translate(\"welcome.message\", name: \"John\")\n# =&gt; \"Welcome, John!\"\n</code></pre> @example <pre><code>Locale.translate(\"missing.key\", default: \"Custom fallback message\")\n# =&gt; \"Custom fallback message\"\n</code></pre></p>"},{"location":"api/CMDx/LocaleGenerator/","title":"Class: Cmdx::LocaleGenerator","text":"<p>Inherits: Rails::Generators::Base</p> <p>Generates CMDx locale files for Rails applications</p> <p>Rails generator that copies CMDx locale files into the application's config/locales directory. This allows applications to customize and extend the default CMDx locale files.</p>"},{"location":"api/CMDx/LocaleGenerator/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/LocaleGenerator/#copy_locale_files","title":"copy_locale_files()","text":"<p>Copies the locale template to the Rails application</p> <p>Copies the specified locale file from the gem's locales directory to the application's config/locales directory. If the locale file doesn't exist in the gem, the generator will fail gracefully.</p> <p>@return [void] </p> <p>@example <pre><code># Copy default (English) locale file\nrails generate cmdx:locale\n# =&gt; Creates config/locales/en.yml\n\n# Copy Spanish locale file\nrails generate cmdx:locale es\n# =&gt; Creates config/locales/es.yml\n</code></pre></p>"},{"location":"api/CMDx/LogFormatters/","title":"Module: CMDx::LogFormatters","text":""},{"location":"api/CMDx/MiddlewareRegistry/","title":"Class: CMDx::MiddlewareRegistry","text":"<p>Inherits: Object</p> <p>Registry for managing middleware components in a task execution chain.</p> <p>The MiddlewareRegistry maintains an ordered list of middleware components that can be inserted, removed, and executed in sequence. Each middleware can be configured with specific options and is executed in the order they were registered.</p>"},{"location":"api/CMDx/MiddlewareRegistry/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/MiddlewareRegistry/#registryrw","title":"registry[RW]","text":"<p>Returns the ordered collection of middleware entries.</p> <p>@return [Array] Array of middleware-options pairs <p>@example <pre><code>registry.registry # =&gt; [[LoggingMiddleware, {level: :debug}], [AuthMiddleware, {}]]\n</code></pre></p>"},{"location":"api/CMDx/MiddlewareRegistry/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/MiddlewareRegistry/#calltask","title":"call!(task)","text":"<p>Execute the middleware chain for a given task.</p> <p>@param [Object] The task object to process through middleware</p> <p>@raise [ArgumentError] When no block is provided</p> <p>@return [Object] Result of the block execution</p> <p>@yield [task] Block to execute after all middleware processing</p> <p>@yieldparam [Object] The processed task object</p> <p>@example <pre><code>result = registry.call!(my_task) do |processed_task|\n  processed_task.execute\nend\n```## deregister(middleware) [](#method-i-deregister)\nRemove a middleware component from the registry.\n\n**@param** [Object] The middleware object to remove\n\n**@return** [MiddlewareRegistry] Returns self for method chaining\n\n\n**@example**\n```ruby\nregistry.deregister(LoggingMiddleware)\n```## dup() [](#method-i-dup)\nCreate a duplicate of the registry with duplicated middleware entries.\n\n**@return** [MiddlewareRegistry] A new registry instance with duplicated entries\n\n\n**@example**\n```ruby\nnew_registry = registry.dup\n```## initialize(registry[]) [](#method-i-initialize)\nInitialize a new middleware registry.\n\n**@param** [Array] Initial array of middleware entries\n\n**@return** [MiddlewareRegistry] a new instance of MiddlewareRegistry\n\n\n**@example**\n```ruby\nregistry = MiddlewareRegistry.new\nregistry = MiddlewareRegistry.new([[MyMiddleware, {option: 'value'}]])\n```## register(middleware, at:-1,, **options) [](#method-i-register)\nRegister a middleware component in the registry.\n\n**@option** [] \n\n**@option** [] \n\n**@param** [Object] The middleware object to register\n\n**@param** [Integer] Position to insert the middleware (default: -1, end of list)\n\n**@param** [Hash] Configuration options for the middleware\n\n**@return** [MiddlewareRegistry] Returns self for method chaining\n\n\n**@example**\n```ruby\nregistry.register(LoggingMiddleware, at: 0, log_level: :debug)\nregistry.register(AuthMiddleware, at: -1, timeout: 30)\n</code></pre></p>"},{"location":"api/CMDx/Middlewares/","title":"Module: CMDx::Middlewares","text":""},{"location":"api/CMDx/Pipeline/","title":"Class: CMDx::Pipeline","text":"<p>Inherits: Object</p> <p>Executes workflows by processing task groups with conditional logic and breakpoint handling. The Pipeline class manages the execution flow of workflow tasks, evaluating conditions and handling breakpoints that can interrupt execution at specific task statuses.</p>"},{"location":"api/CMDx/Pipeline/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Pipeline/#executeworkflow","title":"execute(workflow )","text":"<p>Executes a workflow using a new pipeline instance. @param [Workflow] The workflow to execute</p> <p>@return [void] </p> <p>@example <pre><code>Pipeline.execute(my_workflow)\n```# Attributes\n## workflow[RW] [](#attribute-i-workflow)\nReturns the workflow being executed by this pipeline.\n\n**@return** [Workflow] The workflow instance\n\n\n**@example**\n```ruby\npipeline.workflow.context[:status] # =&gt; \"processing\"\n</code></pre></p>"},{"location":"api/CMDx/Pipeline/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Pipeline/#execute","title":"execute()","text":"<p>Executes the workflow by processing all task groups in sequence. Each group is evaluated against its conditions, and breakpoints are checked after each task execution to determine if workflow should continue or halt.</p> <p>@return [void] </p> <p>@example <pre><code>pipeline = Pipeline.new(my_workflow)\npipeline.execute\n```## initialize(workflow) [](#method-i-initialize)\n\n**@param** [Workflow] The workflow to execute\n\n**@return** [Pipeline] A new pipeline instance\n\n\n**@example**\n```ruby\npipeline = Pipeline.new(my_workflow)\n</code></pre></p>"},{"location":"api/CMDx/Railtie/","title":"Class: CMDx::Railtie","text":"<p>Inherits: Rails::Railtie</p> <p>Rails integration class that automatically configures CMDx when the Rails application initializes. Handles locale configuration and I18n setup.</p>"},{"location":"api/CMDx/Result/","title":"Class: CMDx::Result","text":"<p>Inherits: Object</p> <p>Extended by: Forwardable</p> <p>Represents the execution result of a CMDx task, tracking state transitions, status changes, and providing methods for handling different outcomes.</p> <p>The Result class manages the lifecycle of task execution from initialization through completion or interruption, offering a fluent interface for status checking and conditional handling.</p>"},{"location":"api/CMDx/Result/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/Result/#causerw","title":"cause[RW]","text":"<p>Returns the exception that caused the interruption.</p> <p>@return [Exception, nil] The causing exception, or nil if not interrupted</p> <p>@example <pre><code>result.cause # =&gt; #&lt;StandardError: Connection timeout&gt;\n```## metadata[RW] [](#attribute-i-metadata)\nReturns additional metadata about the result.\n\n**@return** [Hash{Symbol =&gt; Object}] Metadata hash\n\n\n**@example**\n```ruby\nresult.metadata # =&gt; { duration: 1.5, retries: 2 }\n```## reason[RW] [](#attribute-i-reason)\nReturns the reason for interruption (skip or failure).\n\n**@return** [String, nil] The reason message, or nil if not interrupted\n\n\n**@example**\n```ruby\nresult.reason # =&gt; \"Validation failed\"\n```## state[RW] [](#attribute-i-state)\nReturns the current execution state of the result.\n\n**@return** [String] One of: \"initialized\", \"executing\", \"complete\", \"interrupted\"\n\n\n**@example**\n```ruby\nresult.state # =&gt; \"complete\"\n```## status[RW] [](#attribute-i-status)\nReturns the execution status of the result.\n\n**@return** [String] One of: \"success\", \"skipped\", \"failed\"\n\n\n**@example**\n```ruby\nresult.status # =&gt; \"success\"\n```## task[RW] [](#attribute-i-task)\nReturns the task instance associated with this result.\n\n**@return** [CMDx::Task] The task instance\n\n\n**@example**\n```ruby\nresult.task.id # =&gt; \"users/create\"\n</code></pre></p>"},{"location":"api/CMDx/Result/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Result/#bad","title":"bad?()","text":"<p>@return [Boolean] Whether the task execution was unsuccessful (not success)</p> <p>@example <pre><code>result.bad? # =&gt; true if !success?\n```## caused_failure() [](#method-i-caused_failure)\n\n**@return** [CMDx::Result, nil] The result that caused this failure, or nil\n\n\n**@example**\n```ruby\ncause = result.caused_failure\nputs \"Caused by: #{cause.task.id}\" if cause\n```## caused_failure?() [](#method-i-caused_failure?)\n\n**@return** [Boolean] Whether this result caused the failure\n\n\n**@example**\n```ruby\nif result.caused_failure?\n  puts \"This task caused the failure\"\nend\n```## complete!() [](#method-i-complete!)\n\n**@raise** [RuntimeError] When attempting to transition from invalid state\n\n\n**@example**\n```ruby\nresult.complete! # Transitions from executing to complete\n```## deconstruct() [](#method-i-deconstruct)\n\n**@param** [Array] Array of keys to deconstruct\n\n**@return** [Array] Array containing state, status, reason, cause, and metadata\n\n\n**@example**\n```ruby\nstate, status = result.deconstruct\nputs \"State: #{state}, Status: #{status}\"\n```## deconstruct_keys() [](#method-i-deconstruct_keys)\n\n**@param** [Array] Array of keys to deconstruct\n\n**@return** [Hash] Hash with key-value pairs for pattern matching\n\n\n**@example**\n```ruby\ncase result.deconstruct_keys\nin {state: \"complete\", good: true}\n  puts \"Task completed successfully\"\nin {bad: true}\n  puts \"Task had issues\"\nend\n```## executed!() [](#method-i-executed!)\n\n**@return** [self] Returns self for method chaining\n\n\n**@example**\n```ruby\nresult.executed! # Transitions to complete or interrupted\n```## executed?() [](#method-i-executed?)\n\n**@return** [Boolean] Whether the task has been executed (complete or interrupted)\n\n\n**@example**\n```ruby\nresult.executed? # =&gt; true if complete? || interrupted?\n```## executing!() [](#method-i-executing!)\n\n**@raise** [RuntimeError] When attempting to transition from invalid state\n\n\n**@example**\n```ruby\nresult.executing! # Transitions from initialized to executing\n```## fail!(reasonnil, halt:true, cause:nil, **metadata) [](#method-i-fail!)\n\n**@param** [String, nil] Reason for task failure\n\n**@param** [Boolean] Whether to halt execution after failure\n\n**@param** [Exception, nil] Exception that caused the failure\n\n**@param** [Hash] Additional metadata about the failure\n\n**@raise** [RuntimeError] When attempting to fail from invalid status\n\n\n**@example**\n```ruby\nresult.fail!(\"Validation failed\", cause: validation_error)\nresult.fail!(\"Network timeout\", halt: false, timeout: 30)\n```## good?() [](#method-i-good?)\n\n**@return** [Boolean] Whether the task execution was successful (not failed)\n\n\n**@example**\n```ruby\nresult.good? # =&gt; true if !failed?\n```## halt!() [](#method-i-halt!)\n\n**@raise** [SkipFault] When task was skipped\n\n**@raise** [FailFault] When task failed\n\n\n**@example**\n```ruby\nresult.halt! # Raises appropriate fault based on status\n```## handle_bad() [](#method-i-handle_bad)\n\n**@param** [Proc] Block to execute conditionally\n\n**@raise** [ArgumentError] When no block is provided\n\n**@return** [self] Returns self for method chaining\n\n**@yield** [self] Executes the block if task execution was unsuccessful\n\n\n**@example**\n```ruby\nresult.handle_bad { |r| puts \"Task had issues: #{r.reason}\" }\n```## handle_executed() [](#method-i-handle_executed)\n\n**@param** [Proc] Block to execute conditionally\n\n**@raise** [ArgumentError] When no block is provided\n\n**@return** [self] Returns self for method chaining\n\n**@yield** [self] Executes the block if task has been executed\n\n\n**@example**\n```ruby\nresult.handle_executed { |r| puts \"Task finished: #{r.outcome}\" }\n```## handle_good() [](#method-i-handle_good)\n\n**@param** [Proc] Block to execute conditionally\n\n**@raise** [ArgumentError] When no block is provided\n\n**@return** [self] Returns self for method chaining\n\n**@yield** [self] Executes the block if task execution was successful\n\n\n**@example**\n```ruby\nresult.handle_good { |r| puts \"Task completed successfully\" }\n```## index() [](#method-i-index)\n\n**@return** [Integer] Index of this result in the chain\n\n\n**@example**\n```ruby\nposition = result.index\nputs \"Task #{position + 1} of #{chain.results.count}\"\n```## initialize(task) [](#method-i-initialize)\n\n**@param** [CMDx::Task] The task instance this result represents\n\n**@raise** [TypeError] When task is not a CMDx::Task instance\n\n**@return** [CMDx::Result] A new result instance for the task\n\n\n**@example**\n```ruby\nresult = CMDx::Result.new(my_task)\nresult.state # =&gt; \"initialized\"\n```## interrupt!() [](#method-i-interrupt!)\n\n**@raise** [RuntimeError] When attempting to transition from invalid state\n\n\n**@example**\n```ruby\nresult.interrupt! # Transitions from executing to interrupted\n```## outcome() [](#method-i-outcome)\n\n**@return** [String] The outcome of the task execution\n\n\n**@example**\n```ruby\nresult.outcome # =&gt; \"success\" or \"interrupted\"\n```## skip!(reasonnil, halt:true, cause:nil, **metadata) [](#method-i-skip!)\n\n**@param** [String, nil] Reason for skipping the task\n\n**@param** [Boolean] Whether to halt execution after skipping\n\n**@param** [Exception, nil] Exception that caused the skip\n\n**@param** [Hash] Additional metadata about the skip\n\n**@raise** [RuntimeError] When attempting to skip from invalid status\n\n\n**@example**\n```ruby\nresult.skip!(\"Dependencies not met\", cause: dependency_error)\nresult.skip!(\"Already processed\", halt: false)\n```## threw_failure() [](#method-i-threw_failure)\n\n**@return** [CMDx::Result, nil] The result that threw this failure, or nil\n\n\n**@example**\n```ruby\nthrown = result.threw_failure\nputs \"Thrown by: #{thrown.task.id}\" if thrown\n```## threw_failure?() [](#method-i-threw_failure?)\n\n**@return** [Boolean] Whether this result threw the failure\n\n\n**@example**\n```ruby\nif result.threw_failure?\n  puts \"This task threw the failure\"\nend\n```## throw!(result, halt:true, cause:nil, **metadata) [](#method-i-throw!)\n\n**@param** [CMDx::Result] Result to throw from current result\n\n**@param** [Boolean] Whether to halt execution after throwing\n\n**@param** [Exception, nil] Exception that caused the throw\n\n**@param** [Hash] Additional metadata to merge\n\n**@raise** [TypeError] When result is not a CMDx::Result instance\n\n\n**@example**\n```ruby\nother_result = OtherTask.execute\nresult.throw!(other_result, cause: upstream_error)\n```## thrown_failure?() [](#method-i-thrown_failure?)\n\n**@return** [Boolean] Whether this result is a thrown failure\n\n\n**@example**\n```ruby\nif result.thrown_failure?\n  puts \"This failure was thrown from another task\"\nend\n```## to_h() [](#method-i-to_h)\n\n**@return** [Hash] Hash representation of the result\n\n\n**@example**\n```ruby\nresult.to_h\n# =&gt; {state: \"complete\", status: \"success\", outcome: \"success\", metadata: {}}\n```## to_s() [](#method-i-to_s)\n\n**@return** [String] String representation of the result\n\n\n**@example**\n```ruby\nresult.to_s # =&gt; \"task_id=my_task state=complete status=success\"\n</code></pre></p>"},{"location":"api/CMDx/Task/","title":"Class: CMDx::Task","text":"<p>Inherits: Object</p> <p>Extended by: Forwardable</p> <p>Represents a task that can be executed within the CMDx framework. Tasks define attributes, callbacks, and execution logic that can be chained together to form workflows.</p>"},{"location":"api/CMDx/Task/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Task/#attributes","title":"attributes()","text":"<p>@param [Array] Arguments to build the attribute with</p> <p>@example <pre><code>attributes :name, :email\nattributes :age, type: Integer, default: 18\n```## deregister(type , object ) [](#method-c-deregister)\n**@param** [Symbol] The type of registry to deregister from\n\n**@param** [Object] The object to deregister\n\n**@param** [Array] Additional arguments for deregistration\n\n**@raise** [RuntimeError] If the registry type is unknown\n\n\n**@example**\n```ruby\nderegister(:attribute, :name)\nderegister(:callback, :before, MyCallback)\n```## execute(*args , **kwargs ) [](#method-c-execute)\n**@param** [Array] Arguments to pass to the task constructor\n\n**@return** [Result] The execution result\n\n\n**@example**\n```ruby\nresult = MyTask.execute(name: \"example\")\nif result.success?\n  puts \"Task completed successfully\"\nend\n```## execute!(*args , **kwargs ) [](#method-c-execute!)\n**@param** [Array] Arguments to pass to the task constructor\n\n**@raise** [ExecutionError] If the task execution fails\n\n**@return** [Result] The execution result\n\n\n**@example**\n```ruby\nresult = MyTask.execute!(name: \"example\")\n# Will raise an exception if execution fails\n```## optional() [](#method-c-optional)\n**@param** [Array] Arguments to build the optional attribute with\n\n\n**@example**\n```ruby\noptional :description, :notes\noptional :priority, type: Symbol, default: :normal\n```## register(type , object ) [](#method-c-register)\n**@param** [Symbol] The type of registry to register with\n\n**@param** [Object] The object to register\n\n**@param** [Array] Additional arguments for registration\n\n**@raise** [RuntimeError] If the registry type is unknown\n\n\n**@example**\n```ruby\nregister(:attribute, MyAttribute.new)\nregister(:callback, :before, -&gt; { puts \"before\" })\n```## remove_attributes(*names ) [](#method-c-remove_attributes)\n**@param** [Array&lt;Symbol&gt;] Names of attributes to remove\n\n\n**@example**\n```ruby\nremove_attributes :old_field, :deprecated_field\n```## required() [](#method-c-required)\n**@param** [Array] Arguments to build the required attribute with\n\n\n**@example**\n```ruby\nrequired :name, :email\nrequired :age, type: Integer, min: 0\n```## settings(**options ) [](#method-c-settings)\n**@param** [Hash] Configuration options to merge with existing settings\n\n**@return** [Hash] The merged settings hash\n\n\n**@example**\n```ruby\nclass MyTask &lt; Task\n  settings deprecate: true, tags: [:experimental]\nend\n```# Attributes\n## attributes[RW] [](#attribute-i-attributes)\nReturns the hash of processed attribute values for this task.\n\n**@return** [Hash{Symbol =&gt; Object}] Hash of attribute names to their values\n\n\n**@example**\n```ruby\ntask.attributes # =&gt; { user_id: 42, user_name: \"John\" }\n```## chain[RW] [](#attribute-i-chain)\nReturns the execution chain containing all task results.\n\n**@return** [Chain] The chain instance\n\n\n**@example**\n```ruby\ntask.chain.results.size # =&gt; 3\n```## context[RW] [](#attribute-i-context)\nReturns the execution context for this task.\n\n**@return** [Context] The context instance\n\n\n**@example**\n```ruby\ntask.context[:user_id] # =&gt; 42\n```## errors[RW] [](#attribute-i-errors)\nReturns the collection of validation and execution errors.\n\n**@return** [Errors] The errors collection\n\n\n**@example**\n```ruby\ntask.errors.to_h # =&gt; { email: [\"must be valid\"] }\n```## id[RW] [](#attribute-i-id)\nReturns the unique identifier for this task instance.\n\n**@return** [String] The task identifier\n\n\n**@example**\n```ruby\ntask.id # =&gt; \"abc123xyz\"\n```## result[RW] [](#attribute-i-result)\nReturns the execution result for this task.\n\n**@return** [Result] The result instance\n\n\n**@example**\n```ruby\ntask.result.status # =&gt; \"success\"\n</code></pre></p>"},{"location":"api/CMDx/Task/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Task/#executeraisefalse","title":"execute(raise:false)","text":"<p>@param [Boolean] Whether to raise exceptions on failure</p> <p>@return [Result] The execution result</p> <p>@example <pre><code>result = task.execute\nresult = task.execute(raise: true)\n```## initialize(context{}) [](#method-i-initialize)\n\n**@option** [] \n\n**@param** [Hash, Context] The initial context for the task\n\n**@raise** [DeprecationError] If the task class is deprecated\n\n**@return** [Task] A new task instance\n\n\n**@example**\n```ruby\ntask = MyTask.new(name: \"example\", priority: :high)\ntask = MyTask.new(Context.build(name: \"example\"))\n```## logger() [](#method-i-logger)\n\n**@return** [Logger] The logger instance for this task\n\n\n**@example**\n```ruby\nlogger.info \"Starting task execution\"\nlogger.error \"Task failed\", error: exception\n```## to_h() [](#method-i-to_h)\n\n**@option** [] \n\n**@option** [] \n\n**@option** [] \n\n**@option** [] \n\n**@option** [] \n\n**@option** [] \n\n**@param** [Hash] a customizable set of options\n\n**@return** [Hash] A hash representation of the task\n\n\n**@example**\n```ruby\ntask_hash = task.to_h\nputs \"Task type: #{task_hash[:type]}\"\nputs \"Task tags: #{task_hash[:tags].join(', ')}\"\n```## to_s() [](#method-i-to_s)\n\n**@return** [String] A string representation of the task\n\n\n**@example**\n```ruby\nputs task.to_s\n# Output: \"Task[MyTask] tags: [:important] id: abc123\"\n```## work() [](#method-i-work)\n\n**@raise** [UndefinedMethodError] Always raised as this method must be overridden\n\n\n**@example**\n```ruby\nclass MyTask &lt; Task\n  def work\n    # Custom work logic here\n    puts \"Performing work...\"\n  end\nend\n</code></pre></p>"},{"location":"api/CMDx/TaskGenerator/","title":"Class: Cmdx::TaskGenerator","text":"<p>Inherits: Rails::Generators::NamedBase</p> <p>Generates CMDx task files for Rails applications</p> <p>This generator creates task classes that inherit from either ApplicationTask (if defined) or CMDx::Task. It generates the task file in the standard Rails tasks directory structure.</p>"},{"location":"api/CMDx/TaskGenerator/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/TaskGenerator/#copy_files","title":"copy_files()","text":"<p>Copies the task template to the Rails application</p> <p>Creates a new task file at <code>[app/tasks/](class_path)/[file_name].rb</code> using the task template. The file is placed in the standard Rails tasks directory structure, maintaining proper namespacing if the task is nested.</p> <p>@return [void] </p> <p>@example <pre><code>rails generate cmdx:task UserRegistration\n# =&gt; Creates app/tasks/user_registration.rb\n</code></pre> @example <pre><code>rails generate cmdx:task Admin::UserManagement\n# =&gt; Creates app/tasks/admin/user_management.rb\n</code></pre></p>"},{"location":"api/CMDx/Utils/","title":"Module: CMDx::Utils","text":""},{"location":"api/CMDx/ValidatorRegistry/","title":"Class: CMDx::ValidatorRegistry","text":"<p>Inherits: Object</p> <p>Extended by: Forwardable</p> <p>Registry for managing validation rules and their corresponding validator classes. Provides methods to register, deregister, and execute validators against task values.</p>"},{"location":"api/CMDx/ValidatorRegistry/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/ValidatorRegistry/#registryrw","title":"registry[RW]","text":"<p>Returns the internal registry mapping validator types to classes.</p> <p>@return [Hash{Symbol =&gt; Class}] Hash of validator type names to validator classes</p> <p>@example <pre><code>registry.registry # =&gt; { presence: Validators::Presence, format: Validators::Format }\n</code></pre></p>"},{"location":"api/CMDx/ValidatorRegistry/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/ValidatorRegistry/#deregistername","title":"deregister(name)","text":"<p>Remove a validator from the registry by name.</p> <p>@param [String, Symbol] The name of the validator to remove</p> <p>@return [ValidatorRegistry] Returns self for method chaining</p> <p>@example <pre><code>registry.deregister(:format)\nregistry.deregister(\"presence\")\n```## dup() [](#method-i-dup)\nCreate a duplicate of the registry with copied internal state.\n\n**@return** [ValidatorRegistry] A new validator registry with duplicated registry hash\n\n## initialize(registrynil) [](#method-i-initialize)\nInitialize a new validator registry with default validators.\n\n**@param** [Hash, nil] Optional hash mapping validator names to validator classes\n\n**@return** [ValidatorRegistry] A new validator registry instance\n\n## register(name, validator) [](#method-i-register)\nRegister a new validator class with the given name.\n\n**@param** [String, Symbol] The name to register the validator under\n\n**@param** [Class] The validator class to register\n\n**@return** [ValidatorRegistry] Returns self for method chaining\n\n\n**@example**\n```ruby\nregistry.register(:custom, CustomValidator)\nregistry.register(\"email\", EmailValidator)\n```## validate(type, task, value, options{}) [](#method-i-validate)\nValidate a value using the specified validator type and options.\n\n**@option** [] \n\n**@param** [Symbol] The type of validator to use\n\n**@param** [Task] The task context for validation\n\n**@param** [Object] The value to validate\n\n**@param** [Hash, Object] Validation options or condition\n\n**@raise** [TypeError] When the validator type is not registered\n\n\n**@example**\n```ruby\nregistry.validate(:presence, task, user.name, presence: true)\nregistry.validate(:length, task, password, { min: 8, allow_nil: false })\n</code></pre></p>"},{"location":"api/CMDx/Validators/","title":"Module: CMDx::Validators","text":""},{"location":"api/CMDx/Workflow/","title":"Module: CMDx::Workflow","text":"<p>Provides workflow execution capabilities by organizing tasks into execution groups. Workflows allow you to define sequences of tasks that can be executed conditionally with breakpoint handling and context management.</p>"},{"location":"api/CMDx/Workflow/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Workflow/#includedbase","title":"included(base )","text":"<p>Extends the including class with workflow capabilities. @param [Class] The class including this module</p> <p>@example <pre><code>class MyWorkflow\n  include CMDx::Workflow\n  # Now has access to task, tasks, and work methods\nend\n</code></pre></p>"},{"location":"api/CMDx/Workflow/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Workflow/#work","title":"work()","text":"<p>Executes the workflow by processing all tasks in the pipeline. This method delegates execution to the Pipeline class which handles the processing of tasks with proper error handling and context management.</p> <p>@example <pre><code>class MyWorkflow\n  include CMDx::Workflow\n  task ValidateTask\n  task ProcessTask\nend\n\nworkflow = MyWorkflow.new\nresult = workflow.work\n</code></pre></p>"},{"location":"api/CMDx/WorkflowGenerator/","title":"Class: Cmdx::WorkflowGenerator","text":"<p>Inherits: Rails::Generators::NamedBase</p> <p>Generates CMDx workflow files for Rails applications</p> <p>This generator creates task classes that inherit from either ApplicationTask (if defined) or CMDx::Task. It generates the task file in the standard Rails tasks directory structure.</p>"},{"location":"api/CMDx/WorkflowGenerator/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/WorkflowGenerator/#copy_files","title":"copy_files()","text":"<p>Copies the task template to the Rails application</p> <p>Creates a new task file at <code>[app/tasks/](class_path)/[file_name].rb</code> using the task template. The file is placed in the standard Rails tasks directory structure, maintaining proper namespacing if the task is nested.</p> <p>@return [void] </p> <p>@example <pre><code>rails generate cmdx:workflow SendNotifications\n# =&gt; Creates app/tasks/send_notifications.rb\n</code></pre> @example <pre><code>rails generate cmdx:workflow Admin::SendNotifications\n# =&gt; Creates app/tasks/admin/send_notifications.rb\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Array/","title":"Module: CMDx::Coercions::Array","text":"<p>Extended by: CMDx::Coercions::Array</p> <p>Converts various input types to Array format</p> <p>Handles conversion from strings that look like JSON arrays and other values that can be converted to arrays using Ruby's Array() method.</p>"},{"location":"api/CMDx/Coercions/Array/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Array/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to an Array @option [] </p> <p>@param [Object] The value to convert to an array</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [JSON::ParserError] If the string value contains invalid JSON</p> <p>@return [Array] The converted array value</p> <p>@example <pre><code>Array.call(\"[1, 2, 3]\") # =&gt; [1, 2, 3]\n</code></pre> @example <pre><code>Array.call(\"hello\")     # =&gt; [\"hello\"]\nArray.call(42)          # =&gt; [42]\nArray.call(nil)         # =&gt; []\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Array/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Array/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to an Array</p> <p>@option [] </p> <p>@param [Object] The value to convert to an array</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [JSON::ParserError] If the string value contains invalid JSON</p> <p>@return [Array] The converted array value</p> <p>@example <pre><code>Array.call(\"[1, 2, 3]\") # =&gt; [1, 2, 3]\n</code></pre> @example <pre><code>Array.call(\"hello\")     # =&gt; [\"hello\"]\nArray.call(42)          # =&gt; [42]\nArray.call(nil)         # =&gt; []\n</code></pre></p>"},{"location":"api/CMDx/Coercions/BigDecimal/","title":"Module: CMDx::Coercions::BigDecimal","text":"<p>Extended by: CMDx::Coercions::BigDecimal</p> <p>Converts various input types to BigDecimal format</p> <p>Handles conversion from numeric strings, integers, floats, and other values that can be converted to BigDecimal using Ruby's BigDecimal() method.</p>"},{"location":"api/CMDx/Coercions/BigDecimal/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/BigDecimal/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to a BigDecimal @option [] </p> <p>@param [Object] The value to convert to BigDecimal</p> <p>@param [Hash] Optional configuration parameters</p> <p>@raise [CoercionError] If the value cannot be converted to BigDecimal</p> <p>@return [BigDecimal] The converted BigDecimal value</p> <p>@example <pre><code>BigDecimal.call(\"123.45\")                   # =&gt; #&lt;BigDecimal:7f8b8c0d8e0f '0.12345E3',9(18)&gt;\nBigDecimal.call(\"0.001\", precision: 6)      # =&gt; #&lt;BigDecimal:7f8b8c0d8e0f '0.1E-2',9(18)&gt;\n</code></pre> @example <pre><code>BigDecimal.call(42)                         # =&gt; #&lt;BigDecimal:7f8b8c0d8e0f '0.42E2',9(18)&gt;\nBigDecimal.call(3.14159)                    # =&gt; #&lt;BigDecimal:7f8b8c0d8e0f '0.314159E1',9(18)&gt;\n</code></pre></p>"},{"location":"api/CMDx/Coercions/BigDecimal/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/BigDecimal/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to a BigDecimal</p> <p>@option [] </p> <p>@param [Object] The value to convert to BigDecimal</p> <p>@param [Hash] Optional configuration parameters</p> <p>@raise [CoercionError] If the value cannot be converted to BigDecimal</p> <p>@return [BigDecimal] The converted BigDecimal value</p> <p>@example <pre><code>BigDecimal.call(\"123.45\")                   # =&gt; #&lt;BigDecimal:7f8b8c0d8e0f '0.12345E3',9(18)&gt;\nBigDecimal.call(\"0.001\", precision: 6)      # =&gt; #&lt;BigDecimal:7f8b8c0d8e0f '0.1E-2',9(18)&gt;\n</code></pre> @example <pre><code>BigDecimal.call(42)                         # =&gt; #&lt;BigDecimal:7f8b8c0d8e0f '0.42E2',9(18)&gt;\nBigDecimal.call(3.14159)                    # =&gt; #&lt;BigDecimal:7f8b8c0d8e0f '0.314159E1',9(18)&gt;\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Boolean/","title":"Module: CMDx::Coercions::Boolean","text":"<p>Extended by: CMDx::Coercions::Boolean</p> <p>Converts various input types to Boolean format</p> <p>Handles conversion from strings, numbers, and other values to boolean using predefined truthy and falsey patterns.</p>"},{"location":"api/CMDx/Coercions/Boolean/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Boolean/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to a Boolean @option [] </p> <p>@param [Object] The value to convert to boolean</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to boolean</p> <p>@return [Boolean] The converted boolean value</p> <p>@example <pre><code>Boolean.call(\"true\")   # =&gt; true\nBoolean.call(\"yes\")    # =&gt; true\nBoolean.call(\"1\")      # =&gt; true\n</code></pre> @example <pre><code>Boolean.call(\"false\")  # =&gt; false\nBoolean.call(\"no\")     # =&gt; false\nBoolean.call(\"0\")      # =&gt; false\n</code></pre> @example <pre><code>Boolean.call(\"TRUE\")   # =&gt; true\nBoolean.call(\"False\")  # =&gt; false\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Boolean/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Boolean/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to a Boolean</p> <p>@option [] </p> <p>@param [Object] The value to convert to boolean</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to boolean</p> <p>@return [Boolean] The converted boolean value</p> <p>@example <pre><code>Boolean.call(\"true\")   # =&gt; true\nBoolean.call(\"yes\")    # =&gt; true\nBoolean.call(\"1\")      # =&gt; true\n</code></pre> @example <pre><code>Boolean.call(\"false\")  # =&gt; false\nBoolean.call(\"no\")     # =&gt; false\nBoolean.call(\"0\")      # =&gt; false\n</code></pre> @example <pre><code>Boolean.call(\"TRUE\")   # =&gt; true\nBoolean.call(\"False\")  # =&gt; false\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Complex/","title":"Module: CMDx::Coercions::Complex","text":"<p>Extended by: CMDx::Coercions::Complex</p> <p>Converts various input types to Complex number format</p> <p>Handles conversion from numeric strings, integers, floats, and other values that can be converted to Complex using Ruby's Complex() method.</p>"},{"location":"api/CMDx/Coercions/Complex/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Complex/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to a Complex number @param [Object] The value to convert to Complex</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to Complex</p> <p>@return [Complex] The converted Complex number value</p> <p>@example <pre><code>Complex.call(\"3+4i\")                     # =&gt; (3+4i)\nComplex.call(\"2.5\")                      # =&gt; (2.5+0i)\n</code></pre> @example <pre><code>Complex.call(5)                          # =&gt; (5+0i)\nComplex.call(3.14)                       # =&gt; (3.14+0i)\nComplex.call(Complex(1, 2))              # =&gt; (1+2i)\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Complex/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Complex/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to a Complex number</p> <p>@param [Object] The value to convert to Complex</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to Complex</p> <p>@return [Complex] The converted Complex number value</p> <p>@example <pre><code>Complex.call(\"3+4i\")                     # =&gt; (3+4i)\nComplex.call(\"2.5\")                      # =&gt; (2.5+0i)\n</code></pre> @example <pre><code>Complex.call(5)                          # =&gt; (5+0i)\nComplex.call(3.14)                       # =&gt; (3.14+0i)\nComplex.call(Complex(1, 2))              # =&gt; (1+2i)\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Date/","title":"Module: CMDx::Coercions::Date","text":"<p>Extended by: CMDx::Coercions::Date</p> <p>Converts various input types to Date format</p> <p>Handles conversion from strings, Date objects, DateTime objects, Time objects, and other date-like values to Date objects using Ruby's built-in parsing capabilities and optional custom format parsing.</p>"},{"location":"api/CMDx/Coercions/Date/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Date/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to a Date object @option [] </p> <p>@param [Object] The value to convert to a Date</p> <p>@param [Hash] Optional configuration parameters</p> <p>@raise [CoercionError] If the value cannot be converted to a Date</p> <p>@return [Date] The converted Date object</p> <p>@example <pre><code>Date.call(\"2023-12-25\")           # =&gt; #&lt;Date: 2023-12-25&gt;\nDate.call(\"Dec 25, 2023\")        # =&gt; #&lt;Date: 2023-12-25&gt;\n</code></pre> @example <pre><code>Date.call(\"25/12/2023\", strptime: \"%d/%m/%Y\")  # =&gt; #&lt;Date: 2023-12-25&gt;\nDate.call(\"12-25-2023\", strptime: \"%m-%d-%Y\")  # =&gt; #&lt;Date: 2023-12-25&gt;\n</code></pre> @example <pre><code>Date.call(Date.new(2023, 12, 25)) # =&gt; #&lt;Date: 2023-12-25&gt;\nDate.call(DateTime.new(2023, 12, 25)) # =&gt; #&lt;Date: 2023-12-25&gt;\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Date/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Date/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to a Date object</p> <p>@option [] </p> <p>@param [Object] The value to convert to a Date</p> <p>@param [Hash] Optional configuration parameters</p> <p>@raise [CoercionError] If the value cannot be converted to a Date</p> <p>@return [Date] The converted Date object</p> <p>@example <pre><code>Date.call(\"2023-12-25\")           # =&gt; #&lt;Date: 2023-12-25&gt;\nDate.call(\"Dec 25, 2023\")        # =&gt; #&lt;Date: 2023-12-25&gt;\n</code></pre> @example <pre><code>Date.call(\"25/12/2023\", strptime: \"%d/%m/%Y\")  # =&gt; #&lt;Date: 2023-12-25&gt;\nDate.call(\"12-25-2023\", strptime: \"%m-%d-%Y\")  # =&gt; #&lt;Date: 2023-12-25&gt;\n</code></pre> @example <pre><code>Date.call(Date.new(2023, 12, 25)) # =&gt; #&lt;Date: 2023-12-25&gt;\nDate.call(DateTime.new(2023, 12, 25)) # =&gt; #&lt;Date: 2023-12-25&gt;\n</code></pre></p>"},{"location":"api/CMDx/Coercions/DateTime/","title":"Module: CMDx::Coercions::DateTime","text":"<p>Extended by: CMDx::Coercions::DateTime</p> <p>Converts various input types to DateTime format</p> <p>Handles conversion from date strings, Date objects, Time objects, and other values that can be converted to DateTime using Ruby's DateTime.parse method or custom strptime formats.</p>"},{"location":"api/CMDx/Coercions/DateTime/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/DateTime/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to a DateTime @option [] </p> <p>@param [Object] The value to convert to DateTime</p> <p>@param [Hash] Optional configuration parameters</p> <p>@raise [CoercionError] If the value cannot be converted to DateTime</p> <p>@return [DateTime] The converted DateTime value</p> <p>@example <pre><code>DateTime.call(\"2023-12-25\")               # =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\nDateTime.call(\"Dec 25, 2023\")             # =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\n</code></pre> @example <pre><code>DateTime.call(\"25/12/2023\", strptime: \"%d/%m/%Y\")\n# =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\n</code></pre> @example <pre><code>DateTime.call(Date.new(2023, 12, 25))     # =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\nDateTime.call(Time.new(2023, 12, 25))     # =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\n</code></pre></p>"},{"location":"api/CMDx/Coercions/DateTime/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/DateTime/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to a DateTime</p> <p>@option [] </p> <p>@param [Object] The value to convert to DateTime</p> <p>@param [Hash] Optional configuration parameters</p> <p>@raise [CoercionError] If the value cannot be converted to DateTime</p> <p>@return [DateTime] The converted DateTime value</p> <p>@example <pre><code>DateTime.call(\"2023-12-25\")               # =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\nDateTime.call(\"Dec 25, 2023\")             # =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\n</code></pre> @example <pre><code>DateTime.call(\"25/12/2023\", strptime: \"%d/%m/%Y\")\n# =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\n</code></pre> @example <pre><code>DateTime.call(Date.new(2023, 12, 25))     # =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\nDateTime.call(Time.new(2023, 12, 25))     # =&gt; #&lt;DateTime: 2023-12-25T00:00:00+00:00&gt;\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Float/","title":"Module: CMDx::Coercions::Float","text":"<p>Extended by: CMDx::Coercions::Float</p> <p>Converts various input types to Float format</p> <p>Handles conversion from numeric strings, integers, and other numeric types that can be converted to floats using Ruby's Float() method.</p>"},{"location":"api/CMDx/Coercions/Float/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Float/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to a Float @option [] </p> <p>@param [Object] The value to convert to a float</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to a float</p> <p>@return [Float] The converted float value</p> <p>@example <pre><code>Float.call(\"123\")        # =&gt; 123.0\nFloat.call(\"123.456\")    # =&gt; 123.456\nFloat.call(\"-42.5\")      # =&gt; -42.5\nFloat.call(\"1.23e4\")     # =&gt; 12300.0\n</code></pre> @example <pre><code>Float.call(42)           # =&gt; 42.0\nFloat.call(BigDecimal(\"123.456\")) # =&gt; 123.456\nFloat.call(Rational(3, 4))       # =&gt; 0.75\nFloat.call(Complex(5.0, 0))      # =&gt; 5.0\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Float/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Float/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to a Float</p> <p>@option [] </p> <p>@param [Object] The value to convert to a float</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to a float</p> <p>@return [Float] The converted float value</p> <p>@example <pre><code>Float.call(\"123\")        # =&gt; 123.0\nFloat.call(\"123.456\")    # =&gt; 123.456\nFloat.call(\"-42.5\")      # =&gt; -42.5\nFloat.call(\"1.23e4\")     # =&gt; 12300.0\n</code></pre> @example <pre><code>Float.call(42)           # =&gt; 42.0\nFloat.call(BigDecimal(\"123.456\")) # =&gt; 123.456\nFloat.call(Rational(3, 4))       # =&gt; 0.75\nFloat.call(Complex(5.0, 0))      # =&gt; 5.0\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Hash/","title":"Module: CMDx::Coercions::Hash","text":"<p>Extended by: CMDx::Coercions::Hash</p> <p>Coerces various input types into Hash objects</p> <p>Supports conversion from: *   Nil values (converted to empty Hash) *   Hash objects (returned as-is) *   Array objects (converted using Hash) *   JSON strings starting with \"{\" (parsed into Hash) *   Other types raise CoercionError</p>"},{"location":"api/CMDx/Coercions/Hash/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Hash/#callvalue-options","title":"call(value , options {})","text":"<p>Coerces a value into a Hash @option [] </p> <p>@param [Object] The value to coerce</p> <p>@param [Hash] Additional options (currently unused)</p> <p>@raise [CoercionError] When the value cannot be coerced to a Hash</p> <p>@return [Hash] The coerced hash value</p> <p>@example <pre><code>Hash.call({a: 1, b: 2}) # =&gt; {a: 1, b: 2}\n</code></pre> @example <pre><code>Hash.call([:a, 1, :b, 2]) # =&gt; {a: 1, b: 2}\n</code></pre> @example <pre><code>Hash.call('{\"key\": \"value\"}') # =&gt; {\"key\" =&gt; \"value\"}\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Hash/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Hash/#callvalue-options_1","title":"call(value, options{})","text":"<p>Coerces a value into a Hash</p> <p>@option [] </p> <p>@param [Object] The value to coerce</p> <p>@param [Hash] Additional options (currently unused)</p> <p>@raise [CoercionError] When the value cannot be coerced to a Hash</p> <p>@return [Hash] The coerced hash value</p> <p>@example <pre><code>Hash.call({a: 1, b: 2}) # =&gt; {a: 1, b: 2}\n</code></pre> @example <pre><code>Hash.call([:a, 1, :b, 2]) # =&gt; {a: 1, b: 2}\n</code></pre> @example <pre><code>Hash.call('{\"key\": \"value\"}') # =&gt; {\"key\" =&gt; \"value\"}\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Integer/","title":"Module: CMDx::Coercions::Integer","text":"<p>Extended by: CMDx::Coercions::Integer</p> <p>Converts various input types to Integer format</p> <p>Handles conversion from strings, numbers, and other values to integers using Ruby's Integer() method. Raises CoercionError for values that cannot be converted to integers.</p>"},{"location":"api/CMDx/Coercions/Integer/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Integer/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to an Integer @option [] </p> <p>@param [Object] The value to convert to an integer</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to an integer</p> <p>@return [Integer] The converted integer value</p> <p>@example <pre><code>Integer.call(\"42\")      # =&gt; 42\nInteger.call(\"-123\")    # =&gt; -123\nInteger.call(\"0\")       # =&gt; 0\n</code></pre> @example <pre><code>Integer.call(42.0)      # =&gt; 42\nInteger.call(3.14)      # =&gt; 3\nInteger.call(0.0)       # =&gt; 0\n</code></pre> @example <pre><code>Integer.call(\"\")        # =&gt; 0\nInteger.call(nil)       # =&gt; 0\nInteger.call(false)     # =&gt; 0\nInteger.call(true)      # =&gt; 1\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Integer/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Integer/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to an Integer</p> <p>@option [] </p> <p>@param [Object] The value to convert to an integer</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to an integer</p> <p>@return [Integer] The converted integer value</p> <p>@example <pre><code>Integer.call(\"42\")      # =&gt; 42\nInteger.call(\"-123\")    # =&gt; -123\nInteger.call(\"0\")       # =&gt; 0\n</code></pre> @example <pre><code>Integer.call(42.0)      # =&gt; 42\nInteger.call(3.14)      # =&gt; 3\nInteger.call(0.0)       # =&gt; 0\n</code></pre> @example <pre><code>Integer.call(\"\")        # =&gt; 0\nInteger.call(nil)       # =&gt; 0\nInteger.call(false)     # =&gt; 0\nInteger.call(true)      # =&gt; 1\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Rational/","title":"Module: CMDx::Coercions::Rational","text":"<p>Extended by: CMDx::Coercions::Rational</p> <p>Converts various input types to Rational format</p> <p>Handles conversion from strings, numbers, and other values to rational numbers using Ruby's Rational() method. Raises CoercionError for values that cannot be converted to rational numbers.</p>"},{"location":"api/CMDx/Coercions/Rational/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Rational/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to a Rational @option [] </p> <p>@param [Object] The value to convert to a rational number</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to a rational number</p> <p>@return [Rational] The converted rational number</p> <p>@example <pre><code>Rational.call(\"3/4\")     # =&gt; (3/4)\nRational.call(\"2.5\")     # =&gt; (5/2)\nRational.call(\"0\")       # =&gt; (0/1)\n</code></pre> @example <pre><code>Rational.call(3.14)      # =&gt; (157/50)\nRational.call(2)         # =&gt; (2/1)\nRational.call(0.5)       # =&gt; (1/2)\n</code></pre> @example <pre><code>Rational.call(\"\")        # =&gt; (0/1)\nRational.call(nil)       # =&gt; (0/1)\nRational.call(0)         # =&gt; (0/1)\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Rational/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Rational/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to a Rational</p> <p>@option [] </p> <p>@param [Object] The value to convert to a rational number</p> <p>@param [Hash] Optional configuration parameters (currently unused)</p> <p>@raise [CoercionError] If the value cannot be converted to a rational number</p> <p>@return [Rational] The converted rational number</p> <p>@example <pre><code>Rational.call(\"3/4\")     # =&gt; (3/4)\nRational.call(\"2.5\")     # =&gt; (5/2)\nRational.call(\"0\")       # =&gt; (0/1)\n</code></pre> @example <pre><code>Rational.call(3.14)      # =&gt; (157/50)\nRational.call(2)         # =&gt; (2/1)\nRational.call(0.5)       # =&gt; (1/2)\n</code></pre> @example <pre><code>Rational.call(\"\")        # =&gt; (0/1)\nRational.call(nil)       # =&gt; (0/1)\nRational.call(0)         # =&gt; (0/1)\n</code></pre></p>"},{"location":"api/CMDx/Coercions/String/","title":"Module: CMDx::Coercions::String","text":"<p>Extended by: CMDx::Coercions::String</p> <p>Coerces values to String type using Ruby's built-in String() method.</p> <p>This coercion handles various input types by converting them to their string representation. It's a simple wrapper around Ruby's String() method for consistency with the CMDx coercion interface.</p>"},{"location":"api/CMDx/Coercions/String/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/String/#callvalue-options","title":"call(value , options {})","text":"<p>Coerces a value to String type. @param [Object] The value to coerce to a string</p> <p>@param [Hash] Optional configuration parameters (unused in this coercion)</p> <p>@raise [TypeError] If the value cannot be converted to a string</p> <p>@return [String] The coerced string value</p> <p>@example <pre><code>String.call(\"hello\")           # =&gt; \"hello\"\nString.call(42)                # =&gt; \"42\"\nString.call([1, 2, 3])         # =&gt; \"[1, 2, 3]\"\nString.call(nil)               # =&gt; \"\"\nString.call(true)              # =&gt; \"true\"\n</code></pre></p>"},{"location":"api/CMDx/Coercions/String/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/String/#callvalue-options_1","title":"call(value, options{})","text":"<p>Coerces a value to String type.</p> <p>@param [Object] The value to coerce to a string</p> <p>@param [Hash] Optional configuration parameters (unused in this coercion)</p> <p>@raise [TypeError] If the value cannot be converted to a string</p> <p>@return [String] The coerced string value</p> <p>@example <pre><code>String.call(\"hello\")           # =&gt; \"hello\"\nString.call(42)                # =&gt; \"42\"\nString.call([1, 2, 3])         # =&gt; \"[1, 2, 3]\"\nString.call(nil)               # =&gt; \"\"\nString.call(true)              # =&gt; \"true\"\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Symbol/","title":"Module: CMDx::Coercions::Symbol","text":"<p>Extended by: CMDx::Coercions::Symbol</p> <p>Coerces values to Symbol type using Ruby's to_sym method.</p> <p>This coercion handles various input types by converting them to symbols. It provides error handling for values that cannot be converted to symbols and raises appropriate CMDx coercion errors with localized messages.</p>"},{"location":"api/CMDx/Coercions/Symbol/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Symbol/#callvalue-options","title":"call(value , options {})","text":"<p>Coerces a value to Symbol type. @param [Object] The value to coerce to a symbol</p> <p>@param [Hash] Optional configuration parameters (unused in this coercion)</p> <p>@raise [CoercionError] If the value cannot be converted to a symbol</p> <p>@return [Symbol] The coerced symbol value</p> <p>@example <pre><code>Symbol.call(\"hello\")           # =&gt; :hello\nSymbol.call(\"user_id\")         # =&gt; :user_id\nSymbol.call(\"\")                # =&gt; :\"\"\nSymbol.call(:existing)         # =&gt; :existing\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Symbol/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Symbol/#callvalue-options_1","title":"call(value, options{})","text":"<p>Coerces a value to Symbol type.</p> <p>@param [Object] The value to coerce to a symbol</p> <p>@param [Hash] Optional configuration parameters (unused in this coercion)</p> <p>@raise [CoercionError] If the value cannot be converted to a symbol</p> <p>@return [Symbol] The coerced symbol value</p> <p>@example <pre><code>Symbol.call(\"hello\")           # =&gt; :hello\nSymbol.call(\"user_id\")         # =&gt; :user_id\nSymbol.call(\"\")                # =&gt; :\"\"\nSymbol.call(:existing)         # =&gt; :existing\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Time/","title":"Module: CMDx::Coercions::Time","text":"<p>Extended by: CMDx::Coercions::Time</p> <p>Converts various input types to Time format</p> <p>Handles conversion from strings, dates, and other time-like objects to Time using Ruby's built-in time parsing methods. Supports custom strptime formats and raises CoercionError for values that cannot be converted to Time.</p>"},{"location":"api/CMDx/Coercions/Time/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Coercions/Time/#callvalue-options","title":"call(value , options {})","text":"<p>Converts a value to a Time object @option [] </p> <p>@param [Object] The value to convert to a Time object</p> <p>@param [Hash] Optional configuration parameters</p> <p>@raise [CoercionError] If the value cannot be converted to a Time object</p> <p>@return [Time] The converted Time object</p> <p>@example <pre><code>Time.call(Time.now)                    # =&gt; Time object (unchanged)\nTime.call(DateTime.now)                # =&gt; Time object (converted)\nTime.call(Date.today)                  # =&gt; Time object (converted)\n</code></pre> @example <pre><code>Time.call(\"2023-12-25 10:30:00\")      # =&gt; Time object\nTime.call(\"2023-12-25\")               # =&gt; Time object\nTime.call(\"10:30:00\")                 # =&gt; Time object\n</code></pre> @example <pre><code>Time.call(\"25/12/2023\", strptime: \"%d/%m/%Y\")  # =&gt; Time object\nTime.call(\"12-25-2023\", strptime: \"%m-%d-%Y\")  # =&gt; Time object\n</code></pre></p>"},{"location":"api/CMDx/Coercions/Time/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Coercions/Time/#callvalue-options_1","title":"call(value, options{})","text":"<p>Converts a value to a Time object</p> <p>@option [] </p> <p>@param [Object] The value to convert to a Time object</p> <p>@param [Hash] Optional configuration parameters</p> <p>@raise [CoercionError] If the value cannot be converted to a Time object</p> <p>@return [Time] The converted Time object</p> <p>@example <pre><code>Time.call(Time.now)                    # =&gt; Time object (unchanged)\nTime.call(DateTime.now)                # =&gt; Time object (converted)\nTime.call(Date.today)                  # =&gt; Time object (converted)\n</code></pre> @example <pre><code>Time.call(\"2023-12-25 10:30:00\")      # =&gt; Time object\nTime.call(\"2023-12-25\")               # =&gt; Time object\nTime.call(\"10:30:00\")                 # =&gt; Time object\n</code></pre> @example <pre><code>Time.call(\"25/12/2023\", strptime: \"%d/%m/%Y\")  # =&gt; Time object\nTime.call(\"12-25-2023\", strptime: \"%m-%d-%Y\")  # =&gt; Time object\n</code></pre></p>"},{"location":"api/CMDx/LogFormatters/JSON/","title":"Class: CMDx::LogFormatters::JSON","text":"<p>Inherits: Object</p> <p>Formats log messages as JSON for structured logging</p> <p>This formatter converts log entries into JSON format with standardized fields including severity, timestamp, program name, process ID, and formatted message. The output is suitable for log aggregation systems and structured analysis.</p>"},{"location":"api/CMDx/LogFormatters/JSON/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/LogFormatters/JSON/#callseverity-time-progname-message","title":"call(severity, time, progname, message)","text":"<p>Formats a log entry as a JSON string</p> <p>@param [String] The log level (e.g., \"INFO\", \"ERROR\", \"DEBUG\")</p> <p>@param [Time] The timestamp when the log entry was created</p> <p>@param [String, nil] The program name or identifier</p> <p>@param [Object] The log message content</p> <p>@return [String] A JSON-formatted log entry with a trailing newline</p> <p>@example <pre><code>logger_formatter.call(\"INFO\", Time.now, \"MyApp\", \"User logged in\")\n# =&gt; '{\"severity\":\"INFO\",\"timestamp\":\"2024-01-15T10:30:45.123456Z\",\"progname\":\"MyApp\",\"pid\":12345,\"message\":\"User logged in\"}\\n'\n</code></pre></p>"},{"location":"api/CMDx/LogFormatters/KeyValue/","title":"Class: CMDx::LogFormatters::KeyValue","text":"<p>Inherits: Object</p> <p>Formats log messages as key-value pairs for structured logging</p> <p>This formatter converts log entries into key-value format with standardized fields including severity, timestamp, program name, process ID, and formatted message. The output is suitable for log parsing tools and human-readable structured logs.</p>"},{"location":"api/CMDx/LogFormatters/KeyValue/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/LogFormatters/KeyValue/#callseverity-time-progname-message","title":"call(severity, time, progname, message)","text":"<p>Formats a log entry as a key-value string</p> <p>@param [String] The log level (e.g., \"INFO\", \"ERROR\", \"DEBUG\")</p> <p>@param [Time] The timestamp when the log entry was created</p> <p>@param [String, nil] The program name or identifier</p> <p>@param [Object] The log message content</p> <p>@return [String] A key-value formatted log entry with a trailing newline</p> <p>@example <pre><code>logger_formatter.call(\"INFO\", Time.now, \"MyApp\", \"User logged in\")\n# =&gt; \"severity=INFO timestamp=2024-01-15T10:30:45.123456Z progname=MyApp pid=12345 message=User logged in\\n\"\n</code></pre></p>"},{"location":"api/CMDx/LogFormatters/Line/","title":"Class: CMDx::LogFormatters::Line","text":"<p>Inherits: Object</p> <p>Formats log messages as single-line text for human-readable logging</p> <p>This formatter converts log entries into a compact single-line format with severity abbreviation, ISO8601 timestamp, process ID, and formatted message. The output is optimized for human readability and traditional log file formats.</p>"},{"location":"api/CMDx/LogFormatters/Line/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/LogFormatters/Line/#callseverity-time-progname-message","title":"call(severity, time, progname, message)","text":"<p>Formats a log entry as a single-line string</p> <p>@param [String] The log level (e.g., \"INFO\", \"ERROR\", \"DEBUG\")</p> <p>@param [Time] The timestamp when the log entry was created</p> <p>@param [String, nil] The program name or identifier</p> <p>@param [Object] The log message content</p> <p>@return [String] A single-line formatted log entry with a trailing newline</p> <p>@example <pre><code>logger_formatter.call(\"INFO\", Time.now, \"MyApp\", \"User logged in\")\n# =&gt; \"I, [2024-01-15T10:30:45.123456Z #12345] INFO -- MyApp: User logged in\\n\"\n</code></pre></p>"},{"location":"api/CMDx/LogFormatters/Logstash/","title":"Class: CMDx::LogFormatters::Logstash","text":"<p>Inherits: Object</p> <p>Formats log messages as Logstash-compatible JSON for structured logging</p> <p>This formatter converts log entries into Logstash-compatible JSON format with standardized fields including @version, @timestamp, severity, program name, process ID, and formatted message. The output follows Logstash event format specifications for seamless integration with ELK stack and similar systems.</p>"},{"location":"api/CMDx/LogFormatters/Logstash/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/LogFormatters/Logstash/#callseverity-time-progname-message","title":"call(severity, time, progname, message)","text":"<p>Formats a log entry as a Logstash-compatible JSON string</p> <p>@param [String] The log level (e.g., \"INFO\", \"ERROR\", \"DEBUG\")</p> <p>@param [Time] The timestamp when the log entry was created</p> <p>@param [String, nil] The program name or identifier</p> <p>@param [Object] The log message content</p> <p>@return [String] A Logstash-compatible JSON-formatted log entry with a trailing newline</p> <p>@example <pre><code>logger_formatter.call(\"INFO\", Time.now, \"MyApp\", \"User logged in\")\n# =&gt; '{\"severity\":\"INFO\",\"progname\":\"MyApp\",\"pid\":12345,\"message\":\"User logged in\",\"@version\":\"1\",\"@timestamp\":\"2024-01-15T10:30:45.123456Z\"}\\n'\n</code></pre></p>"},{"location":"api/CMDx/LogFormatters/Raw/","title":"Class: CMDx::LogFormatters::Raw","text":"<p>Inherits: Object</p> <p>Formats log messages as raw text without additional formatting</p> <p>This formatter outputs log messages in their original form with minimal processing, adding only a trailing newline. It's useful for scenarios where you want to preserve the exact message content without metadata or structured formatting.</p>"},{"location":"api/CMDx/LogFormatters/Raw/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/LogFormatters/Raw/#callseverity-time-progname-message","title":"call(severity, time, progname, message)","text":"<p>Formats a log entry as raw text</p> <p>@param [String] The log level (e.g., \"INFO\", \"ERROR\", \"DEBUG\")</p> <p>@param [Time] The timestamp when the log entry was created</p> <p>@param [String, nil] The program name or identifier</p> <p>@param [Object] The log message content</p> <p>@return [String] The raw message with a trailing newline</p> <p>@example <pre><code>logger_formatter.call(\"INFO\", Time.now, \"MyApp\", \"User logged in\")\n# =&gt; \"User logged in\\n\"\n</code></pre></p>"},{"location":"api/CMDx/Middlewares/Correlate/","title":"Module: CMDx::Middlewares::Correlate","text":"<p>Extended by: CMDx::Middlewares::Correlate</p> <p>Middleware for correlating task executions with unique identifiers.</p> <p>The Correlate middleware provides thread-safe correlation ID management for tracking task execution flows across different operations. It automatically generates correlation IDs when none are provided and stores them in task result metadata for traceability.</p>"},{"location":"api/CMDx/Middlewares/Correlate/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Middlewares/Correlate/#calltask-options","title":"call(task , **options )","text":"<p>Middleware entry point that applies correlation ID logic to task execution.</p> <p>Evaluates the condition from options and applies correlation ID handling if enabled. Generates or retrieves correlation IDs based on the :id option and stores them in task result metadata. @option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Task] The task being executed</p> <p>@param [Hash] Configuration options for correlation</p> <p>@return [Object] The result of task execution</p> <p>@yield [] The task execution block</p> <p>@example <pre><code>Correlate.call(task, &amp;block)\n</code></pre> @example <pre><code>Correlate.call(task, id: \"custom-123\", &amp;block)\n</code></pre> @example <pre><code>Correlate.call(task, id: :correlation_id, &amp;block)\n</code></pre> @example <pre><code>Correlate.call(task, id: -&gt; { \"dynamic-#{Time.now.to_i}\" }, &amp;block)\n</code></pre> @example <pre><code>Correlate.call(task, if: :enable_correlation, &amp;block)\n```## clear() [](#method-c-clear)\nClears the current correlation ID from thread-local storage.\n**@return** [nil] Always returns nil\n\n\n**@example**\n```ruby\nCorrelate.clear\n```## id() [](#method-c-id)\nRetrieves the current correlation ID from thread-local storage.\n**@return** [String, nil] The current correlation ID or nil if not set\n\n\n**@example**\n```ruby\nCorrelate.id # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n```## id=(id ) [](#method-c-id=)\nSets the correlation ID in thread-local storage.\n**@param** [String] The correlation ID to set\n\n**@return** [String] The set correlation ID\n\n\n**@example**\n```ruby\nCorrelate.id = \"abc-123-def\"\n```## use(new_id ) [](#method-c-use)\nTemporarily uses a new correlation ID for the duration of a block. Restores\nthe previous ID after the block completes, even if an error occurs.\n**@param** [String] The correlation ID to use temporarily\n\n**@return** [Object] The result of the yielded block\n\n**@yield** [] The block to execute with the new correlation ID\n\n\n**@example**\n```ruby\nCorrelate.use(\"temp-id\") do\n  # Operations here use \"temp-id\"\n  perform_operation\nend\n# Previous ID is restored\n</code></pre></p>"},{"location":"api/CMDx/Middlewares/Correlate/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Middlewares/Correlate/#calltask-options_1","title":"call(task, **options)","text":"<p>Middleware entry point that applies correlation ID logic to task execution.</p> <p>Evaluates the condition from options and applies correlation ID handling if enabled. Generates or retrieves correlation IDs based on the :id option and stores them in task result metadata.</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Task] The task being executed</p> <p>@param [Hash] Configuration options for correlation</p> <p>@return [Object] The result of task execution</p> <p>@yield [] The task execution block</p> <p>@example <pre><code>Correlate.call(task, &amp;block)\n</code></pre> @example <pre><code>Correlate.call(task, id: \"custom-123\", &amp;block)\n</code></pre> @example <pre><code>Correlate.call(task, id: :correlation_id, &amp;block)\n</code></pre> @example <pre><code>Correlate.call(task, id: -&gt; { \"dynamic-#{Time.now.to_i}\" }, &amp;block)\n</code></pre> @example <pre><code>Correlate.call(task, if: :enable_correlation, &amp;block)\n```## clear() [](#method-i-clear)\nClears the current correlation ID from thread-local storage.\n\n**@return** [nil] Always returns nil\n\n\n**@example**\n```ruby\nCorrelate.clear\n```## id() [](#method-i-id)\nRetrieves the current correlation ID from thread-local storage.\n\n**@return** [String, nil] The current correlation ID or nil if not set\n\n\n**@example**\n```ruby\nCorrelate.id # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n```## id=(id) [](#method-i-id=)\nSets the correlation ID in thread-local storage.\n\n**@param** [String] The correlation ID to set\n\n**@return** [String] The set correlation ID\n\n\n**@example**\n```ruby\nCorrelate.id = \"abc-123-def\"\n```## use(new_id) [](#method-i-use)\nTemporarily uses a new correlation ID for the duration of a block. Restores\nthe previous ID after the block completes, even if an error occurs.\n\n**@param** [String] The correlation ID to use temporarily\n\n**@return** [Object] The result of the yielded block\n\n**@yield** [] The block to execute with the new correlation ID\n\n\n**@example**\n```ruby\nCorrelate.use(\"temp-id\") do\n  # Operations here use \"temp-id\"\n  perform_operation\nend\n# Previous ID is restored\n</code></pre></p>"},{"location":"api/CMDx/Middlewares/Runtime/","title":"Module: CMDx::Middlewares::Runtime","text":"<p>Extended by: CMDx::Middlewares::Runtime</p> <p>Middleware for measuring task execution runtime.</p> <p>The Runtime middleware provides performance monitoring by measuring the execution time of tasks using monotonic clock for accuracy. It stores runtime measurements in task result metadata for analysis.</p>"},{"location":"api/CMDx/Middlewares/Runtime/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Middlewares/Runtime/#calltask-options","title":"call(task , **options )","text":"<p>Middleware entry point that measures task execution runtime.</p> <p>Evaluates the condition from options and measures execution time if enabled. Uses monotonic clock for precise timing measurements and stores the result in task metadata. @option [] </p> <p>@option [] </p> <p>@param [Task] The task being executed</p> <p>@param [Hash] Configuration options for runtime measurement</p> <p>@return [Object] The result of task execution</p> <p>@yield [] The task execution block</p> <p>@example <pre><code>Runtime.call(task, &amp;block)\n</code></pre> @example <pre><code>Runtime.call(task, if: :enable_profiling, &amp;block)\n</code></pre> @example <pre><code>Runtime.call(task, unless: :skip_profiling, &amp;block)\n</code></pre></p>"},{"location":"api/CMDx/Middlewares/Runtime/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Middlewares/Runtime/#calltask-options_1","title":"call(task, **options)","text":"<p>Middleware entry point that measures task execution runtime.</p> <p>Evaluates the condition from options and measures execution time if enabled. Uses monotonic clock for precise timing measurements and stores the result in task metadata.</p> <p>@option [] </p> <p>@option [] </p> <p>@param [Task] The task being executed</p> <p>@param [Hash] Configuration options for runtime measurement</p> <p>@return [Object] The result of task execution</p> <p>@yield [] The task execution block</p> <p>@example <pre><code>Runtime.call(task, &amp;block)\n</code></pre> @example <pre><code>Runtime.call(task, if: :enable_profiling, &amp;block)\n</code></pre> @example <pre><code>Runtime.call(task, unless: :skip_profiling, &amp;block)\n</code></pre></p>"},{"location":"api/CMDx/Middlewares/Timeout/","title":"Module: CMDx::Middlewares::Timeout","text":"<p>Extended by: CMDx::Middlewares::Timeout</p> <p>Middleware for enforcing execution time limits on tasks.</p> <p>The Timeout middleware provides execution time control by wrapping task execution with Ruby's Timeout module. It automatically fails tasks that exceed the configured time limit and provides detailed error information including the exceeded limit.</p>"},{"location":"api/CMDx/Middlewares/Timeout/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Middlewares/Timeout/#calltask-options","title":"call(task , **options )","text":"<p>Middleware entry point that enforces execution time limits.</p> <p>Evaluates the condition from options and applies timeout control if enabled. Supports various timeout limit configurations including numeric values, task method calls, and dynamic proc evaluation. @option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Task] The task being executed</p> <p>@param [Hash] Configuration options for timeout control</p> <p>@raise [TimeoutError] When execution exceeds the configured limit</p> <p>@return [Object] The result of task execution</p> <p>@yield [] The task execution block</p> <p>@example <pre><code>Timeout.call(task, &amp;block)\n</code></pre> @example <pre><code>Timeout.call(task, seconds: 10, &amp;block)\n</code></pre> @example <pre><code>Timeout.call(task, seconds: :timeout_limit, &amp;block)\n</code></pre> @example <pre><code>Timeout.call(task, seconds: -&gt; { calculate_timeout }, &amp;block)\n</code></pre> @example <pre><code>Timeout.call(task, if: :enable_timeout, &amp;block)\n</code></pre></p>"},{"location":"api/CMDx/Middlewares/Timeout/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Middlewares/Timeout/#calltask-options_1","title":"call(task, **options)","text":"<p>Middleware entry point that enforces execution time limits.</p> <p>Evaluates the condition from options and applies timeout control if enabled. Supports various timeout limit configurations including numeric values, task method calls, and dynamic proc evaluation.</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Task] The task being executed</p> <p>@param [Hash] Configuration options for timeout control</p> <p>@raise [TimeoutError] When execution exceeds the configured limit</p> <p>@return [Object] The result of task execution</p> <p>@yield [] The task execution block</p> <p>@example <pre><code>Timeout.call(task, &amp;block)\n</code></pre> @example <pre><code>Timeout.call(task, seconds: 10, &amp;block)\n</code></pre> @example <pre><code>Timeout.call(task, seconds: :timeout_limit, &amp;block)\n</code></pre> @example <pre><code>Timeout.call(task, seconds: -&gt; { calculate_timeout }, &amp;block)\n</code></pre> @example <pre><code>Timeout.call(task, if: :enable_timeout, &amp;block)\n</code></pre></p>"},{"location":"api/CMDx/Utils/Call/","title":"Module: CMDx::Utils::Call","text":"<p>Extended by: CMDx::Utils::Call</p> <p>Utility module for invoking callable objects with different invocation strategies.</p> <p>This module provides a unified interface for calling methods, procs, and other callable objects on target objects, handling the appropriate invocation method based on the callable type.</p>"},{"location":"api/CMDx/Utils/Call/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Utils/Call/#invoketarget-callable-args-kwargs","title":"invoke(target , callable , args , *kwargs )","text":"<p>Invokes a callable object on the target with the given arguments. @param [Object] The target object to invoke the callable on</p> <p>@param [Symbol, Proc, #call] The callable to invoke</p> <p>@param [Array] Positional arguments to pass to the callable</p> <p>@param [Hash] Keyword arguments to pass to the callable</p> <p>@param [Proc, nil] Block to pass to the callable</p> <p>@raise [RuntimeError] When the callable cannot be invoked</p> <p>@return [Object] The result of invoking the callable</p> <p>@example <pre><code>Call.invoke(user, :name)\nCall.invoke(user, :update, { name: 'John' })\n</code></pre> @example <pre><code>proc = -&gt;(name) { \"Hello #{name}\" }\nCall.invoke(user, proc, 'John')\n</code></pre> @example <pre><code>callable = MyCallable.new\nCall.invoke(user, callable, 'data')\n</code></pre></p>"},{"location":"api/CMDx/Utils/Call/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Utils/Call/#invoketarget-callable-args-kwargs_1","title":"invoke(target, callable, args, *kwargs)","text":"<p>Invokes a callable object on the target with the given arguments.</p> <p>@param [Object] The target object to invoke the callable on</p> <p>@param [Symbol, Proc, #call] The callable to invoke</p> <p>@param [Array] Positional arguments to pass to the callable</p> <p>@param [Hash] Keyword arguments to pass to the callable</p> <p>@param [Proc, nil] Block to pass to the callable</p> <p>@raise [RuntimeError] When the callable cannot be invoked</p> <p>@return [Object] The result of invoking the callable</p> <p>@example <pre><code>Call.invoke(user, :name)\nCall.invoke(user, :update, { name: 'John' })\n</code></pre> @example <pre><code>proc = -&gt;(name) { \"Hello #{name}\" }\nCall.invoke(user, proc, 'John')\n</code></pre> @example <pre><code>callable = MyCallable.new\nCall.invoke(user, callable, 'data')\n</code></pre></p>"},{"location":"api/CMDx/Utils/Condition/","title":"Module: CMDx::Utils::Condition","text":"<p>Extended by: CMDx::Utils::Condition</p> <p>Provides conditional evaluation utilities for CMDx tasks and workflows.</p> <p>This module handles conditional logic evaluation with support for <code>if</code> and <code>unless</code> conditions using various callable types including symbols, procs, and objects responding to <code>call</code>.</p>"},{"location":"api/CMDx/Utils/Condition/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Utils/Condition/#evaluatetarget-options","title":"evaluate(target , options )","text":"<p>Evaluates conditional logic based on provided options.</p> <p>Supports both <code>if</code> and <code>unless</code> conditions, with <code>unless</code> taking precedence when both are specified. Returns true if no conditions are provided. @option [] </p> <p>@option [] </p> <p>@param [Object] The target object to evaluate conditions against</p> <p>@param [Hash] Conditional options hash</p> <p>@param [Array] Additional arguments passed to condition evaluation</p> <p>@param [Hash] Additional keyword arguments passed to condition evaluation</p> <p>@param [Proc, nil] Optional block passed to condition evaluation</p> <p>@raise [RuntimeError] When a callable cannot be evaluated</p> <p>@return [Boolean] true if conditions are met, false otherwise</p> <p>@example <pre><code>Condition.evaluate(user, if: :active?)\n# =&gt; true if user.active? returns true\n</code></pre> @example <pre><code>Condition.evaluate(user, unless: :blocked?)\n# =&gt; true if user.blocked? returns false\n</code></pre> @example <pre><code>Condition.evaluate(user, if: :verified?, unless: :suspended?)\n# =&gt; true if user.verified? is true AND user.suspended? is false\n</code></pre> @example <pre><code>Condition.evaluate(user, if: -&gt;(u) { u.has_permission?(:admin) }, :admin)\n# =&gt; true if the proc returns true when called with user and :admin\n</code></pre></p>"},{"location":"api/CMDx/Utils/Condition/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Utils/Condition/#evaluatetarget-options_1","title":"evaluate(target, options)","text":"<p>Evaluates conditional logic based on provided options.</p> <p>Supports both <code>if</code> and <code>unless</code> conditions, with <code>unless</code> taking precedence when both are specified. Returns true if no conditions are provided.</p> <p>@option [] </p> <p>@option [] </p> <p>@param [Object] The target object to evaluate conditions against</p> <p>@param [Hash] Conditional options hash</p> <p>@param [Array] Additional arguments passed to condition evaluation</p> <p>@param [Hash] Additional keyword arguments passed to condition evaluation</p> <p>@param [Proc, nil] Optional block passed to condition evaluation</p> <p>@raise [RuntimeError] When a callable cannot be evaluated</p> <p>@return [Boolean] true if conditions are met, false otherwise</p> <p>@example <pre><code>Condition.evaluate(user, if: :active?)\n# =&gt; true if user.active? returns true\n</code></pre> @example <pre><code>Condition.evaluate(user, unless: :blocked?)\n# =&gt; true if user.blocked? returns false\n</code></pre> @example <pre><code>Condition.evaluate(user, if: :verified?, unless: :suspended?)\n# =&gt; true if user.verified? is true AND user.suspended? is false\n</code></pre> @example <pre><code>Condition.evaluate(user, if: -&gt;(u) { u.has_permission?(:admin) }, :admin)\n# =&gt; true if the proc returns true when called with user and :admin\n</code></pre></p>"},{"location":"api/CMDx/Utils/Format/","title":"Module: CMDx::Utils::Format","text":"<p>Extended by: CMDx::Utils::Format</p> <p>Utility module for formatting data structures into log-friendly strings and converting messages to appropriate formats for logging</p>"},{"location":"api/CMDx/Utils/Format/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Utils/Format/#to_logmessage","title":"to_log(message )","text":"<p>Converts a message to a format suitable for logging @param [Object] The message to format</p> <p>@return [Hash, Object] Returns a hash if the message responds to to_h and is a CMDx object, otherwise returns the original message</p> <p>@example <pre><code>Format.to_log({user_id: 123, action: \"login\"})\n# =&gt; {user_id: 123, action: \"login\"}\n</code></pre> @example <pre><code>Format.to_log(\"simple message\")\n# =&gt; \"simple message\"\n</code></pre> @example <pre><code>Format.to_log(CMDx::Task.new(name: \"task1\"))\n# =&gt; {name: \"task1\"}\n```## to_str(hash , &amp;block ) [](#method-c-to_str)\nConverts a hash to a formatted string using a custom formatter\n**@option** [] \n\n**@option** [] \n\n**@param** [Hash] The hash to convert to string\n\n**@param** [Proc, nil] Optional custom formatter block\n\n**@return** [String] Space-separated formatted key-value pairs\n\n\n**@example**\n```ruby\nFormat.to_str({user_id: 123, status: \"active\"})\n# =&gt; \"user_id=123 status=\\\"active\\\"\"\n</code></pre> @example <pre><code>Format.to_str({count: 5, total: 100}) { |k, v| \"#{k}:#{v}\" }\n# =&gt; \"count:5 total:100\"\n</code></pre></p>"},{"location":"api/CMDx/Utils/Format/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Utils/Format/#to_logmessage_1","title":"to_log(message)","text":"<p>Converts a message to a format suitable for logging</p> <p>@param [Object] The message to format</p> <p>@return [Hash, Object] Returns a hash if the message responds to to_h and is a CMDx object, otherwise returns the original message</p> <p>@example <pre><code>Format.to_log({user_id: 123, action: \"login\"})\n# =&gt; {user_id: 123, action: \"login\"}\n</code></pre> @example <pre><code>Format.to_log(\"simple message\")\n# =&gt; \"simple message\"\n</code></pre> @example <pre><code>Format.to_log(CMDx::Task.new(name: \"task1\"))\n# =&gt; {name: \"task1\"}\n```## to_str(hash, &amp;block) [](#method-i-to_str)\nConverts a hash to a formatted string using a custom formatter\n\n**@option** [] \n\n**@option** [] \n\n**@param** [Hash] The hash to convert to string\n\n**@param** [Proc, nil] Optional custom formatter block\n\n**@return** [String] Space-separated formatted key-value pairs\n\n\n**@example**\n```ruby\nFormat.to_str({user_id: 123, status: \"active\"})\n# =&gt; \"user_id=123 status=\\\"active\\\"\"\n</code></pre> @example <pre><code>Format.to_str({count: 5, total: 100}) { |k, v| \"#{k}:#{v}\" }\n# =&gt; \"count:5 total:100\"\n</code></pre></p>"},{"location":"api/CMDx/Validators/Exclusion/","title":"Module: CMDx::Validators::Exclusion","text":"<p>Extended by: CMDx::Validators::Exclusion</p> <p>Validates that a value is not included in a specified set or range</p> <p>This validator ensures that the given value is excluded from a collection of forbidden values or falls outside a specified range. It supports both discrete value lists and range-based exclusions.</p>"},{"location":"api/CMDx/Validators/Exclusion/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Validators/Exclusion/#callvalue-options","title":"call(value , options {})","text":"<p>Validates that a value is excluded from the specified options @option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Object] The value to validate for exclusion</p> <p>@param [Hash] Validation configuration options</p> <p>@raise [ValidationError] When the value is found in the forbidden collection</p> <p>@example <pre><code>Exclusion.call(\"admin\", in: [\"admin\", \"root\", \"superuser\"])\n# =&gt; raises ValidationError if value is \"admin\"\n</code></pre> @example <pre><code>Exclusion.call(5, in: 1..10)\n# =&gt; raises ValidationError if value is 5 (within 1..10)\n</code></pre> @example <pre><code>Exclusion.call(\"test\", in: [\"test\", \"demo\"], message: \"value %{values} is forbidden\")\n</code></pre></p>"},{"location":"api/CMDx/Validators/Exclusion/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Validators/Exclusion/#callvalue-options_1","title":"call(value, options{})","text":"<p>Validates that a value is excluded from the specified options</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Object] The value to validate for exclusion</p> <p>@param [Hash] Validation configuration options</p> <p>@raise [ValidationError] When the value is found in the forbidden collection</p> <p>@example <pre><code>Exclusion.call(\"admin\", in: [\"admin\", \"root\", \"superuser\"])\n# =&gt; raises ValidationError if value is \"admin\"\n</code></pre> @example <pre><code>Exclusion.call(5, in: 1..10)\n# =&gt; raises ValidationError if value is 5 (within 1..10)\n</code></pre> @example <pre><code>Exclusion.call(\"test\", in: [\"test\", \"demo\"], message: \"value %{values} is forbidden\")\n</code></pre></p>"},{"location":"api/CMDx/Validators/Format/","title":"Module: CMDx::Validators::Format","text":"<p>Extended by: CMDx::Validators::Format</p> <p>Validates that a value matches a specified format pattern</p> <p>This validator ensures that the given value conforms to a specific format using regular expressions. It supports both direct regex matching and conditional matching with inclusion/exclusion patterns.</p>"},{"location":"api/CMDx/Validators/Format/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Validators/Format/#callvalue-options","title":"call(value , options {})","text":"<p>Validates that a value matches the specified format pattern @option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Object] The value to validate for format compliance</p> <p>@param [Hash, Regexp] Validation configuration options or direct regex pattern</p> <p>@raise [ValidationError] When the value doesn't match the required format</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Format.call(\"user@example.com\", /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Format.call(\"ABC123\", with: /\\A[A-Z]{3}\\d{3}\\z/)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Format.call(\"hello\", without: /\\d/)\n# =&gt; nil (validation passes - no digits)\n</code></pre> @example <pre><code>Format.call(\"test123\", with: /\\A\\w+\\z/, without: /\\A\\d+\\z/)\n# =&gt; nil (validation passes - alphanumeric but not all digits)\n</code></pre> @example <pre><code>Format.call(\"invalid\", with: /\\A\\d+\\z/, message: \"Must contain only digits\")\n# =&gt; raises ValidationError with custom message\n</code></pre></p>"},{"location":"api/CMDx/Validators/Format/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Validators/Format/#callvalue-options_1","title":"call(value, options{})","text":"<p>Validates that a value matches the specified format pattern</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Object] The value to validate for format compliance</p> <p>@param [Hash, Regexp] Validation configuration options or direct regex pattern</p> <p>@raise [ValidationError] When the value doesn't match the required format</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Format.call(\"user@example.com\", /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Format.call(\"ABC123\", with: /\\A[A-Z]{3}\\d{3}\\z/)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Format.call(\"hello\", without: /\\d/)\n# =&gt; nil (validation passes - no digits)\n</code></pre> @example <pre><code>Format.call(\"test123\", with: /\\A\\w+\\z/, without: /\\A\\d+\\z/)\n# =&gt; nil (validation passes - alphanumeric but not all digits)\n</code></pre> @example <pre><code>Format.call(\"invalid\", with: /\\A\\d+\\z/, message: \"Must contain only digits\")\n# =&gt; raises ValidationError with custom message\n</code></pre></p>"},{"location":"api/CMDx/Validators/Inclusion/","title":"Module: CMDx::Validators::Inclusion","text":"<p>Extended by: CMDx::Validators::Inclusion</p> <p>Validates that a value is included in a specified set or range</p> <p>This validator ensures that the given value is present within a collection of allowed values or falls within a specified range. It supports both discrete value lists and range-based validations.</p>"},{"location":"api/CMDx/Validators/Inclusion/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Validators/Inclusion/#callvalue-options","title":"call(value , options {})","text":"<p>Validates that a value is included in the specified options @option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Object] The value to validate for inclusion</p> <p>@param [Hash] Validation configuration options</p> <p>@raise [ValidationError] When the value is not found in the allowed collection</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Inclusion.call(\"admin\", in: [\"admin\", \"user\", \"guest\"])\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Inclusion.call(5, in: 1..10)\n# =&gt; nil (validation passes - 5 is within 1..10)\n</code></pre> @example <pre><code>Inclusion.call(\"test\", in: [\"admin\", \"user\"], message: \"must be one of: %{values}\")\n</code></pre></p>"},{"location":"api/CMDx/Validators/Inclusion/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Validators/Inclusion/#callvalue-options_1","title":"call(value, options{})","text":"<p>Validates that a value is included in the specified options</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Object] The value to validate for inclusion</p> <p>@param [Hash] Validation configuration options</p> <p>@raise [ValidationError] When the value is not found in the allowed collection</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Inclusion.call(\"admin\", in: [\"admin\", \"user\", \"guest\"])\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Inclusion.call(5, in: 1..10)\n# =&gt; nil (validation passes - 5 is within 1..10)\n</code></pre> @example <pre><code>Inclusion.call(\"test\", in: [\"admin\", \"user\"], message: \"must be one of: %{values}\")\n</code></pre></p>"},{"location":"api/CMDx/Validators/Length/","title":"Module: CMDx::Validators::Length","text":"<p>Extended by: CMDx::Validators::Length</p> <p>Validates the length of a value against various constraints.</p> <p>This validator supports multiple length validation strategies including exact length, minimum/maximum bounds, and range-based validation. It can be used to ensure values meet specific length requirements for strings, arrays, and other enumerable objects.</p>"},{"location":"api/CMDx/Validators/Length/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Validators/Length/#callvalue-options","title":"call(value , options {})","text":"<p>Validates a value's length against specified constraints. @option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [String, Array, Hash, Object] The value to validate (must respond to #length)</p> <p>@param [Hash] Validation options</p> <p>@raise [ValidationError] When validation fails</p> <p>@raise [ArgumentError] When unknown validation options are provided</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Length.call(\"hello\", is: 5)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Length.call(\"test\", within: 3..6)\n# =&gt; nil (validation passes - length 4 is within range)\n</code></pre> @example <pre><code>Length.call(\"username\", min: 3, max: 20)\n# =&gt; nil (validation passes - length 8 is between 3 and 20)\n</code></pre> @example <pre><code>Length.call(\"short\", not_in: 1..3)\n# =&gt; nil (validation passes - length 5 is not in excluded range)\n</code></pre></p>"},{"location":"api/CMDx/Validators/Length/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Validators/Length/#callvalue-options_1","title":"call(value, options{})","text":"<p>Validates a value's length against specified constraints.</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [String, Array, Hash, Object] The value to validate (must respond to #length)</p> <p>@param [Hash] Validation options</p> <p>@raise [ValidationError] When validation fails</p> <p>@raise [ArgumentError] When unknown validation options are provided</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Length.call(\"hello\", is: 5)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Length.call(\"test\", within: 3..6)\n# =&gt; nil (validation passes - length 4 is within range)\n</code></pre> @example <pre><code>Length.call(\"username\", min: 3, max: 20)\n# =&gt; nil (validation passes - length 8 is between 3 and 20)\n</code></pre> @example <pre><code>Length.call(\"short\", not_in: 1..3)\n# =&gt; nil (validation passes - length 5 is not in excluded range)\n</code></pre></p>"},{"location":"api/CMDx/Validators/Numeric/","title":"Module: CMDx::Validators::Numeric","text":"<p>Extended by: CMDx::Validators::Numeric</p> <p>Validates numeric values against various constraints and ranges</p> <p>This validator ensures that numeric values meet specified criteria such as minimum/maximum bounds, exact matches, or range inclusions. It supports both inclusive and exclusive range validations with customizable error messages.</p>"},{"location":"api/CMDx/Validators/Numeric/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Validators/Numeric/#callvalue-options","title":"call(value , options {})","text":"<p>Validates a numeric value against the specified options @option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Numeric] The numeric value to validate</p> <p>@param [Hash] Validation configuration options</p> <p>@raise [ValidationError] When the value fails validation</p> <p>@raise [ArgumentError] When unknown validator options are provided</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Numeric.call(5, within: 1..10)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Numeric.call(15, min: 10, max: 20)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Numeric.call(42, is: 42)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Numeric.call(5, not_in: 1..10)\n# =&gt; nil (validation passes - 5 is not in 1..10)\n</code></pre></p>"},{"location":"api/CMDx/Validators/Numeric/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Validators/Numeric/#callvalue-options_1","title":"call(value, options{})","text":"<p>Validates a numeric value against the specified options</p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@option [] </p> <p>@param [Numeric] The numeric value to validate</p> <p>@param [Hash] Validation configuration options</p> <p>@raise [ValidationError] When the value fails validation</p> <p>@raise [ArgumentError] When unknown validator options are provided</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Numeric.call(5, within: 1..10)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Numeric.call(15, min: 10, max: 20)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Numeric.call(42, is: 42)\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Numeric.call(5, not_in: 1..10)\n# =&gt; nil (validation passes - 5 is not in 1..10)\n</code></pre></p>"},{"location":"api/CMDx/Validators/Presence/","title":"Module: CMDx::Validators::Presence","text":"<p>Extended by: CMDx::Validators::Presence</p> <p>Validates that a value is present and not empty</p> <p>This validator ensures that the given value exists and contains meaningful content. It handles different value types appropriately: *   Strings: checks for non-whitespace characters *   Collections: checks for non-empty collections *   Other objects: checks for non-nil values</p>"},{"location":"api/CMDx/Validators/Presence/#class-methods","title":"Class Methods","text":""},{"location":"api/CMDx/Validators/Presence/#callvalue-options","title":"call(value , options {})","text":"<p>Validates that a value is present and not empty @option [] </p> <p>@param [Object] The value to validate for presence</p> <p>@param [Hash] Validation configuration options</p> <p>@raise [ValidationError] When the value is empty, nil, or contains only whitespace</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Presence.call(\"hello world\")\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Presence.call(\"   \")\n# =&gt; raises ValidationError\n</code></pre> @example <pre><code>Presence.call([1, 2, 3])\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Presence.call([])\n# =&gt; raises ValidationError\n</code></pre> @example <pre><code>Presence.call(nil, message: \"Value cannot be blank\")\n# =&gt; raises ValidationError with custom message\n</code></pre></p>"},{"location":"api/CMDx/Validators/Presence/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Validators/Presence/#callvalue-options_1","title":"call(value, options{})","text":"<p>Validates that a value is present and not empty</p> <p>@option [] </p> <p>@param [Object] The value to validate for presence</p> <p>@param [Hash] Validation configuration options</p> <p>@raise [ValidationError] When the value is empty, nil, or contains only whitespace</p> <p>@return [nil] Returns nil if validation passes</p> <p>@example <pre><code>Presence.call(\"hello world\")\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Presence.call(\"   \")\n# =&gt; raises ValidationError\n</code></pre> @example <pre><code>Presence.call([1, 2, 3])\n# =&gt; nil (validation passes)\n</code></pre> @example <pre><code>Presence.call([])\n# =&gt; raises ValidationError\n</code></pre> @example <pre><code>Presence.call(nil, message: \"Value cannot be blank\")\n# =&gt; raises ValidationError with custom message\n</code></pre></p>"},{"location":"api/CMDx/Workflow/ClassMethods/","title":"Module: CMDx::Workflow::ClassMethods","text":""},{"location":"api/CMDx/Workflow/ClassMethods/#instance-methods","title":"Instance Methods","text":""},{"location":"api/CMDx/Workflow/ClassMethods/#method_addedmethod_name","title":"method_added(method_name)","text":"<p>Prevents redefinition of the work method to maintain workflow integrity.</p> <p>@param [Symbol] The name of the method being added</p> <p>@raise [RuntimeError] If attempting to redefine the work method</p> <p>@example <pre><code>class MyWorkflow\n  include CMDx::Workflow\n  # This would raise an error:\n  # def work; end\nend\n```## pipeline() [](#method-i-pipeline)\nReturns the collection of execution groups for this workflow.\n\n**@return** [Array&lt;ExecutionGroup&gt;] Array of execution groups\n\n\n**@example**\n```ruby\nclass MyWorkflow\n  include CMDx::Workflow\n  task Task1\n  task Task2\n  puts pipeline.size # =&gt; 2\nend\n```## tasks(*tasks, **options) [](#method-i-tasks)\nAdds multiple tasks to the workflow with optional configuration.\n\n**@option** [] \n\n**@option** [] \n\n**@param** [Array&lt;Class&gt;] Array of task classes to add\n\n**@param** [Hash] Configuration options for the task execution\n\n**@raise** [TypeError] If any task is not a CMDx::Task subclass\n\n\n**@example**\n```ruby\nclass MyWorkflow\n  include CMDx::Workflow\n  tasks ValidateTask, ProcessTask, NotifyTask, breakpoints: [:failure, :halt]\nend\n</code></pre></p>"},{"location":"api/CMDx/Workflow/ExecutionGroup/","title":"Class: CMDx::Workflow::ExecutionGroup","text":"<p>Inherits: Struct</p> <p>Represents a group of tasks with shared execution options.</p> <p>@attr [Array] Array of task classes in this group <p>@attr [Hash] Configuration options for the group</p>"},{"location":"api/CMDx/Workflow/ExecutionGroup/#attributes","title":"Attributes","text":""},{"location":"api/CMDx/Workflow/ExecutionGroup/#optionsrw","title":"options[RW]","text":"<p>Configuration options for the group</p> <p>@return [Hash] the current value of options</p>"},{"location":"api/CMDx/Workflow/ExecutionGroup/#tasksrw","title":"tasks[RW]","text":"<p>Array of task classes in this group</p> <p>@return [Array] the current value of tasks"},{"location":"attributes/coercions/","title":"Attributes - Coercions","text":"<p>Automatically convert inputs to expected types. Coercions handle everything from simple string-to-integer conversions to JSON parsing.</p> <p>See Global Configuration for custom coercion setup.</p>"},{"location":"attributes/coercions/#usage","title":"Usage","text":"<p>Define attribute types to enable automatic coercion:</p> <pre><code>class ParseMetrics &lt; CMDx::Task\n  # Coerce into a symbol\n  attribute :measurement_type, type: :symbol\n\n  # Coerce into a rational fallback to big decimal\n  attribute :value, type: [:rational, :big_decimal]\n\n  # Coerce with options\n  attribute :recorded_at, type: :date, strptime: \"%m-%d-%Y\"\n\n  def work\n    measurement_type #=&gt; :temperature\n    recorded_at      #=&gt; &lt;Date 2024-01-23&gt;\n    value            #=&gt; 98.6 (Float)\n  end\nend\n\nParseMetrics.execute(\n  measurement_type: \"temperature\",\n  recorded_at: \"01-23-2020\",\n  value: \"98.6\"\n)\n</code></pre> <p>Tip</p> <p>Specify multiple coercion types for attributes that could be a variety of value formats. CMDx attempts each type in order until one succeeds.</p>"},{"location":"attributes/coercions/#built-in-coercions","title":"Built-in Coercions","text":"Type Options Description Examples <code>:array</code> Array conversion with JSON support <code>\"val\"</code> \u2192 <code>[\"val\"]</code><code>\"[1,2,3]\"</code> \u2192 <code>[1, 2, 3]</code> <code>:big_decimal</code> <code>:precision</code> High-precision decimal <code>\"123.456\"</code> \u2192 <code>BigDecimal(\"123.456\")</code> <code>:boolean</code> Boolean with text patterns <code>\"yes\"</code> \u2192 <code>true</code>, <code>\"no\"</code> \u2192 <code>false</code> <code>:complex</code> Complex numbers <code>\"1+2i\"</code> \u2192 <code>Complex(1, 2)</code> <code>:date</code> <code>:strptime</code> Date objects <code>\"2024-01-23\"</code> \u2192 <code>Date.new(2024, 1, 23)</code> <code>:datetime</code> <code>:strptime</code> DateTime objects <code>\"2024-01-23 10:30\"</code> \u2192 <code>DateTime.new(2024, 1, 23, 10, 30)</code> <code>:float</code> Floating-point numbers <code>\"123.45\"</code> \u2192 <code>123.45</code> <code>:hash</code> Hash conversion with JSON support <code>'{\"a\":1}'</code> \u2192 <code>{\"a\" =&gt; 1}</code> <code>:integer</code> Integer with hex/octal support <code>\"0xFF\"</code> \u2192 <code>255</code>, <code>\"077\"</code> \u2192 <code>63</code> <code>:rational</code> Rational numbers <code>\"1/2\"</code> \u2192 <code>Rational(1, 2)</code> <code>:string</code> String conversion <code>123</code> \u2192 <code>\"123\"</code> <code>:symbol</code> Symbol conversion <code>\"abc\"</code> \u2192 <code>:abc</code> <code>:time</code> <code>:strptime</code> Time objects <code>\"10:30:00\"</code> \u2192 <code>Time.new(2024, 1, 23, 10, 30)</code>"},{"location":"attributes/coercions/#declarations","title":"Declarations","text":"<p>Important</p> <p>Custom coercions must raise <code>CMDx::CoercionError</code> with a descriptive message.</p>"},{"location":"attributes/coercions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple coercion logic:</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  # Proc\n  register :callback, :geolocation, proc do |value, options = {}|\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  end\n\n  # Lambda\n  register :callback, :geolocation, -&gt;(value, options = {}) {\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/coercions/#class-or-module","title":"Class or Module","text":"<p>Register custom coercion logic for specialized type handling:</p> <pre><code>class GeolocationCoercion\n  def self.call(value, options = {})\n    Geolocation(value)\n  rescue StandardError\n    raise CMDx::CoercionError, \"could not convert into a geolocation\"\n  end\nend\n\nclass TransformCoordinates &lt; CMDx::Task\n  register :coercion, :geolocation, GeolocationCoercion\n\n  attribute :latitude, type: :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#removals","title":"Removals","text":"<p>Remove unwanted coercions:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one coercion. Use multiple calls for batch removals.</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  deregister :coercion, :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#error-handling","title":"Error Handling","text":"<p>Coercion failures provide detailed error information including attribute paths, attempted types, and specific failure reasons:</p> <pre><code>class AnalyzePerformance &lt; CMDx::Task\n  attribute  :iterations, type: :integer\n  attribute  :score, type: [:float, :big_decimal]\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = AnalyzePerformance.execute(\n  iterations: \"not-a-number\",\n  score: \"invalid-float\"\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"iterations could not coerce into an integer. score could not coerce into one of: float, big_decimal.\",\n                #       messages: {\n                #         iterations: [\"could not coerce into an integer\"],\n                #         score: [\"could not coerce into one of: float, big_decimal\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/defaults/","title":"Attributes - Defaults","text":"<p>Provide fallback values for optional attributes. Defaults kick in when values aren't provided or are <code>nil</code>.</p>"},{"location":"attributes/defaults/#declarations","title":"Declarations","text":"<p>Defaults work seamlessly with coercions, validations, and nested attributes:</p>"},{"location":"attributes/defaults/#static-values","title":"Static Values","text":"<pre><code>class OptimizeDatabase &lt; CMDx::Task\n  attribute :strategy, default: :incremental\n  attribute :level, default: \"basic\"\n  attribute :notify_admin, default: true\n  attribute :timeout_minutes, default: 30\n  attribute :indexes, default: []\n  attribute :options, default: {}\n\n  def work\n    strategy        #=&gt; :incremental\n    level           #=&gt; \"basic\"\n    notify_admin    #=&gt; true\n    timeout_minutes #=&gt; 30\n    indexes         #=&gt; []\n    options         #=&gt; {}\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic default values:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :granularity, default: :default_granularity\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def default_granularity\n    Current.user.premium? ? \"hourly\" : \"daily\"\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic default values:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, default: proc { Current.tenant.cache_duration || 24 }\n\n  # Lambda\n  attribute :compression, default: -&gt; { Current.tenant.premium? ? \"gzip\" : \"none\" }\nend\n</code></pre>"},{"location":"attributes/defaults/#coercions-and-validations","title":"Coercions and Validations","text":"<p>Defaults follow the same coercion and validation rules as provided values:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, default: \"7\", type: :integer\n\n  # Validations\n  optional :frequency, default: \"daily\", inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/definitions/","title":"Attributes - Definitions","text":"<p>Attributes define your task's interface with automatic validation, type coercion, and accessor generation. They're the contract between callers and your business logic.</p>"},{"location":"attributes/definitions/#declarations","title":"Declarations","text":"<p>Tip</p> <p>Prefer using the <code>required</code> and <code>optional</code> alias for <code>attributes</code> for brevity and to clearly signal intent.</p>"},{"location":"attributes/definitions/#optional","title":"Optional","text":"<p>Optional attributes return <code>nil</code> when not provided.</p> <pre><code>class ScheduleEvent &lt; CMDx::Task\n  attribute :title\n  attributes :duration, :location\n\n  # Alias for attributes (preferred)\n  optional :description\n  optional :visibility, :attendees\n\n  def work\n    title       #=&gt; \"Team Standup\"\n    duration    #=&gt; 30\n    location    #=&gt; nil\n    description #=&gt; nil\n    visibility  #=&gt; nil\n    attendees   #=&gt; [\"alice@company.com\", \"bob@company.com\"]\n  end\nend\n\n# Attributes passed as keyword arguments\nScheduleEvent.execute(\n  title: \"Team Standup\",\n  duration: 30,\n  attendees: [\"alice@company.com\", \"bob@company.com\"]\n)\n</code></pre>"},{"location":"attributes/definitions/#required","title":"Required","text":"<p>Required attributes must be provided in call arguments or task execution will fail.</p> <pre><code>class PublishArticle &lt; CMDx::Task\n  attribute :title, required: true\n  attributes :content, :author_id, required: true\n\n  # Alias for attributes =&gt; required: true (preferred)\n  required :category\n  required :status, :tags\n\n  def work\n    title     #=&gt; \"Getting Started with Ruby\"\n    content   #=&gt; \"This is a comprehensive guide...\"\n    author_id #=&gt; 42\n    category  #=&gt; \"programming\"\n    status    #=&gt; :published\n    tags      #=&gt; [\"ruby\", \"beginner\"]\n  end\nend\n\n# Attributes passed as keyword arguments\nPublishArticle.execute(\n  title: \"Getting Started with Ruby\",\n  content: \"This is a comprehensive guide...\",\n  author_id: 42,\n  category: \"programming\",\n  status: :published,\n  tags: [\"ruby\", \"beginner\"]\n)\n</code></pre>"},{"location":"attributes/definitions/#sources","title":"Sources","text":"<p>Attributes read from any accessible object\u2014not just context. Use sources to pull data from models, services, or any callable:</p>"},{"location":"attributes/definitions/#context","title":"Context","text":"<pre><code>class BackupDatabase &lt; CMDx::Task\n  # Default source is :context\n  required :database_name\n  optional :compression_level\n\n  # Explicitly specify context source\n  attribute :backup_path, source: :context\n\n  def work\n    database_name     #=&gt; context.database_name\n    backup_path       #=&gt; context.backup_path\n    compression_level #=&gt; context.compression_level\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  attributes :host, :credentials, source: :database_config\n\n  # Access from declared attributes\n  attribute :connection_string, source: :credentials\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def database_config\n    @database_config ||= DatabaseConfig.find(context.database_name)\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  # Proc\n  attribute :timestamp, source: proc { Time.current }\n\n  # Lambda\n  attribute :server, source: -&gt; { Current.server }\nend\n</code></pre>"},{"location":"attributes/definitions/#class-or-module","title":"Class or Module","text":"<p>For complex source logic, use classes or modules:</p> <pre><code>class DatabaseResolver\n  def self.call(task)\n    Database.find(task.context.database_name)\n  end\nend\n\nclass BackupDatabase &lt; CMDx::Task\n  # Class or Module\n  attribute :schema, source: DatabaseResolver\n\n  # Instance\n  attribute :metadata, source: DatabaseResolver.new\nend\n</code></pre>"},{"location":"attributes/definitions/#nesting","title":"Nesting","text":"<p>Build complex structures with nested attributes. Children inherit their parent as source and support all attribute options:</p> <p>Note</p> <p>Nested attributes support all features: naming, coercions, validations, defaults, and more.</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  # Required parent with required children\n  required :network_config do\n    required :hostname, :port, :protocol, :subnet\n    optional :load_balancer\n    attribute :firewall_rules\n  end\n\n  # Optional parent with conditional children\n  optional :ssl_config do\n    required :certificate_path, :private_key # Only required if ssl_config provided\n    optional :enable_http2, prefix: true\n  end\n\n  # Multi-level nesting\n  attribute :monitoring do\n    required :provider\n\n    optional :alerting do\n      required :threshold_percentage\n      optional :notification_channel\n    end\n  end\n\n  def work\n    network_config   #=&gt; { hostname: \"api.company.com\" ... }\n    hostname         #=&gt; \"api.company.com\"\n    load_balancer    #=&gt; nil\n  end\nend\n\nConfigureServer.execute(\n  server_id: \"srv-001\",\n  network_config: {\n    hostname: \"api.company.com\",\n    port: 443,\n    protocol: \"https\",\n    subnet: \"10.0.1.0/24\",\n    firewall_rules: \"allow_web_traffic\"\n  },\n  monitoring: {\n    provider: \"datadog\",\n    alerting: {\n      threshold_percentage: 85.0,\n      notification_channel: \"slack\"\n    }\n  }\n)\n</code></pre> <p>Important</p> <p>Child requirements only apply when the parent is provided\u2014perfect for optional structures.</p>"},{"location":"attributes/definitions/#error-handling","title":"Error Handling","text":"<p>Validation failures provide detailed, structured error messages:</p> <p>Note</p> <p>Nested attributes are only validated when their parent is present and valid.</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  required :server_id, :environment\n  required :network_config do\n    required :hostname, :port\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Missing required top-level attributes\nresult = ConfigureServer.execute(server_id: \"srv-001\")\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"environment is required. network_config is required.\",\n                #       messages: {\n                #         environment: [\"is required\"],\n                #         network_config: [\"is required\"]\n                #       }\n                #     }\n                #   }\n\n# Missing required nested attributes\nresult = ConfigureServer.execute(\n  server_id: \"srv-001\",\n  environment: \"production\",\n  network_config: { hostname: \"api.company.com\" } # Missing port\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"port is required.\",\n                #       messages: {\n                #         port: [\"is required\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/naming/","title":"Attributes - Naming","text":"<p>Customize accessor method names to avoid conflicts and improve clarity. Affixing changes only the generated methods\u2014not the original attribute names.</p> <p>Note</p> <p>Use naming when attributes conflict with existing methods or need better clarity in your code.</p>"},{"location":"attributes/naming/#prefix","title":"Prefix","text":"<p>Adds a prefix to the generated accessor method name.</p> <pre><code>class GenerateReport &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :template, prefix: true\n\n  # Static\n  attribute :format, prefix: \"report_\"\n\n  def work\n    context_template #=&gt; \"monthly_sales\"\n    report_format    #=&gt; \"pdf\"\n  end\nend\n\n# Attributes passed as original attribute names\nGenerateReport.execute(template: \"monthly_sales\", format: \"pdf\")\n</code></pre>"},{"location":"attributes/naming/#suffix","title":"Suffix","text":"<p>Adds a suffix to the generated accessor method name.</p> <pre><code>class DeployApplication &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :branch, suffix: true\n\n  # Static\n  attribute :version, suffix: \"_tag\"\n\n  def work\n    branch_context #=&gt; \"main\"\n    version_tag    #=&gt; \"v1.2.3\"\n  end\nend\n\n# Attributes passed as original attribute names\nDeployApplication.execute(branch: \"main\", version: \"v1.2.3\")\n</code></pre>"},{"location":"attributes/naming/#as","title":"As","text":"<p>Completely renames the generated accessor method.</p> <pre><code>class ScheduleMaintenance &lt; CMDx::Task\n  attribute :scheduled_at, as: :when\n\n  def work\n    when #=&gt; &lt;DateTime&gt;\n  end\nend\n\n# Attributes passed as original attribute names\nScheduleMaintenance.execute(scheduled_at: DateTime.new(2024, 12, 15, 2, 0, 0))\n</code></pre>"},{"location":"attributes/transformations/","title":"Attributes - Transformations","text":"<p>Modify attribute values after coercion but before validation. Perfect for normalization, formatting, and data cleanup.</p>"},{"location":"attributes/transformations/#declarations","title":"Declarations","text":""},{"location":"attributes/transformations/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic value transformations:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :options, transform: :compact_blank\nend\n</code></pre>"},{"location":"attributes/transformations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic value transformations:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, transform: proc { |v| v * 2 }\n\n  # Lambda\n  attribute :compression, transform: -&gt;(v) { v.to_s.upcase.strip[0..2]  }\nend\n</code></pre>"},{"location":"attributes/transformations/#class-or-module","title":"Class or Module","text":"<p>Use any object that responds to <code>call</code> for reusable transformation logic:</p> <pre><code>class EmailNormalizer\n  def call(value)\n    value.to_s.downcase.strip\n  end\nend\n\nclass ProcessContacts &lt; CMDx::Task\n  # Class or Module\n  attribute :email, transform: EmailNormalizer\n\n  # Instance\n  attribute :email, transform: EmailNormalizer.new\nend\n</code></pre>"},{"location":"attributes/transformations/#validations","title":"Validations","text":"<p>Validations run on transformed values, ensuring data consistency:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, type: :integer, transform: proc { |v| v.clamp(1, 5) }\n\n  # Validations\n  optional :frequency, transform: :downcase, inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/validations/","title":"Attributes - Validations","text":"<p>Ensure inputs meet requirements before execution. Validations run after coercions, giving you declarative data integrity checks.</p> <p>See Global Configuration for custom validator setup.</p>"},{"location":"attributes/validations/#usage","title":"Usage","text":"<p>Define validation rules on attributes to enforce data requirements:</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  # Required field with presence validation\n  attribute :user_id, presence: true\n\n  # String with length constraints\n  attribute :preferences, length: { minimum: 10, maximum: 500 }\n\n  # Numeric range validation\n  attribute :tier_level, inclusion: { in: 1..5 }\n\n  # Format validation for email\n  attribute :contact_email, format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    user_id       #=&gt; \"98765\"\n    preferences   #=&gt; \"Send weekly digest emails\"\n    tier_level    #=&gt; 3\n    contact_email #=&gt; \"user@company.com\"\n  end\nend\n\nProcessSubscription.execute(\n  user_id: \"98765\",\n  preferences: \"Send weekly digest emails\",\n  tier_level: 3,\n  contact_email: \"user@company.com\"\n)\n</code></pre> <p>Tip</p> <p>Validations run after coercions, so you can validate the final coerced values rather than raw input.</p>"},{"location":"attributes/validations/#built-in-validators","title":"Built-in Validators","text":""},{"location":"attributes/validations/#common-options","title":"Common Options","text":"<p>This list of options is available to all validators:</p> Option Description <code>:allow_nil</code> Skip validation when value is <code>nil</code> <code>:if</code> Symbol, proc, lambda, or callable determining when to validate <code>:unless</code> Symbol, proc, lambda, or callable determining when to skip validation <code>:message</code> Custom error message for validation failures"},{"location":"attributes/validations/#exclusion","title":"Exclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :status, exclusion: { in: %w[recalled archived] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of forbidden values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value exclusions <code>:in_message</code> Custom message for range-based exclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#format","title":"Format","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :sku, format: /\\A[A-Z]{3}-[0-9]{4}\\z/\n\n  attribute :sku, format: { with: /\\A[A-Z]{3}-[0-9]{4}\\z/ }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>regexp</code> Alias for :with option <code>:with</code> Regex pattern that the value must match <code>:without</code> Regex pattern that the value must not match"},{"location":"attributes/validations/#inclusion","title":"Inclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :availability, inclusion: { in: %w[available limited] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of allowed values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value inclusions <code>:in_message</code> Custom message for range-based inclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#length","title":"Length","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :title, length: { within: 5..100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the length must fall within (inclusive) <code>:not_within</code> Range that the length must not fall within <code>:in</code> Alias for :within <code>:not_in</code> Range that the length must not fall within <code>:min</code> Minimum allowed length <code>:max</code> Maximum allowed length <code>:is</code> Exact required length <code>:is_not</code> Length that is not allowed <code>:within_message</code> Custom message for within/range validations <code>:in_message</code> Custom message for :in validation <code>:not_within_message</code> Custom message for not_within validation <code>:not_in_message</code> Custom message for not_in validation <code>:min_message</code> Custom message for minimum length validation <code>:max_message</code> Custom message for maximum length validation <code>:is_message</code> Custom message for exact length validation <code>:is_not_message</code> Custom message for is_not validation"},{"location":"attributes/validations/#numeric","title":"Numeric","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :word_count, numeric: { min: 100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the value must fall within (inclusive) <code>:not_within</code> Range that the value must not fall within <code>:in</code> Alias for :within option <code>:not_in</code> Alias for :not_within option <code>:min</code> Minimum allowed value (inclusive, &gt;=) <code>:max</code> Maximum allowed value (inclusive, &lt;=) <code>:is</code> Exact value that must match <code>:is_not</code> Value that must not match <code>:within_message</code> Custom message for range validations <code>:not_within_message</code> Custom message for exclusion validations <code>:min_message</code> Custom message for minimum validation <code>:max_message</code> Custom message for maximum validation <code>:is_message</code> Custom message for exact match validation <code>:is_not_message</code> Custom message for exclusion validation"},{"location":"attributes/validations/#presence","title":"Presence","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :content, presence: true\n\n  attribute :content, presence: { message: \"cannot be blank\" }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>true</code> Ensures value is not nil, empty string, or whitespace"},{"location":"attributes/validations/#declarations","title":"Declarations","text":"<p>Important</p> <p>Custom validators must raise <code>CMDx::ValidationError</code> with a descriptive message.</p>"},{"location":"attributes/validations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple validation logic:</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  # Proc\n  register :validator, :api_key, proc do |value, options = {}|\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\n\n  # Lambda\n  register :validator, :api_key, -&gt;(value, options = {}) {\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/validations/#class-or-module","title":"Class or Module","text":"<p>Register custom validation logic for specialized requirements:</p> <pre><code>class ApiKeyValidator\n  def self.call(value, options = {})\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\nend\n\nclass SetupApplication &lt; CMDx::Task\n  register :validator, :api_key, ApiKeyValidator\n\n  attribute :access_key, api_key: true\nend\n</code></pre>"},{"location":"attributes/validations/#removals","title":"Removals","text":"<p>Remove unwanted validators:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one validator. Use multiple calls for batch removals.</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  deregister :validator, :api_key\nend\n</code></pre>"},{"location":"attributes/validations/#error-handling","title":"Error Handling","text":"<p>Validation failures provide detailed, structured error messages:</p> <pre><code>class CreateProject &lt; CMDx::Task\n  attribute :project_name, presence: true, length: { minimum: 3, maximum: 50 }\n  attribute :budget, numeric: { greater_than: 1000, less_than: 1000000 }\n  attribute :priority, inclusion: { in: [:low, :medium, :high] }\n  attribute :contact_email, format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = CreateProject.execute(\n  project_name: \"AB\",           # Too short\n  budget: 500,                  # Too low\n  priority: :urgent,            # Not in allowed list\n  contact_email: \"invalid-email\"    # Invalid format\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"project_name is too short (minimum is 3 characters). budget must be greater than 1000. priority is not included in the list. contact_email is invalid.\",\n                #       messages: {\n                #         project_name: [\"is too short (minimum is 3 characters)\"],\n                #         budget: [\"must be greater than 1000\"],\n                #         priority: [\"is not included in the list\"],\n                #         contact_email: [\"is invalid\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"basics/chain/","title":"Basics - Chain","text":"<p>Chains automatically track related task executions within a thread. Think of them as execution traces that help you understand what happened and in what order.</p>"},{"location":"basics/chain/#management","title":"Management","text":"<p>Each thread maintains its own isolated chain using thread-local storage.</p> <p>Warning</p> <p>Chains are thread-local. Don't share chain references across threads\u2014it causes race conditions.</p> <pre><code># Thread A\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch1.csv\")\n  result.chain.id    #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nend\n\n# Thread B (completely separate chain)\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch2.csv\")\n  result.chain.id    #=&gt; \"z3a42b95-c821-7892-b156-dd7c921fe2a3\"\nend\n\n# Access current thread's chain\nCMDx::Chain.current  #=&gt; Returns current chain or nil\nCMDx::Chain.clear    #=&gt; Clears current thread's chain\n</code></pre>"},{"location":"basics/chain/#links","title":"Links","text":"<p>Tasks automatically create or join the current thread's chain:</p> <p>Important</p> <p>Chain management is automatic\u2014no manual lifecycle handling needed.</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    # First task creates new chain\n    result1 = ValidateHeaders.execute(file_path: context.file_path)\n    result1.chain.id           #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\n    result1.chain.results.size #=&gt; 1\n\n    # Second task joins existing chain\n    result2 = SendNotification.execute(to: \"admin@company.com\")\n    result2.chain.id == result1.chain.id  #=&gt; true\n    result2.chain.results.size            #=&gt; 2\n\n    # Both results reference the same chain\n    result1.chain.results == result2.chain.results #=&gt; true\n  end\nend\n</code></pre>"},{"location":"basics/chain/#inheritance","title":"Inheritance","text":"<p>Subtasks automatically inherit the current thread's chain, building a unified execution trail:</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    context.dataset = Dataset.find(context.dataset_id)\n\n    # Subtasks automatically inherit current chain\n    ValidateSchema.execute\n    TransformData.execute!(context)\n    SaveToDatabase.execute(dataset_id: context.dataset_id)\n  end\nend\n\nresult = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# All tasks share the same chain\nchain.results.size #=&gt; 4 (main task + 3 subtasks)\nchain.results.map { |r| r.task.class }\n#=&gt; [ImportDataset, ValidateSchema, TransformData, SaveToDatabase]\n</code></pre>"},{"location":"basics/chain/#structure","title":"Structure","text":"<p>Chains expose comprehensive execution information:</p> <p>Important</p> <p>Chain state reflects the first (outermost) task result. Subtasks maintain their own states.</p> <pre><code>result = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# Chain identification\nchain.id      #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nchain.results #=&gt; Array of all results in execution order\n\n# State delegation (from first/outer-most result)\nchain.state   #=&gt; \"complete\"\nchain.status  #=&gt; \"success\"\nchain.outcome #=&gt; \"success\"\n\n# Access individual results\nchain.results.each_with_index do |result, index|\n  puts \"#{index}: #{result.task.class} - #{result.status}\"\nend\n</code></pre>"},{"location":"basics/context/","title":"Basics - Context","text":"<p>Context is your data container for inputs, intermediate values, and outputs. It makes sharing data between tasks effortless.</p>"},{"location":"basics/context/#assigning-data","title":"Assigning Data","text":"<p>Context automatically captures all task inputs, normalizing keys to symbols:</p> <pre><code># Direct execution\nCalculateShipping.execute(weight: 2.5, destination: \"CA\")\n\n# Instance creation\nCalculateShipping.new(weight: 2.5, \"destination\" =&gt; \"CA\")\n</code></pre> <p>Important</p> <p>String keys convert to symbols automatically. Prefer symbols for consistency.</p>"},{"location":"basics/context/#accessing-data","title":"Accessing Data","text":"<p>Access context data using method notation, hash keys, or safe accessors:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Method style access (preferred)\n    weight = context.weight\n    destination = context.destination\n\n    # Hash style access\n    service_type = context[:service_type]\n    options = context[\"options\"]\n\n    # Safe access with defaults\n    rush_delivery = context.fetch!(:rush_delivery, false)\n    carrier = context.dig(:options, :carrier)\n\n    # Shorter alias\n    cost = ctx.weight * ctx.rate_per_pound  # ctx aliases context\n  end\nend\n</code></pre> <p>Important</p> <p>Undefined attributes return <code>nil</code> instead of raising errors\u2014perfect for optional data.</p>"},{"location":"basics/context/#modifying-context","title":"Modifying Context","text":"<p>Context supports dynamic modification during task execution:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Direct assignment\n    context.carrier = Carrier.find_by(code: context.carrier_code)\n    context.package = Package.new(weight: context.weight)\n    context.calculated_at = Time.now\n\n    # Hash-style assignment\n    context[:status] = \"calculating\"\n    context[\"tracking_number\"] = \"SHIP#{SecureRandom.hex(6)}\"\n\n    # Conditional assignment\n    context.insurance_included ||= false\n\n    # Batch updates\n    context.merge!(\n      status: \"completed\",\n      shipping_cost: calculate_cost,\n      estimated_delivery: Time.now + 3.days\n    )\n\n    # Remove sensitive data\n    context.delete!(:credit_card_token)\n  end\n\n  private\n\n  def calculate_cost\n    base_rate = context.weight * context.rate_per_pound\n    base_rate + (base_rate * context.tax_percentage)\n  end\nend\n</code></pre> <p>Tip</p> <p>Use context for both input values and intermediate results. This creates natural data flow through your task execution pipeline.</p>"},{"location":"basics/context/#data-sharing","title":"Data Sharing","text":"<p>Share context across tasks for seamless data flow:</p> <pre><code># During execution\nclass CalculateShipping &lt; CMDx::Task\n  def work\n    # Validate shipping data\n    validation_result = ValidateAddress.execute(context)\n\n    # Via context\n    CalculateInsurance.execute(context)\n\n    # Via result\n    NotifyShippingCalculated.execute(validation_result)\n\n    # Context now contains accumulated data from all tasks\n    context.address_validated    #=&gt; true (from validation)\n    context.insurance_calculated #=&gt; true (from insurance)\n    context.notification_sent    #=&gt; true (from notification)\n  end\nend\n\n# After execution\nresult = CalculateShipping.execute(destination: \"New York, NY\")\n\nCreateShippingLabel.execute(result)\n</code></pre>"},{"location":"basics/execution/","title":"Basics - Execution","text":"<p>CMDx offers two execution methods with different error handling approaches. Choose based on your needs: safe result handling or exception-based control flow.</p>"},{"location":"basics/execution/#execution-methods","title":"Execution Methods","text":"<p>Both methods return results, but handle failures differently:</p> Method Returns Exceptions Use Case <code>execute</code> Always returns <code>CMDx::Result</code> Never raises Predictable result handling <code>execute!</code> Returns <code>CMDx::Result</code> on success Raises <code>CMDx::Fault</code> when skipped or failed Exception-based control flow"},{"location":"basics/execution/#non-bang-execution","title":"Non-bang Execution","text":"<p>Always returns a <code>CMDx::Result</code>, never raises exceptions. Perfect for most use cases.</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Check execution state\nresult.success?         #=&gt; true/false\nresult.failed?          #=&gt; true/false\nresult.skipped?         #=&gt; true/false\n\n# Access result data\nresult.context.email    #=&gt; \"user@example.com\"\nresult.state            #=&gt; \"complete\"\nresult.status           #=&gt; \"success\"\n</code></pre>"},{"location":"basics/execution/#bang-execution","title":"Bang Execution","text":"<p>Raises <code>CMDx::Fault</code> exceptions on failure or skip. Returns results only on success.</p> Exception Raised When <code>CMDx::FailFault</code> Task execution fails <code>CMDx::SkipFault</code> Task execution is skipped <p>Important</p> <p>Behavior depends on <code>task_breakpoints</code> or <code>workflow_breakpoints</code> config. Default: only failures raise exceptions.</p> <pre><code>begin\n  result = CreateAccount.execute!(email: \"user@example.com\")\n  SendWelcomeEmail.execute(result.context)\nrescue CMDx::FailFault =&gt; e\n  ScheduleAccountRetryJob.perform_later(e.result.context.email)\nrescue CMDx::SkipFault =&gt; e\n  Rails.logger.info(\"Account creation skipped: #{e.result.reason}\")\nrescue Exception =&gt; e\n  ErrorTracker.capture(unhandled_exception: e)\nend\n</code></pre>"},{"location":"basics/execution/#direct-instantiation","title":"Direct Instantiation","text":"<p>Tasks can be instantiated directly for advanced use cases, testing, and custom execution patterns:</p> <pre><code># Direct instantiation\ntask = CreateAccount.new(email: \"user@example.com\", send_welcome: true)\n\n# Access properties before execution\ntask.id                      #=&gt; \"abc123...\" (unique task ID)\ntask.context.email           #=&gt; \"user@example.com\"\ntask.context.send_welcome    #=&gt; true\ntask.result.state            #=&gt; \"initialized\"\ntask.result.status           #=&gt; \"success\"\n\n# Manual execution\ntask.execute\n# or\ntask.execute!\n\ntask.result.success?         #=&gt; true/false\n</code></pre>"},{"location":"basics/execution/#result-details","title":"Result Details","text":"<p>The <code>Result</code> object provides comprehensive execution information:</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Execution metadata\nresult.id           #=&gt; \"abc123...\"  (unique execution ID)\nresult.task         #=&gt; CreateAccount instance (frozen)\nresult.chain        #=&gt; Task execution chain\n\n# Context and metadata\nresult.context      #=&gt; Context with all task data\nresult.metadata     #=&gt; Hash with execution metadata\n</code></pre>"},{"location":"basics/setup/","title":"Basics - Setup","text":"<p>Tasks are the heart of CMDx\u2014self-contained units of business logic with built-in validation, error handling, and execution tracking.</p>"},{"location":"basics/setup/#structure","title":"Structure","text":"<p>Tasks need only two things: inherit from <code>CMDx::Task</code> and define a <code>work</code> method:</p> <pre><code>class ValidateDocument &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Without a <code>work</code> method, execution raises <code>CMDx::UndefinedMethodError</code>.</p> <pre><code>class IncompleteTask &lt; CMDx::Task\n  # No `work` method defined\nend\n\nIncompleteTask.execute #=&gt; raises CMDx::UndefinedMethodError\n</code></pre>"},{"location":"basics/setup/#rollback","title":"Rollback","text":"<p>Undo any operations linked to the given status, helping to restore a pristine state.</p> <pre><code>class ValidateDocument &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\n\n  def rollback\n    # Your undo logic...\n  end\nend\n</code></pre>"},{"location":"basics/setup/#inheritance","title":"Inheritance","text":"<p>Share configuration across tasks using inheritance:</p> <pre><code>class ApplicationTask &lt; CMDx::Task\n  register :middleware, SecurityMiddleware\n\n  before_execution :initialize_request_tracking\n\n  attribute :session_id\n\n  private\n\n  def initialize_request_tracking\n    context.tracking_id ||= SecureRandom.uuid\n  end\nend\n\nclass SyncInventory &lt; ApplicationTask\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"basics/setup/#lifecycle","title":"Lifecycle","text":"<p>Tasks follow a predictable execution pattern:</p> <p>Caution</p> <p>Tasks are single-use objects. Once executed, they're frozen and immutable.</p> Stage State Status Description Instantiation <code>initialized</code> <code>success</code> Task created with context Validation <code>executing</code> <code>success</code>/<code>failed</code> Attributes validated Execution <code>executing</code> <code>success</code>/<code>failed</code>/<code>skipped</code> <code>work</code> method runs Completion <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Result finalized Freezing <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Task becomes immutable Rollback <code>executed</code> <code>failed</code>/<code>skipped</code> Work undone"},{"location":"interruptions/exceptions/","title":"Interruptions - Exceptions","text":"<p>Exception handling differs between <code>execute</code> and <code>execute!</code>. Choose the method that matches your error handling strategy.</p>"},{"location":"interruptions/exceptions/#exception-handling","title":"Exception Handling","text":"<p>Important</p> <p>Prefer <code>skip!</code> and <code>fail!</code> over raising exceptions\u2014they signal intent more clearly.</p>"},{"location":"interruptions/exceptions/#non-bang-execution","title":"Non-bang execution","text":"<p>Captures all exceptions and returns them as failed results:</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nresult = CompressDocument.execute(document_id: \"unknown-doc-id\")\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.failed?  #=&gt; true\nresult.reason   #=&gt; \"[ActiveRecord::NotFoundError] record not found\"\nresult.cause    #=&gt; &lt;ActiveRecord::NotFoundError&gt;\n</code></pre> <p>Note</p> <p>Use <code>exception_handler</code> with <code>execute</code> to send exceptions to APM tools before they become failed results.</p>"},{"location":"interruptions/exceptions/#bang-execution","title":"Bang execution","text":"<p>Lets exceptions propagate naturally for standard Ruby error handling:</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nbegin\n  CompressDocument.execute!(document_id: \"unknown-doc-id\")\nrescue ActiveRecord::NotFoundError =&gt; e\n  puts \"Handle exception: #{e.message}\"\nend\n</code></pre>"},{"location":"interruptions/faults/","title":"Interruptions - Faults","text":"<p>Faults are exceptions raised by <code>execute!</code> when tasks halt. They carry rich context about execution state, enabling sophisticated error handling patterns.</p>"},{"location":"interruptions/faults/#fault-types","title":"Fault Types","text":"Type Triggered By Use Case <code>CMDx::Fault</code> Base class Catch-all for any interruption <code>CMDx::SkipFault</code> <code>skip!</code> method Optional processing, early returns <code>CMDx::FailFault</code> <code>fail!</code> method Validation errors, processing failures <p>Important</p> <p>All faults inherit from <code>CMDx::Fault</code> and expose result, task, context, and chain data.</p>"},{"location":"interruptions/faults/#fault-handling","title":"Fault Handling","text":"<pre><code>begin\n  ProcessTicket.execute!(ticket_id: 456)\nrescue CMDx::SkipFault =&gt; e\n  logger.info \"Ticket processing skipped: #{e.message}\"\n  schedule_retry(e.context.ticket_id)\nrescue CMDx::FailFault =&gt; e\n  logger.error \"Ticket processing failed: #{e.message}\"\n  notify_admin(e.context.assigned_agent, e.result.metadata[:error_code])\nrescue CMDx::Fault =&gt; e\n  logger.warn \"Ticket processing interrupted: #{e.message}\"\n  rollback_changes\nend\n</code></pre>"},{"location":"interruptions/faults/#data-access","title":"Data Access","text":"<p>Access rich execution data from fault exceptions:</p> <pre><code>begin\n  LicenseActivation.execute!(license_key: key, machine_id: machine)\nrescue CMDx::Fault =&gt; e\n  # Result information\n  e.result.state     #=&gt; \"interrupted\"\n  e.result.status    #=&gt; \"failed\" or \"skipped\"\n  e.result.reason    #=&gt; \"License key already activated\"\n\n  # Task information\n  e.task.class       #=&gt; &lt;LicenseActivation&gt;\n  e.task.id          #=&gt; \"abc123...\"\n\n  # Context data\n  e.context.license_key #=&gt; \"ABC-123-DEF\"\n  e.context.machine_id  #=&gt; \"[FILTERED]\"\n\n  # Chain information\n  e.chain.id         #=&gt; \"def456...\"\n  e.chain.size       #=&gt; 3\nend\n</code></pre>"},{"location":"interruptions/faults/#advanced-matching","title":"Advanced Matching","text":""},{"location":"interruptions/faults/#task-specific-matching","title":"Task-Specific Matching","text":"<p>Handle faults only from specific tasks using <code>for?</code>:</p> <pre><code>begin\n  DocumentWorkflow.execute!(document_data: data)\nrescue CMDx::FailFault.for?(FormatValidator, ContentProcessor) =&gt; e\n  # Handle only document-related failures\n  retry_with_alternate_parser(e.context)\nrescue CMDx::SkipFault.for?(VirusScanner, ContentFilter) =&gt; e\n  # Handle security-related skips\n  quarantine_for_review(e.context.document_id)\nend\n</code></pre>"},{"location":"interruptions/faults/#custom-logic-matching","title":"Custom Logic Matching","text":"<pre><code>begin\n  ReportGenerator.execute!(report: report_data)\nrescue CMDx::Fault.matches? { |f| f.context.data_size &gt; 10_000 } =&gt; e\n  escalate_large_dataset_failure(e)\nrescue CMDx::FailFault.matches? { |f| f.result.metadata[:attempt_count] &gt; 3 } =&gt; e\n  abandon_report_generation(e)\nrescue CMDx::Fault.matches? { |f| f.result.metadata[:error_type] == \"memory\" } =&gt; e\n  increase_memory_and_retry(e)\nend\n</code></pre>"},{"location":"interruptions/faults/#fault-propagation","title":"Fault Propagation","text":"<p>Propagate failures with <code>throw!</code> to preserve context and maintain the error chain:</p>"},{"location":"interruptions/faults/#basic-propagation","title":"Basic Propagation","text":"<pre><code>class ReportGenerator &lt; CMDx::Task\n  def work\n    # Throw if skipped or failed\n    validation_result = DataValidator.execute(context)\n    throw!(validation_result)\n\n    # Only throw if skipped\n    check_permissions = CheckPermissions.execute(context)\n    throw!(check_permissions) if check_permissions.skipped?\n\n    # Only throw if failed\n    data_result = DataProcessor.execute(context)\n    throw!(data_result) if data_result.failed?\n\n    # Continue processing\n    generate_report\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#additional-metadata","title":"Additional Metadata","text":"<pre><code>class BatchProcessor &lt; CMDx::Task\n  def work\n    step_result = FileValidation.execute(context)\n\n    if step_result.failed?\n      throw!(step_result, {\n        batch_stage: \"validation\",\n        can_retry: true,\n        next_step: \"file_repair\"\n      })\n    end\n\n    continue_batch\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#chain-analysis","title":"Chain Analysis","text":"<p>Trace fault origins and propagation through the execution chain:</p> <pre><code>result = DocumentWorkflow.execute(invalid_data)\n\nif result.failed?\n  # Trace the original failure\n  original = result.caused_failure\n  if original\n    puts \"Original failure: #{original.task.class.name}\"\n    puts \"Reason: #{original.reason}\"\n  end\n\n  # Find what propagated the failure\n  thrower = result.threw_failure\n  puts \"Propagated by: #{thrower.task.class.name}\" if thrower\n\n  # Analyze failure type\n  case\n  when result.caused_failure?\n    puts \"This task was the original source\"\n  when result.threw_failure?\n    puts \"This task propagated a failure\"\n  when result.thrown_failure?\n    puts \"This task failed due to propagation\"\n  end\nend\n</code></pre>"},{"location":"interruptions/halt/","title":"Interruptions - Halt","text":"<p>Stop task execution intentionally using <code>skip!</code> or <code>fail!</code>. Both methods signal clear intent about why execution stopped.</p>"},{"location":"interruptions/halt/#skipping","title":"Skipping","text":"<p>Use <code>skip!</code> when the task doesn't need to run. It's a no-op, not an error.</p> <p>Important</p> <p>Skipped tasks are considered \"good\" outcomes\u2014they succeeded by doing nothing.</p> <pre><code>class ProcessInventory &lt; CMDx::Task\n  def work\n    # Without a reason\n    skip! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    # With a reason\n    skip!(\"Warehouse closed\") unless Time.now.hour.between?(8, 18)\n\n    inventory = Inventory.find(context.inventory_id)\n\n    if inventory.already_counted?\n      skip!(\"Inventory already counted today\")\n    else\n      inventory.count!\n    end\n  end\nend\n\nresult = ProcessInventory.execute(inventory_id: 456)\n\n# Executed\nresult.status #=&gt; \"skipped\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Warehouse closed\"\n</code></pre>"},{"location":"interruptions/halt/#failing","title":"Failing","text":"<p>Use <code>fail!</code> when the task can't complete successfully. It signals controlled, intentional failure:</p> <pre><code>class ProcessRefund &lt; CMDx::Task\n  def work\n    # Without a reason\n    fail! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    refund = Refund.find(context.refund_id)\n\n    # With a reason\n    if refund.expired?\n      fail!(\"Refund period has expired\")\n    elsif !refund.amount.positive?\n      fail!(\"Refund amount must be positive\")\n    else\n      refund.process!\n    end\n  end\nend\n\nresult = ProcessRefund.execute(refund_id: 789)\n\n# Executed\nresult.status #=&gt; \"failed\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Refund period has expired\"\n</code></pre>"},{"location":"interruptions/halt/#metadata-enrichment","title":"Metadata Enrichment","text":"<p>Enrich halt calls with metadata for better debugging and error handling:</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    license = License.find(context.license_id)\n\n    if license.already_renewed?\n      # Without metadata\n      skip!(\"License already renewed\")\n    end\n\n    unless license.renewal_eligible?\n      # With metadata\n      fail!(\n        \"License not eligible for renewal\",\n        error_code: \"LICENSE.NOT_ELIGIBLE\",\n        retry_after: Time.current + 30.days\n      )\n    end\n\n    process_renewal\n  end\nend\n\nresult = ProcessRenewal.execute(license_id: 567)\n\n# Without metadata\nresult.metadata #=&gt; {}\n\n# With metadata\nresult.metadata #=&gt; {\n                #     error_code: \"LICENSE.NOT_ELIGIBLE\",\n                #     retry_after: &lt;Time 30 days from now&gt;\n                #   }\n</code></pre>"},{"location":"interruptions/halt/#state-transitions","title":"State Transitions","text":"<p>Halt methods trigger specific state and status transitions:</p> Method State Status Outcome <code>skip!</code> <code>interrupted</code> <code>skipped</code> <code>good? = true</code>, <code>bad? = true</code> <code>fail!</code> <code>interrupted</code> <code>failed</code> <code>good? = false</code>, <code>bad? = true</code> <pre><code>result = ProcessRenewal.execute(license_id: 567)\n\n# State information\nresult.state        #=&gt; \"interrupted\"\nresult.status       #=&gt; \"skipped\" or \"failed\"\nresult.interrupted? #=&gt; true\nresult.complete?    #=&gt; false\n\n# Outcome categorization\nresult.good?        #=&gt; true for skipped, false for failed\nresult.bad?         #=&gt; true for both skipped and failed\n</code></pre>"},{"location":"interruptions/halt/#execution-behavior","title":"Execution Behavior","text":"<p>Halt methods behave differently depending on the call method used:</p>"},{"location":"interruptions/halt/#non-bang-execution","title":"Non-bang execution","text":"<p>Returns result object without raising exceptions:</p> <pre><code>result = ProcessRefund.execute(refund_id: 789)\n\ncase result.status\nwhen \"success\"\n  puts \"Refund processed: $#{result.context.refund.amount}\"\nwhen \"skipped\"\n  puts \"Refund skipped: #{result.reason}\"\nwhen \"failed\"\n  puts \"Refund failed: #{result.reason}\"\n  handle_refund_error(result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#bang-execution","title":"Bang execution","text":"<p>Raises exceptions for halt conditions based on <code>task_breakpoints</code> configuration:</p> <pre><code>begin\n  result = ProcessRefund.execute!(refund_id: 789)\n  puts \"Success: Refund processed\"\nrescue CMDx::SkipFault =&gt; e\n  puts \"Skipped: #{e.message}\"\nrescue CMDx::FailFault =&gt; e\n  puts \"Failed: #{e.message}\"\n  handle_refund_failure(e.result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#best-practices","title":"Best Practices","text":"<p>Always provide a reason for better debugging and clearer exception messages:</p> <pre><code># Good: Clear, specific reason\nskip!(\"Document processing paused for compliance review\")\nfail!(\"File format not supported by processor\", code: \"FORMAT_UNSUPPORTED\")\n\n# Acceptable: Generic, non-specific reason\nskip!(\"Paused\")\nfail!(\"Unsupported\")\n\n# Bad: Default, cannot determine reason\nskip! #=&gt; \"Unspecified\"\nfail! #=&gt; \"Unspecified\"\n</code></pre>"},{"location":"interruptions/halt/#manual-errors","title":"Manual Errors","text":"<p>For rare cases, manually add errors before halting:</p> <p>Important</p> <p>Manual errors don't stop execution\u2014you still need to call <code>fail!</code> or <code>skip!</code>.</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    if document.nonrenewable?\n      errors.add(:document, \"not renewable\")\n      fail!(\"document could not be renewed\")\n    else\n      document.renew!\n    end\n  end\nend\n</code></pre>"},{"location":"outcomes/result/","title":"Outcomes - Result","text":"<p>Results are your window into task execution. They expose everything: outcome, state, timing, context, and metadata.</p>"},{"location":"outcomes/result/#result-attributes","title":"Result Attributes","text":"<p>Access essential execution information:</p> <p>Important</p> <p>Results are immutable after execution completes.</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Object data\nresult.task     #=&gt; &lt;BuildApplication&gt;\nresult.context  #=&gt; &lt;CMDx::Context&gt;\nresult.chain    #=&gt; &lt;CMDx::Chain&gt;\n\n# Execution data\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\n\n# Fault data\nresult.reason   #=&gt; \"Build tool not found\"\nresult.cause    #=&gt; &lt;CMDx::FailFault&gt;\nresult.metadata #=&gt; { error_code: \"BUILD_TOOL.NOT_FOUND\" }\n</code></pre>"},{"location":"outcomes/result/#lifecycle-information","title":"Lifecycle Information","text":"<p>Check execution state and status with predicate methods:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# State predicates (execution lifecycle)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\nresult.executed?    #=&gt; true (execution finished)\n\n# Status predicates (execution outcome)\nresult.success?     #=&gt; true (successful execution)\nresult.failed?      #=&gt; false (no failure)\nresult.skipped?     #=&gt; false (not skipped)\n\n# Outcome categorization\nresult.good?        #=&gt; true (success or skipped)\nresult.bad?         #=&gt; false (skipped or failed)\n</code></pre>"},{"location":"outcomes/result/#outcome-analysis","title":"Outcome Analysis","text":"<p>Get a unified outcome string combining state and status:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\nresult.outcome #=&gt; \"success\" (state and status)\n</code></pre>"},{"location":"outcomes/result/#chain-analysis","title":"Chain Analysis","text":"<p>Trace fault origins and propagation:</p> <pre><code>result = DeploymentWorkflow.execute(app_name: \"webapp\")\n\nif result.failed?\n  # Find the original cause of failure\n  if original_failure = result.caused_failure\n    puts \"Root cause: #{original_failure.task.class.name}\"\n    puts \"Reason: #{original_failure.reason}\"\n  end\n\n  # Find what threw the failure to this result\n  if throwing_task = result.threw_failure\n    puts \"Failure source: #{throwing_task.task.class.name}\"\n    puts \"Reason: #{throwing_task.reason}\"\n  end\n\n  # Failure classification\n  result.caused_failure?  #=&gt; true if this result was the original cause\n  result.threw_failure?   #=&gt; true if this result threw a failure\n  result.thrown_failure?  #=&gt; true if this result received a thrown failure\nend\n</code></pre>"},{"location":"outcomes/result/#index-and-position","title":"Index and Position","text":"<p>Results track their position within execution chains:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Position in execution sequence\nresult.index #=&gt; 0 (first task in chain)\n\n# Access via chain\nresult.chain.results[result.index] == result #=&gt; true\n</code></pre>"},{"location":"outcomes/result/#block-yield","title":"Block Yield","text":"<p>Execute code with direct result access:</p> <pre><code>BuildApplication.execute(version: \"1.2.3\") do |result|\n  if result.success?\n    notify_deployment_ready(result)\n  elsif result.failed?\n    handle_build_failure(result)\n  else\n    log_skip_reason(result)\n  end\nend\n</code></pre>"},{"location":"outcomes/result/#handlers","title":"Handlers","text":"<p>Handle outcomes with functional-style methods. Handlers return the result for chaining:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Status-based handlers\nresult\n  .handle_success { |result| notify_deployment_ready(result) }\n  .handle_failed { |result| handle_build_failure(result) }\n  .handle_skipped { |result| log_skip_reason(result) }\n\n# State-based handlers\nresult\n  .handle_complete { |result| update_build_status(result) }\n  .handle_interrupted { |result| cleanup_partial_artifacts(result) }\n\n# Outcome-based handlers\nresult\n  .handle_good { |result| increment_success_counter(result) }\n  .handle_bad { |result| alert_operations_team(result) }\n</code></pre>"},{"location":"outcomes/result/#pattern-matching","title":"Pattern Matching","text":"<p>Use Ruby 3.0+ pattern matching for elegant outcome handling:</p> <p>Important</p> <p>Pattern matching works with both array and hash deconstruction.</p>"},{"location":"outcomes/result/#array-pattern","title":"Array Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin [\"complete\", \"success\"]\n  redirect_to build_success_page\nin [\"interrupted\", \"failed\"]\n  retry_build_with_backoff(result)\nin [\"interrupted\", \"skipped\"]\n  log_skip_and_continue\nend\n</code></pre>"},{"location":"outcomes/result/#hash-pattern","title":"Hash Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin { state: \"complete\", status: \"success\" }\n  celebrate_build_success\nin { status: \"failed\", metadata: { retryable: true } }\n  schedule_build_retry(result)\nin { bad: true, metadata: { reason: String =&gt; reason } }\n  escalate_build_error(\"Build failed: #{reason}\")\nend\n</code></pre>"},{"location":"outcomes/result/#pattern-guards","title":"Pattern Guards","text":"<pre><code>case result\nin { status: \"failed\", metadata: { attempts: n } } if n &lt; 3\n  retry_build_with_delay(result, n * 2)\nin { status: \"failed\", metadata: { attempts: n } } if n &gt;= 3\n  mark_build_permanently_failed(result)\nin { runtime: time } if time &gt; performance_threshold\n  investigate_build_performance(result)\nend\n</code></pre>"},{"location":"outcomes/states/","title":"Outcomes - States","text":"<p>States track where a task is in its execution lifecycle\u2014from creation through completion or interruption.</p>"},{"location":"outcomes/states/#definitions","title":"Definitions","text":"State Description <code>initialized</code> Task created but execution not yet started. Default state for new tasks. <code>executing</code> Task is actively running its business logic. Transient state during execution. <code>complete</code> Task finished execution successfully without any interruption or halt. <code>interrupted</code> Task execution was stopped due to a fault, exception, or explicit halt. <p>State-Status combinations:</p> State Status Meaning <code>initialized</code> <code>success</code> Task created, not yet executed <code>executing</code> <code>success</code> Task currently running <code>complete</code> <code>success</code> Task finished successfully <code>complete</code> <code>skipped</code> Task finished by skipping execution <code>interrupted</code> <code>failed</code> Task stopped due to failure <code>interrupted</code> <code>skipped</code> Task stopped by skip condition"},{"location":"outcomes/states/#transitions","title":"Transitions","text":"<p>Caution</p> <p>States are managed automatically\u2014never modify them manually.</p> <pre><code># Valid state transition flow\ninitialized \u2192 executing \u2192 complete    (successful execution)\ninitialized \u2192 executing \u2192 interrupted (skipped/failed execution)\n</code></pre>"},{"location":"outcomes/states/#predicates","title":"Predicates","text":"<p>Use state predicates to check the current execution lifecycle:</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state checks\nresult.initialized? #=&gt; false (after execution)\nresult.executing?   #=&gt; false (after execution)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\n\n# State categorization\nresult.executed?    #=&gt; true (complete OR interrupted)\n</code></pre>"},{"location":"outcomes/states/#handlers","title":"Handlers","text":"<p>Handle lifecycle events with state-based handlers. Use <code>handle_executed</code> for cleanup that runs regardless of outcome:</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state handlers\nresult\n  .handle_complete { |result| send_upload_notification(result) }\n  .handle_interrupted { |result| cleanup_temp_files(result) }\n  .handle_executed { |result| log_upload_metrics(result) }\n</code></pre>"},{"location":"outcomes/statuses/","title":"Outcomes - Statuses","text":"<p>Statuses represent the business outcome\u2014did the task succeed, skip, or fail? This differs from state, which tracks the execution lifecycle.</p>"},{"location":"outcomes/statuses/#definitions","title":"Definitions","text":"Status Description <code>success</code> Task execution completed successfully with expected business outcome. Default status for all tasks. <code>skipped</code> Task intentionally stopped execution because conditions weren't met or continuation was unnecessary. <code>failed</code> Task stopped execution due to business rule violations, validation errors, or exceptions."},{"location":"outcomes/statuses/#transitions","title":"Transitions","text":"<p>Important</p> <p>Status transitions are final and unidirectional. Once skipped or failed, tasks can't return to success.</p> <pre><code># Valid status transitions\nsuccess \u2192 skipped    # via skip!\nsuccess \u2192 failed     # via fail! or exception\n\n# Invalid transitions (will raise errors)\nskipped \u2192 success    # \u274c Cannot transition\nskipped \u2192 failed     # \u274c Cannot transition\nfailed \u2192 success     # \u274c Cannot transition\nfailed \u2192 skipped     # \u274c Cannot transition\n</code></pre>"},{"location":"outcomes/statuses/#predicates","title":"Predicates","text":"<p>Use status predicates to check execution outcomes:</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status checks\nresult.success? #=&gt; true/false\nresult.skipped? #=&gt; true/false\nresult.failed?  #=&gt; true/false\n\n# Outcome categorization\nresult.good?    #=&gt; true if success OR skipped\nresult.bad?     #=&gt; true if skipped OR failed (not success)\n</code></pre>"},{"location":"outcomes/statuses/#handlers","title":"Handlers","text":"<p>Branch business logic with status-based handlers. Use <code>handle_good</code> and <code>handle_bad</code> for success/skip vs failed outcomes:</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status handlers\nresult\n  .handle_success { |result| mark_notification_sent(result) }\n  .handle_skipped { |result| log_notification_skipped(result) }\n  .handle_failed { |result| queue_retry_notification(result) }\n\n# Outcome-based handlers\nresult\n  .handle_good { |result| update_message_stats(result) }\n  .handle_bad { |result| track_delivery_failure(result) }\n</code></pre>"}]}