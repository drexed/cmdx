{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<pre><code>class ApproveLoan &lt; CMDx::Task\n  on_success :notify_applicant!\n\n  required :application_id, type: :integer\n  optional :override_checks, default: false\n\n  def work\n    if application.nil?\n      fail!(\"Application not found\", code: 404)\n    elsif application.approved?\n      skip!(\"Application already approved\")\n    else\n      application.approve!\n      context.approved_at = Time.current\n    end\n  end\n\n  private\n\n  def application\n    @application ||= LoanApplication.find_by(id: application_id)\n  end\n\n  def notify_applicant!\n    ApprovalMailer.approved(application).deliver_later\n  end\nend\n</code></pre>"},{"location":"SKILL/","title":"CMDx - Ruby Business Logic Framework","text":"<p>CMDx structures business logic through Tasks (single operations) and Workflows (task pipelines) using the CERO pattern.</p>"},{"location":"SKILL/#quick-start","title":"Quick Start","text":"<pre><code>class ProcessPayment &lt; CMDx::Task\n  required :amount, type: :big_decimal, numeric: { min: 0.01 }\n  required :user_id, type: :integer\n  optional :currency, default: \"USD\"\n\n  on_success :send_receipt!\n\n  def work\n    return fail!(\"User not found\", code: 404) if user.nil?\n    return skip!(\"Already processed\") if already_processed?\n\n    context.transaction = Gateway.charge(amount:, currency:)\n    context.processed_at = Time.current\n  end\n\n  private\n\n  def user = @user ||= User.find_by(id: user_id)\n  def already_processed? = context.transaction.present?\n  def send_receipt! = PaymentMailer.receipt(user).deliver_later\nend\n\nresult = ProcessPayment.execute(amount: 99.99, user_id: 123)\nresult.success? &amp;&amp; result.context.transaction\n</code></pre>"},{"location":"SKILL/#cero-pattern","title":"CERO Pattern","text":"<p>CMDx tasks follow the CERO lifecycle \u2014 Compose, Execute, React, Observe:</p> <ol> <li>Compose \u2014 Declare and validate inputs via typed attributes with coercion, defaults, and validators.</li> <li>Execute \u2014 Run business logic in the <code>work</code> method, using <code>fail!</code>/<code>skip!</code>/<code>throw!</code> for control flow.</li> <li>React \u2014 Respond to outcomes via callbacks (<code>on_success</code>, <code>on_failed</code>, etc.) and fluent <code>on</code> handlers.</li> <li>Observe \u2014 Inspect results through the <code>Result</code> object, chain tracking, logging, and pattern matching.</li> </ol>"},{"location":"SKILL/#the-work-method","title":"The <code>work</code> Method","text":"<p>Every task must override <code>work</code>. It is the only required method. Failing to define it raises <code>CMDx::UndefinedMethodError</code>.</p> <pre><code>class MyTask &lt; CMDx::Task\n  def work\n    # Business logic here\n    # Use fail!, skip!, throw! for control flow\n    # Write outputs to context\n  end\nend\n</code></pre> <p>Workflows define <code>work</code> automatically \u2014 you cannot redefine it in a workflow class.</p>"},{"location":"SKILL/#attributes","title":"Attributes","text":""},{"location":"SKILL/#declarations","title":"Declarations","text":"<pre><code>class CreateUser &lt; CMDx::Task\n  required :email, type: :string, format: { with: URI::MailTo::EMAIL_REGEXP }\n  required :age, type: :integer, numeric: { min: 18, max: 120 }\n  optional :role, default: \"user\", inclusion: { in: %w[user admin] }\n  optional :notes, transform: :strip\n\n  # Multiple types (union)\n  required :external_id, types: [:string, :integer]\n\n  # Nested attributes\n  required :address do\n    required :street, :city, type: :string\n    optional :zip, type: :string, length: { is: 5 }\n  end\n\n  # Source from other objects\n  attribute :tenant_id, source: -&gt; { Current.tenant&amp;.id }\n\n  # Conditional requirement\n  required :manager_id, if: :requires_approval?\n\n  def work\n    # Access via method: email, age, role, address[:street]\n    # Or via context: context.email, context.fetch(:role, \"guest\")\n  end\nend\n</code></pre> <p>The <code>required</code>, <code>optional</code>, and <code>attribute</code> (alias <code>attributes</code>) class methods declare inputs:</p> <ul> <li><code>required</code> \u2014 Must be present (sets <code>required: true</code>)</li> <li><code>optional</code> \u2014 May be absent (sets <code>required: false</code>)</li> <li><code>attribute</code> / <code>attributes</code> \u2014 Generic declaration (defaults to <code>required: false</code>)</li> </ul> <p>Multiple attribute names can share the same options: <code>required :first_name, :last_name, type: :string</code></p>"},{"location":"SKILL/#attribute-options-reference","title":"Attribute Options Reference","text":"Option Type Description <code>type:</code> Symbol Single expected type (see Built-in Types) <code>types:</code> Array Multiple accepted types (union) <code>default:</code> Object / Symbol / Proc Default value when absent <code>transform:</code> Symbol / Proc Transform value before validation <code>source:</code> Symbol / String / Proc / Callable Where to read the value (default: <code>:context</code>) <code>as:</code> Symbol / String Override the accessor method name <code>prefix:</code> Symbol / String / <code>true</code> Prefix the method name (<code>true</code> \u2192 <code>\"#{source}_\"</code>) <code>suffix:</code> Symbol / String / <code>true</code> Suffix the method name (<code>true</code> \u2192 <code>\"_#{source}\"</code>) <code>description:</code> String Human-readable description (alias: <code>desc:</code>) <code>if:</code> Symbol / Proc / Callable Conditional \u2014 only validate/require when truthy <code>unless:</code> Symbol / Proc / Callable Conditional \u2014 skip validation/requirement when truthy <code>required:</code> Boolean Explicitly set requirement (used internally)"},{"location":"SKILL/#built-in-types","title":"Built-in Types","text":"Type Coerces from Options <code>:string</code> Any via <code>to_s</code> <code>:integer</code> String, Float Hex/octal support <code>:float</code> String, Integer <code>:big_decimal</code> String, Numeric <code>:precision</code> <code>:boolean</code> \"true\"/\"false\", \"yes\"/\"no\", 0/1 (case-insensitive) <code>:date</code> String <code>:strptime</code> <code>:time</code> String <code>:strptime</code> <code>:datetime</code> String <code>:strptime</code> <code>:array</code> String (JSON) <code>:hash</code> String (JSON) <code>:symbol</code> String <code>:rational</code> String (\"1/2\") <code>:complex</code> String (\"1+2i\") <p>Custom coercions can be registered \u2014 see the Coercions Guide.</p>"},{"location":"SKILL/#validations","title":"Validations","text":"<pre><code>required :email, format: { with: /\\A[\\w+\\-.]+@[a-z\\d\\-]+\\.[a-z]+\\z/i }\nrequired :age, numeric: { min: 18, max: 120 }\nrequired :status, inclusion: { in: %w[active pending] }\nrequired :name, length: { min: 2, max: 100 }\nrequired :banned, absence: true    # Must be nil/blank\nrequired :terms, presence: true    # Must be present\noptional :code, exclusion: { in: %w[admin root] }\n</code></pre> <p>Built-in validators: <code>absence</code>, <code>presence</code>, <code>format</code>, <code>inclusion</code>, <code>exclusion</code>, <code>length</code>, <code>numeric</code>. Custom validators can be registered \u2014 see the Validators Guide.</p>"},{"location":"SKILL/#introspection-removal","title":"Introspection &amp; Removal","text":"<pre><code># Inspect the attribute schema\nCreateUser.attributes_schema\n# =&gt; { email: { name: :email, method_name: :email, required: true, types: [:string], ... }, ... }\n\n# Remove inherited attributes in subclasses\nclass AdminUser &lt; CreateUser\n  remove_attributes :role, :manager_id\nend\n</code></pre>"},{"location":"SKILL/#context","title":"Context","text":"<p>Context is a shared, hash-like object that flows through tasks and workflows. Keys are automatically symbolized.</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Read\n    weight = context.weight          # method_missing accessor\n    destination = context[:destination]  # bracket access\n    rush = context.fetch(:rush, false)   # fetch with default\n    zip = context.dig(:address, :zip)    # nested dig\n\n    # Atomic get-or-set\n    context.fetch_or_store(:cache_key) { compute_expensive_key }\n\n    # Write\n    context.shipping_cost = calculate_cost\n    context.merge!(carrier: \"FedEx\", estimated_days: 3)\n    context.store(:tracking_id, generate_id)\n\n    # Delete / Clear\n    context.delete(:temp_data)\n    # context.clear!  # removes all keys\n\n    # Check existence\n    context.key?(:weight)  # =&gt; true\n\n    # Iteration\n    context.each { |k, v| log(k, v) }\n    context.to_h  # =&gt; { weight: 10, ... }\n\n    # Pass to subtasks (context is shared)\n    ValidateAddress.execute(context)\n  end\nend\n</code></pre> <p>Aliases: <code>merge</code> = <code>merge!</code>, <code>delete</code> = <code>delete!</code>, <code>clear</code> = <code>clear!</code></p>"},{"location":"SKILL/#control-flow","title":"Control Flow","text":"Method When to use Result <code>fail!(reason, **meta)</code> Business rule violated <code>failed?</code> = true <code>skip!(reason, **meta)</code> Nothing to do <code>skipped?</code> = true <code>throw!(result, **meta)</code> Propagate subtask failure Preserves state/status/reason <p><code>fail!</code> and <code>skip!</code> accept: <code>reason</code> (String, optional), <code>halt:</code> (Boolean, default: <code>true</code>), <code>cause:</code> (Exception, optional), <code>**metadata</code>. <code>throw!</code> accepts: <code>result</code> (Result), <code>halt:</code>, <code>cause:</code>, <code>**metadata</code> \u2014 it copies state/status/reason from the given result.</p> <pre><code>def work\n  # Direct failure\n  return fail!(\"Insufficient funds\", code: 402) if insufficient_funds?\n\n  # Propagate failures from subtasks\n  validation = ValidateData.execute(context)\n  throw!(validation) if validation.failed?\n\n  # Skip with metadata\n  return skip!(\"Already processed\", skipped_at: Time.current) if processed?\n\n  # Non-halting failure (continues execution, sets status but doesn't raise)\n  fail!(\"Partial failure\", halt: false) if partial_issue?\nend\n</code></pre>"},{"location":"SKILL/#results","title":"Results","text":""},{"location":"SKILL/#status-state-predicates","title":"Status &amp; State Predicates","text":"<pre><code>result = ProcessPayment.execute(amount: 99.99, user_id: 123)\n\n# States (lifecycle)\nresult.initialized?  # Before execution\nresult.executing?    # During work\nresult.complete?     # Finished successfully\nresult.interrupted?  # Halted (failed or skipped)\nresult.executed?     # complete? || interrupted?\n\n# Statuses (outcome)\nresult.success?      # Completed successfully\nresult.failed?       # Business failure\nresult.skipped?      # Intentionally skipped\n\n# Compound predicates\nresult.good?         # !failed? (success OR skipped)\nresult.ok?           # Alias for good?\nresult.bad?          # !success? (failed OR skipped)\n\n# Retry / rollback predicates\nresult.retried?      # retries &gt; 0\nresult.rolled_back?  # Was rollback called?\n\n# Data access\nresult.context       # Shared context (alias: ctx)\nresult.reason        # Why it failed/skipped (String or nil)\nresult.cause         # Exception that caused interruption (or nil)\nresult.metadata      # Custom metadata hash (Symbol keys)\nresult.retries       # Number of retry attempts (Integer)\nresult.outcome       # \"success\"/\"failed\"/\"skipped\" or state for thrown failures\nresult.index         # Position in the execution chain\nresult.chain         # The execution chain\nresult.errors        # Errors collection (delegated from task)\nresult.dry_run?      # Whether running in dry-run mode\n</code></pre>"},{"location":"SKILL/#fluent-handlers","title":"Fluent Handlers","text":"<p>The <code>on</code> method accepts any predicate name (states, statuses, or compound). Returns <code>self</code> for chaining.</p> <pre><code>result\n  .on(:success) { |r| notify_user(r.context) }\n  .on(:failed) { |r| alert_admin(r.reason) }\n  .on(:skipped) { |r| log_skip(r.reason) }\n  .on(:good) { |r| track_completion(r) }\n  .on(:bad) { |r| track_issue(r) }\n  .on(:interrupted) { |r| cleanup(r) }\n  .on(:retried) { |r| log_retries(r.retries) }\n\n# Multiple predicates (yields if ANY match)\nresult.on(:success, :skipped) { |r| consider_done(r) }\n</code></pre>"},{"location":"SKILL/#pattern-matching","title":"Pattern Matching","text":"<pre><code># Array deconstruction\nstate, status, reason, cause, metadata = result.deconstruct\n\n# Hash deconstruction (Ruby 3.0+)\ncase result\nin { status: \"success\", good: true }\n  redirect_to success_path\nin { status: \"failed\", metadata: { retryable: true } }\n  schedule_retry\nin { bad: true }\n  handle_issue(result.reason)\nend\n\n# Available keys: state, status, reason, cause, metadata, outcome, executed, good, bad\n</code></pre>"},{"location":"SKILL/#failure-analysis","title":"Failure Analysis","text":"<p>When tasks are chained (e.g., in workflows), results track failure provenance:</p> <pre><code>result.caused_failure    # =&gt; Result that originally caused the failure (or nil)\nresult.caused_failure?   # =&gt; true if THIS result caused the failure\nresult.threw_failure     # =&gt; Result that threw/propagated the failure (or nil)\nresult.threw_failure?    # =&gt; true if THIS result threw the failure\nresult.thrown_failure?   # =&gt; true if this is a propagated (not originated) failure\n</code></pre>"},{"location":"SKILL/#errors","title":"Errors","text":"<p>Validation errors are collected in an <code>Errors</code> object, accessible from both the task and result:</p> <pre><code>result.errors.empty?            # =&gt; true/false\nresult.errors.for?(:email)      # =&gt; true if email has errors\nresult.errors.to_h              # =&gt; { email: [\"is invalid\"], age: [\"must be &gt;= 18\"] }\nresult.errors.full_messages     # =&gt; { email: [\"email is invalid\"], age: [\"age must be &gt;= 18\"] }\nresult.errors.to_hash(true)     # =&gt; full_messages format\nresult.errors.to_s              # =&gt; \"email is invalid. age must be &gt;= 18\"\n</code></pre>"},{"location":"SKILL/#bang-execution-faults","title":"Bang Execution &amp; Faults","text":"<pre><code>begin\n  result = ProcessPayment.execute!(amount: 99.99, user_id: 123)\nrescue CMDx::FailFault =&gt; e\n  e.result.reason        # Error message\n  e.context.user_id      # Input data\n  e.chain.id             # Execution chain ID\nrescue CMDx::SkipFault =&gt; e\n  e.result.reason        # Skip reason\nend\n</code></pre> <p><code>execute!</code> raises faults when the result status matches the configured <code>breakpoints</code> (default: <code>[\"failed\"]</code>).</p>"},{"location":"SKILL/#fault-matching","title":"Fault Matching","text":"<p>Use <code>for?</code> and <code>matches?</code> to create targeted rescue clauses:</p> <pre><code>begin\n  result = ProcessCheckouts.execute!(items:, user:)\nrescue CMDx::FailFault.for?(ProcessPayment, ChargeCard) =&gt; e\n  # Only catches failures from ProcessPayment or ChargeCard tasks\n  handle_payment_failure(e)\nrescue CMDx::FailFault.matches? { |f| f.result.metadata[:retryable] } =&gt; e\n  # Only catches failures where metadata[:retryable] is truthy\n  schedule_retry(e)\nrescue CMDx::FailFault =&gt; e\n  # Catches all other failures\n  handle_generic_failure(e)\nend\n</code></pre>"},{"location":"SKILL/#block-yielding","title":"Block Yielding","text":"<p>Both <code>execute</code> and <code>execute!</code> accept blocks:</p> <pre><code>ProcessPayment.execute(amount: 99.99) do |result|\n  result.on(:success) { |r| redirect_to(r.ctx.receipt_url) }\n  result.on(:failed) { |r| render_error(r.reason) }\nend\n</code></pre>"},{"location":"SKILL/#callbacks","title":"Callbacks","text":"<p>All 10 callback types, with execution order:</p> Phase Callback Fires when Pre <code>before_validation</code> Before attribute validation Pre <code>before_execution</code> Before <code>work</code> runs Post <code>on_complete</code> State = complete Post <code>on_interrupted</code> State = interrupted Post <code>on_executed</code> State = complete OR interrupted Post <code>on_success</code> Status = success Post <code>on_skipped</code> Status = skipped Post <code>on_failed</code> Status = failed Post <code>on_good</code> good? = true (success or skipped) Post <code>on_bad</code> bad? = true (failed or skipped) <pre><code>class ProcessOrder &lt; CMDx::Task\n  before_validation :normalize_inputs\n  before_execution :setup\n\n  on_complete :always_run\n  on_success :notify_user\n  on_failed :alert_admin\n  on_skipped :log_skip\n  on_good :track_completion\n  on_bad :track_issue\n\n  # Conditional callbacks\n  on_success :send_email, if: :email_enabled?\n  on_failed :page_oncall, unless: :business_hours?\n\n  # Block callbacks\n  on_success { logger.info(\"Order processed\") }\n\n  # Callable objects\n  on_failed AuditLogger\nend\n</code></pre> <p>Callables: Symbol (method name), Proc (instance_exec'd), or any object responding to <code>call(task)</code>.</p>"},{"location":"SKILL/#workflows","title":"Workflows","text":"<p>Workflows orchestrate multiple tasks through a shared context:</p> <pre><code>class ProcessOrders &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateCart\n  task ProcessPayment, if: :payment_required?\n  task CreateOrder\n  task SendConfirmation, unless: :guest_checkout?\n\n  # Grouped tasks with shared config\n  tasks NotifyWarehouse, UpdateInventory, breakpoints: []\n\n  # Parallel execution (requires 'parallel' gem)\n  tasks SendEmail, SendSMS, SendPush, strategy: :parallel\n  tasks HeavyTask1, HeavyTask2, strategy: :parallel, in_threads: 4\n\n  private\n\n  def payment_required? = context.total.positive?\n  def guest_checkout? = context.user.guest?\nend\n</code></pre> <p>Workflow options:</p> Option Type Description <code>if:</code> Symbol / Proc / Callable Execute group only when truthy <code>unless:</code> Symbol / Proc / Callable Skip group when truthy <code>breakpoints:</code> Array Statuses that halt the workflow (default: <code>[\"failed\"]</code>) <code>strategy:</code> Symbol / String <code>:sequential</code> (default) or <code>:parallel</code> <code>in_threads:</code> Integer Thread count for parallel strategy <code>in_processes:</code> Integer Process count for parallel strategy <p>Access the pipeline definition: <code>ProcessOrders.pipeline</code> \u2192 <code>Array&lt;ExecutionGroup&gt;</code></p>"},{"location":"SKILL/#middleware","title":"Middleware","text":"<pre><code>class ApplicationTask &lt; CMDx::Task\n  register :middleware, CMDx::Middlewares::Correlate, id: -&gt; { Current.request_id }\n  register :middleware, CMDx::Middlewares::Timeout, seconds: 30\n  register :middleware, CMDx::Middlewares::Runtime\nend\n</code></pre>"},{"location":"SKILL/#built-in-middlewares","title":"Built-in Middlewares","text":"Middleware Effect Key options <code>Correlate</code> Thread-safe correlation ID tracking <code>id:</code> (Symbol/Proc/String), <code>if:</code>, <code>unless:</code> <code>Timeout</code> Enforces time limit (raises <code>CMDx::TimeoutError</code>) <code>seconds:</code> (Numeric/Symbol/Proc, default: 3), <code>if:</code>, <code>unless:</code> <code>Runtime</code> Measures execution time in ms <code>if:</code>, <code>unless:</code> <p>Access correlation ID: <code>CMDx::Middlewares::Correlate.id</code> Runtime stored in: <code>result.metadata[:runtime]</code></p>"},{"location":"SKILL/#custom-middleware","title":"Custom Middleware","text":"<pre><code>module AuditMiddleware\n  extend self\n\n  def call(task, **options)\n    result = yield\n    AuditLog.record(task.class.name, result.status) unless task.dry_run?\n    result\n  end\nend\n\nregister :middleware, AuditMiddleware\n</code></pre>"},{"location":"SKILL/#retries","title":"Retries","text":"<pre><code>class FetchExternalData &lt; CMDx::Task\n  settings(\n    retries: 3,\n    retry_on: [Net::ReadTimeout, Faraday::TimeoutError],\n    retry_jitter: 2  # Linear delay: jitter * retry_count (seconds)\n  )\n\n  # Exponential backoff via proc\n  # settings retry_jitter: -&gt;(n) { 2 ** n }  # 2s, 4s, 8s...\n\n  # Backoff via method name\n  # settings retry_jitter: :compute_delay\n\n  def work\n    context.data = ExternalAPI.fetch(context.id)\n  end\n\n  # private\n  # def compute_delay(retry_count) = 2 ** retry_count\nend\n</code></pre> <p>Retry settings:</p> Setting Type Default Description <code>retries:</code> Integer <code>0</code> Maximum retry attempts <code>retry_on:</code> Array\\&lt;Class&gt; <code>[StandardError]</code> Exception classes to retry on <code>retry_jitter:</code> Numeric / Symbol / Proc / Callable <code>nil</code> Delay between retries <p>Jitter evaluation: Numeric \u2192 <code>jitter * retry_count</code>, Symbol \u2192 <code>task.send(sym, count)</code>, Proc \u2192 <code>instance_exec(count)</code>, Callable \u2192 <code>.call(task, count)</code>.</p> <p>After retries, <code>result.retries</code> reflects the count and <code>result.retried?</code> returns <code>true</code>.</p>"},{"location":"SKILL/#rollback","title":"Rollback","text":"<pre><code>class ChargeCard &lt; CMDx::Task\n  def work\n    context.charge = StripeApi.charge(context.amount)\n  end\n\n  def rollback\n    StripeApi.refund(context.charge.id) if context.charge\n  end\nend\n</code></pre> <p>Rollback runs automatically after execution when <code>result.status</code> matches <code>rollback_on</code> (default: <code>[\"failed\"]</code>). After rollback, <code>result.rolled_back?</code> returns <code>true</code>. Implement a <code>rollback</code> instance method to opt in.</p>"},{"location":"SKILL/#dry-run","title":"Dry Run","text":"<p>Pass <code>dry_run: true</code> in the context to signal dry-run mode. The flag is inherited by all nested/subtask executions in the chain.</p> <pre><code>result = ProcessPayment.execute(amount: 99.99, user_id: 123, dry_run: true)\nresult.dry_run?  # =&gt; true\n\n# Inside work:\ndef work\n  return skip!(\"Dry run\") if dry_run?\n  # ... real logic\nend\n</code></pre> <p><code>dry_run?</code> is available on the task, result, and chain objects.</p>"},{"location":"SKILL/#deprecation","title":"Deprecation","text":"<p>Mark tasks as deprecated to warn or prevent usage:</p> <pre><code>class LegacyTask &lt; CMDx::Task\n  settings deprecate: \"warn\"  # Outputs to stderr via Kernel#warn\nend\n\n# Other deprecation modes:\n# settings deprecate: \"log\"    # Logs warning via task logger\n# settings deprecate: \"raise\"  # Raises CMDx::DeprecationError\n# settings deprecate: true     # Same as \"raise\"\n# settings deprecate: false    # No deprecation (default)\n# settings deprecate: :check_deprecation  # Calls method, evaluates return value\n# settings deprecate: -&gt; { Date.today &gt; Date.new(2026, 6, 1) ? \"raise\" : \"warn\" }\n</code></pre>"},{"location":"SKILL/#logging","title":"Logging","text":""},{"location":"SKILL/#log-formatters","title":"Log Formatters","text":"<p>Set via configuration or task settings:</p> <pre><code>CMDx.configure do |config|\n  config.logger = Logger.new($stdout, progname: \"cmdx\")\n  config.logger.formatter = CMDx::LogFormatters::JSON.new\nend\n</code></pre> Formatter Output <code>LogFormatters::Line</code> Human-readable single line (default) <code>LogFormatters::JSON</code> Structured JSON with severity, timestamp, pid <code>LogFormatters::KeyValue</code> <code>key=value</code> pairs <code>LogFormatters::Logstash</code> Logstash-compatible JSON <code>LogFormatters::Raw</code> Unformatted message"},{"location":"SKILL/#backtrace-logging","title":"Backtrace Logging","text":"<pre><code>class ApplicationTask &lt; CMDx::Task\n  settings(\n    backtrace: true,  # Log exception backtraces on failure\n    backtrace_cleaner: -&gt;(bt) { bt.reject { |l| l.include?(\"/gems/\") }.first(10) }\n  )\nend\n</code></pre>"},{"location":"SKILL/#exception-handler","title":"Exception Handler","text":"<pre><code>class ApplicationTask &lt; CMDx::Task\n  settings exception_handler: -&gt;(task, error) { Sentry.capture_exception(error) }\nend\n</code></pre> <p>Called when a <code>StandardError</code> (non-fault) is rescued during execution.</p>"},{"location":"SKILL/#configuration","title":"Configuration","text":"<pre><code>CMDx.configure do |config|\n  # Breakpoints \u2014 statuses that trigger execute! to raise\n  config.task_breakpoints = [\"failed\"]          # Default\n  config.workflow_breakpoints = [\"failed\"]      # Default\n\n  # Rollback \u2014 statuses that trigger rollback\n  config.rollback_on = [\"failed\"]               # Default\n\n  # Logging\n  config.logger = Rails.logger\n  config.backtrace = false                      # Default\n  config.backtrace_cleaner = nil                # Default (Proc or nil)\n  config.exception_handler = nil                # Default (Proc or nil)\n\n  # Global middleware\n  config.middlewares.register CMDx::Middlewares::Runtime\n\n  # Global callbacks\n  config.callbacks.register :on_failed, ErrorTracker\nend\n</code></pre> <p>Reset to defaults: <code>CMDx.reset_configuration!</code></p>"},{"location":"SKILL/#i18n-support","title":"I18n Support","text":"<p>CMDx ships with 80+ locale files for validation and fault messages. In Rails, the railtie auto-loads them. Custom locale files can be generated:</p> <pre><code>rails generate cmdx:locale\n</code></pre>"},{"location":"SKILL/#task-settings","title":"Task Settings","text":"<p>Per-task settings override global configuration and inherit from parent classes:</p> <pre><code>class GenerateInvoice &lt; CMDx::Task\n  settings(\n    # Breakpoints\n    breakpoints: [\"failed\"],            # Task-level breakpoints (overrides task_breakpoints)\n\n    # Retries\n    retries: 3,\n    retry_on: [StandardError],\n    retry_jitter: 2,\n\n    # Rollback\n    rollback_on: [\"failed\"],\n\n    # Logging\n    log_level: :info,\n    backtrace: true,\n    backtrace_cleaner: nil,\n    exception_handler: nil,\n\n    # Tags\n    tags: [\"billing\"],\n\n    # Deprecation\n    deprecate: false\n  )\nend\n</code></pre> <p>Inheritance: All settings inherit from the parent class, except <code>backtrace_cleaner</code>, <code>exception_handler</code>, <code>logger</code>, and <code>deprecate</code> which fall back to global configuration.</p>"},{"location":"SKILL/#register-deregister","title":"Register / Deregister","text":"<pre><code>class MyTask &lt; CMDx::Task\n  # Register custom components\n  register :middleware, CustomMiddleware\n  register :callback, :on_success, :notify\n  register :validator, :custom, CustomValidator\n  register :coercion, :money, MoneyCoercion\n\n  # Remove inherited components\n  deregister :middleware, CustomMiddleware\n  deregister :callback, :on_success, :notify\nend\n</code></pre>"},{"location":"SKILL/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Tasks: Verb + noun \u2192 <code>ProcessPayment</code>, <code>ValidateOrder</code>, <code>CreateUser</code></li> <li>Workflows: Verb + noun (plural) \u2192 <code>SendNotifications</code>, <code>ProcessOrders</code>, <code>SyncAccounts</code></li> <li>Namespaces: Domain \u2192 <code>Billing::GenerateInvoice</code>, <code>Shipping::CreateLabel</code></li> </ul>"},{"location":"SKILL/#best-practices","title":"Best Practices","text":"<ol> <li>Single responsibility: One task = one operation</li> <li>Use context for data sharing: <code>context.output = value</code></li> <li>Control flow via fail!/skip!: Not exceptions</li> <li>Memoize lookups: <code>def user = @user ||= User.find(id)</code></li> <li>Validate at boundaries: Use typed attributes with validators</li> <li>Define rollback: For any reversible side effects</li> <li>Use dry_run: For safe previewing of destructive operations</li> <li>Inherit from ApplicationTask: Set shared middleware, logging, and settings once</li> </ol>"},{"location":"SKILL/#rails-generators","title":"Rails Generators","text":"<pre><code>rails generate cmdx:install                # Config initializer\nrails generate cmdx:task ProcessPayment    # Task file\nrails generate cmdx:workflow SyncAccounts  # Workflow file\nrails generate cmdx:locale                 # I18n locale files\n</code></pre>"},{"location":"SKILL/#exceptions-reference","title":"Exceptions Reference","text":"Class Parent Raised when <code>CMDx::Error</code> <code>StandardError</code> Base exception (alias: <code>CMDx::Exception</code>) <code>CMDx::Fault</code> <code>Error</code> Base fault (has <code>.result</code>, <code>.task</code>, <code>.context</code>, <code>.chain</code>) <code>CMDx::FailFault</code> <code>Fault</code> Task failed and halt triggered <code>CMDx::SkipFault</code> <code>Fault</code> Task skipped and halt triggered <code>CMDx::CoercionError</code> <code>Error</code> Attribute type coercion failed <code>CMDx::ValidationError</code> <code>Error</code> Attribute validation failed <code>CMDx::DeprecationError</code> <code>Error</code> Deprecated task used with <code>deprecate: true/\"raise\"</code> <code>CMDx::UndefinedMethodError</code> <code>Error</code> <code>work</code> method not implemented <code>CMDx::TimeoutError</code> <code>Interrupt</code> Timeout middleware limit exceeded"},{"location":"SKILL/#references","title":"References","text":"<ul> <li>Full Documentation</li> <li>Attributes Guide</li> <li>Workflows Guide</li> <li>GitHub</li> </ul>"},{"location":"callbacks/","title":"Callbacks","text":"<p>Run custom logic at specific points during task execution. Callbacks have full access to task context and results, making them perfect for logging, notifications, cleanup, and more.</p> <p>See Global Configuration for framework-wide callback setup.</p> <p>Important</p> <p>Callbacks execute in declaration order (FIFO). Multiple callbacks of the same type run sequentially.</p>"},{"location":"callbacks/#available-callbacks","title":"Available Callbacks","text":"<p>Callbacks execute in a predictable lifecycle order:</p> <pre><code>1. before_validation           # Pre-validation setup\n2. before_execution            # Prepare for execution\n\n# --- Task#work executes ---\n\n3. on_[complete|interrupted]   # State-based (execution lifecycle)\n4. on_executed                 # Always runs after work completes\n5. on_[success|skipped|failed] # Status-based (business outcome)\n6. on_[good|bad]               # Outcome-based (success/skip vs fail)\n</code></pre>"},{"location":"callbacks/#declarations","title":"Declarations","text":""},{"location":"callbacks/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for simple callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  before_execution :find_reservation\n\n  # Batch declarations (works for any type)\n  on_complete :notify_guest, :update_availability\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def find_reservation\n    @reservation ||= Reservation.find(context.reservation_id)\n  end\n\n  def notify_guest\n    GuestNotifier.call(context.guest, result)\n  end\n\n  def update_availability\n    AvailabilityService.update(context.room_ids, result)\n  end\nend\n</code></pre>"},{"location":"callbacks/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for inline callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Proc\n  on_interrupted proc { ReservationSystem.pause! }\n\n  # Lambda\n  on_complete -&gt; { ReservationSystem.resume! }\nend\n</code></pre>"},{"location":"callbacks/#class-or-module","title":"Class or Module","text":"<p>Implement reusable callback logic in dedicated modules and classes:</p> <pre><code>class BookingConfirmationCallback\n  def call(task)\n    if task.result.success?\n      MessagingApi.send_confirmation(task.context.guest)\n    else\n      MessagingApi.send_issue_alert(task.context.manager)\n    end\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # Class or Module\n  on_success BookingConfirmationCallback\n\n  # Instance\n  on_interrupted BookingConfirmationCallback.new\nend\n</code></pre>"},{"location":"callbacks/#conditional-execution","title":"Conditional Execution","text":"<p>Control callback execution with conditional logic:</p> <pre><code>class MessagingPermissionCheck\n  def call(task)\n    task.context.guest.can?(:receive_messages)\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # If and/or Unless\n  before_execution :notify_guest, if: :messaging_enabled?, unless: :messaging_blocked?\n\n  # Proc\n  on_failure :increment_failure, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Legacy\") }\n\n  # Lambda\n  on_success :ping_housekeeping, if: proc { context.rooms_need_cleaning? }\n\n  # Class or Module\n  on_complete :send_confirmation, unless: MessagingPermissionCheck\n\n  # Instance\n  on_complete :send_confirmation, if: MessagingPermissionCheck.new\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def messaging_enabled?\n    context.guest.messaging_preference == true\n  end\n\n  def messaging_blocked?\n    context.guest.communication_status == :blocked\n  end\nend\n</code></pre>"},{"location":"callbacks/#callback-removal","title":"Callback Removal","text":"<p>Remove unwanted callbacks dynamically:</p> <p>Important</p> <p>Each <code>deregister</code> call removes one callback. Use multiple calls for batch removals.</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Symbol\n  deregister :callback, :before_execution, :notify_guest\n\n  # Class or Module (no instances)\n  deregister :callback, :on_complete, BookingConfirmationCallback\nend\n</code></pre>"},{"location":"comparison/","title":"Comparison","text":""},{"location":"comparison/#alternative-frameworks","title":"Alternative Frameworks","text":"<p>CMDx stands apart by combining zero external dependencies with production-grade observability and a comprehensive type coercion system\u2014all in a single, cohesive package. While other gems excel in specific areas, CMDx delivers the full stack: structured logging with correlation IDs, automatic runtime metrics, 20+ built-in type coercers, extensible middleware, and fault tolerance patterns\u2014without pulling in a single additional dependency.</p> Feature CMDx Actor Interactor ActiveInteraction LightService Zero dependencies \u2705 \u2705 \u2705 \u274c \u2705 Typed attributes \u2705 \u2705 \u274c \u2705 \u274c Type coercion \u2705 \u274c \u274c \u2705 \u274c Attribute validation \u2705 \u2705 \u274c \u2705 \u274c Built-in logging \u2705 \u274c \u274c \u274c \u274c Correlation IDs \u2705 \u274c \u274c \u274c \u274c Runtime metrics \u2705 \u274c \u274c \u274c \u274c Middleware system \u2705 \u274c \u274c \u274c \u2705 Batch execution \u2705 \u2705 \u274c \u2705 \u274c Fault tolerance \u2705 \u274c \u274c \u274c \u274c Lifecycle callbacks \u2705 \u2705 \u2705 \u2705 \u2705 RBS type signatures \u2705 \u274c \u274c \u274c \u274c <p>Key differentiators:</p> <ul> <li> <p>Observability out of the box \u2014 Structured logging, chain correlation, and runtime metrics are built-in, not bolted on. Trace complex workflows across services without additional instrumentation.</p> </li> <li> <p>Comprehensive type system \u2014 20+ coercers handle everything from primitives to dates, arrays, and custom types. Validation rules like <code>numeric</code>, <code>format</code>, and <code>inclusion</code> ensure data integrity before execution.</p> </li> <li> <p>Extensible middleware \u2014 Inject cross-cutting concerns (authentication, rate limiting, telemetry) without modifying task logic. Middleware composes cleanly and executes in predictable order.</p> </li> <li> <p>Fault tolerance patterns \u2014 Built-in retry policies with exponential backoff, circuit breakers, and timeout handling. Production-ready resilience without external gems.</p> </li> <li> <p>Framework agnostic \u2014 Works seamlessly with Rails, Hanami, Sinatra, or plain Ruby. No ActiveSupport dependency, no framework lock-in.</p> </li> </ul>"},{"location":"comparison/#event-sourcing-replacement","title":"Event Sourcing Replacement","text":"<p>Traditional Event Sourcing architectures impose a significant \"complexity tax\"\u2014requiring specialized event stores, snapshots, and complex state rehydration logic. CMDx offers a pragmatic alternative: Log-Based Event Sourcing.</p> <p>By ensuring all state changes occur through CMDx tasks, your structured logs become a complete, immutable ledger of system behavior.</p> <ul> <li> <p>Audit Trail: Every execution is automatically logged with its inputs, status, and metadata. This provides a detailed history of intent (arguments) and outcome (success/failure) without extra coding.</p> </li> <li> <p>Reconstructability Because commands encapsulate all inputs required for an action, you can reconstruct past system states or replay business logic by inspecting the command history, giving you the traceability of Event Sourcing without the infrastructure overhead.</p> </li> <li> <p>Simplified Architecture Keep your standard relational database for current state queries (the \"Read Model\") while using CMDx logs as your historical record (the \"Write Model\"). This gives you CQRS-like benefits without the complexity of maintaining separate projections.</p> </li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Configure CMDx to customize framework behavior, register components, and control execution flow through global defaults with task-level overrides.</p>"},{"location":"configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>CMDx uses a straightforward two-tier configuration system:</p> <ol> <li>Global Configuration \u2014 Framework-wide defaults</li> <li>Task Settings \u2014 Class-level overrides using <code>settings</code></li> </ol> <p>Important</p> <p>Task settings take precedence over global config. Settings are inherited from parent classes and can be overridden in subclasses.</p>"},{"location":"configuration/#global-configuration","title":"Global Configuration","text":"<p>Configure framework-wide defaults that apply to all tasks. These settings come with sensible defaults out of the box.</p>"},{"location":"configuration/#breakpoints","title":"Breakpoints","text":"<p>Control when <code>execute!</code> raises a <code>CMDx::Fault</code> based on task status.</p> <pre><code>CMDx.configure do |config|\n  config.task_breakpoints = \"failed\" # String or Array[String]\nend\n</code></pre> <p>For workflows, configure which statuses halt the execution pipeline:</p> <pre><code>CMDx.configure do |config|\n  config.workflow_breakpoints = [\"skipped\", \"failed\"]\nend\n</code></pre>"},{"location":"configuration/#rollback","title":"Rollback","text":"<p>Control when a <code>rollback</code> of task execution is called.</p> <pre><code>CMDx.configure do |config|\n  config.rollback_on = [\"failed\"] # String or Array[String]\nend\n</code></pre>"},{"location":"configuration/#backtraces","title":"Backtraces","text":"<p>Enable detailed backtraces for non-fault exceptions to improve debugging. Optionally clean up stack traces to remove framework noise.</p> <p>Note</p> <p>In Rails environments, <code>backtrace_cleaner</code> defaults to <code>Rails.backtrace_cleaner.clean</code>.</p> <pre><code>CMDx.configure do |config|\n  # Truthy\n  config.backtrace = true\n\n  # Via callable (must respond to `call(backtrace)`)\n  config.backtrace_cleaner = AdvanceCleaner.new\n\n  # Via proc or lambda\n  config.backtrace_cleaner = -&gt;(backtrace) { backtrace[0..5] }\nend\n</code></pre>"},{"location":"configuration/#exception-handlers","title":"Exception Handlers","text":"<p>Register handlers that run when non-fault exceptions occur.</p> <p>Tip</p> <p>Use exception handlers to send errors to your APM of choice.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, exception)`)\n  config.exception_handler = NewRelicReporter\n\n  # Via proc or lambda\n  config.exception_handler = proc do |task, exception|\n    APMService.report(exception, extra_data: { task: task.name, id: task.id })\n  end\nend\n</code></pre>"},{"location":"configuration/#logging","title":"Logging","text":"<pre><code>CMDx.configure do |config|\n  config.logger = CustomLogger.new($stdout)\nend\n</code></pre>"},{"location":"configuration/#middlewares","title":"Middlewares","text":"<p>See the Middlewares docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, options)`)\n  config.middlewares.register CMDx::Middlewares::Timeout\n\n  # Via proc or lambda\n  config.middlewares.register proc { |task, options|\n    start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    result = yield\n    end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    Rails.logger.debug { \"task completed in #{((end_time - start_time) * 1000).round(2)}ms\" }\n    result\n  }\n\n  # With options\n  config.middlewares.register AuditTrailMiddleware, service_name: \"document_processor\"\n\n  # Remove middleware\n  config.middlewares.deregister CMDx::Middlewares::Timeout\nend\n</code></pre> <p>Note</p> <p>Middlewares are executed in registration order. Each middleware wraps the next, creating an execution chain around task logic.</p>"},{"location":"configuration/#callbacks","title":"Callbacks","text":"<p>See the Callbacks docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via method\n  config.callbacks.register :before_execution, :initialize_user_session\n\n  # Via callable (must respond to `call(task)`)\n  config.callbacks.register :on_success, LogUserActivity\n\n  # Via proc or lambda\n  config.callbacks.register :on_complete, proc { |task|\n    execution_time = task.metadata[:runtime]\n    Metrics.timer(\"task.execution_time\", execution_time, tags: [\"task:#{task.class.name.underscore}\"])\n  }\n\n  # With options\n  config.callbacks.register :on_failure, :send_alert_notification, if: :critical_task?\n\n  # Remove callback\n  config.callbacks.deregister :on_success, LogUserActivity\nend\n</code></pre>"},{"location":"configuration/#coercions","title":"Coercions","text":"<p>See the Attributes - Coercions docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.coercions.register :currency, CurrencyCoercion\n\n  # Via method (must match signature `def coordinates_coercion(value, options)`)\n  config.coercions.register :coordinates, :coordinates_coercion\n\n  # Via proc or lambda\n  config.coercions.register :tag_list, proc { |value, options|\n    delimiter = options[:delimiter] || ','\n    max_tags = options[:max_tags] || 50\n\n    tags = value.to_s.split(delimiter).map(&amp;:strip).reject(&amp;:empty?)\n    tags.first(max_tags)\n  }\n\n  # Remove coercion\n  config.coercions.deregister :currency\nend\n</code></pre>"},{"location":"configuration/#validators","title":"Validators","text":"<p>See the Attributes - Validations docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.validators.register :username, UsernameValidator\n\n  # Via method (must match signature `def url_validator(value, options)`)\n  config.validators.register :url, :url_validator\n\n  # Via proc or lambda\n  config.validators.register :access_token, proc { |value, options|\n    expected_prefix = options[:prefix] || \"tok_\"\n    minimum_length = options[:min_length] || 40\n\n    value.start_with?(expected_prefix) &amp;&amp; value.length &gt;= minimum_length\n  }\n\n  # Remove validator\n  config.validators.deregister :username\nend\n</code></pre>"},{"location":"configuration/#task-configuration","title":"Task Configuration","text":""},{"location":"configuration/#settings","title":"Settings","text":"<p>Override global configuration for specific tasks using <code>settings</code>:</p> <pre><code>class GenerateInvoice &lt; CMDx::Task\n  settings(\n    # Global configuration overrides\n    task_breakpoints: [\"failed\"],                # Breakpoint override\n    workflow_breakpoints: [],                    # Breakpoint override\n    backtrace: true,                             # Toggle backtrace\n    backtrace_cleaner: -&gt;(bt) { bt[0..5] },      # Backtrace cleaner\n    logger: CustomLogger.new($stdout),           # Custom logger\n\n    # Task configuration settings\n    breakpoints: [\"failed\"],                     # Contextual pointer for :task_breakpoints and :workflow_breakpoints\n    log_level: :info,                            # Log level override\n    log_formatter: CMDx::LogFormatters::Json.new # Log formatter override\n    tags: [\"billing\", \"financial\"],              # Logging tags\n    deprecate: true,                             # Task deprecations\n    retries: 3,                                  # Non-fault exception retries\n    retry_on: [External::ApiError],              # List of exceptions to retry on\n    retry_jitter: 1,                             # Space between retry iteration, eg: current retry num + 1\n    rollback_on: [\"failed\", \"skipped\"],          # Rollback on override\n  )\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Important</p> <p>Retries reuse the same context. By default, all <code>StandardError</code> exceptions (including faults) are retried unless you specify <code>retry_on</code> option for specific matches.</p>"},{"location":"configuration/#registrations","title":"Registrations","text":"<p>Register or deregister middlewares, callbacks, coercions, and validators for specific tasks:</p> <pre><code>class SendCampaignEmail &lt; CMDx::Task\n  # Middlewares\n  register :middleware, CMDx::Middlewares::Timeout\n  deregister :middleware, AuditTrailMiddleware\n\n  # Callbacks\n  register :callback, :on_complete, proc { |task|\n    runtime = task.metadata[:runtime]\n    Analytics.track(\"email_campaign.sent\", runtime, tags: [\"task:#{task.class.name}\"])\n  }\n  deregister :callback, :before_execution, :initialize_user_session\n\n  # Coercions\n  register :coercion, :currency, CurrencyCoercion\n  deregister :coercion, :coordinates\n\n  # Validators\n  register :validator, :username, :username_validator\n  deregister :validator, :url\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"configuration/#configuration-management","title":"Configuration Management","text":""},{"location":"configuration/#access","title":"Access","text":"<pre><code># Global configuration access\nCMDx.configuration.logger               #=&gt; &lt;Logger instance&gt;\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"]\nCMDx.configuration.middlewares.registry #=&gt; [&lt;Middleware&gt;, ...]\n\n# Task configuration access\nclass ProcessUpload &lt; CMDx::Task\n  settings(tags: [\"files\", \"storage\"])\n\n  def work\n    self.class.settings[:logger] #=&gt; Global configuration value\n    self.class.settings[:tags]   #=&gt; Task configuration value =&gt; [\"files\", \"storage\"]\n  end\nend\n</code></pre>"},{"location":"configuration/#resetting","title":"Resetting","text":"<p>Warning</p> <p>Resetting affects your entire application. Use this primarily in test environments.</p> <pre><code># Reset to framework defaults\nCMDx.reset_configuration!\n\n# Verify reset\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"] (default)\nCMDx.configuration.middlewares.registry #=&gt; Empty registry\n\n# Commonly used in test setup (RSpec example)\nRSpec.configure do |config|\n  config.before(:each) do\n    CMDx.reset_configuration!\n  end\nend\n</code></pre>"},{"location":"deprecation/","title":"Task Deprecation","text":"<p>Manage legacy tasks gracefully with built-in deprecation support. Choose how to handle deprecated tasks\u2014log warnings for awareness, issue Ruby warnings for development, or prevent execution entirely.</p>"},{"location":"deprecation/#modes","title":"Modes","text":""},{"location":"deprecation/#raise","title":"Raise","text":"<p>Prevent task execution completely. Perfect for tasks that must no longer run.</p> <p>Warning</p> <p>Use <code>:raise</code> mode carefully\u2014it will break existing workflows immediately.</p> <pre><code>class ProcessObsoleteAPI &lt; CMDx::Task\n  settings(deprecate: :raise)\n\n  def work\n    # Will never execute...\n  end\nend\n\nresult = ProcessObsoleteAPI.execute\n#=&gt; raises CMDx::DeprecationError: \"ProcessObsoleteAPI usage prohibited\"\n</code></pre>"},{"location":"deprecation/#log","title":"Log","text":"<p>Allow execution while tracking deprecation in logs. Ideal for gradual migrations.</p> <pre><code>class ProcessLegacyFormat &lt; CMDx::Task\n  settings(deprecate: :log)\n  settings(deprecate: true)\n\n  def work\n    # Executes but logs deprecation warning...\n  end\nend\n\nresult = ProcessLegacyFormat.execute\nresult.successful? #=&gt; true\n\n# Deprecation warning appears in logs:\n# WARN -- : DEPRECATED: ProcessLegacyFormat - migrate to replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#warn","title":"Warn","text":"<p>Issue Ruby warnings visible during development and testing. Keeps production logs clean while alerting developers.</p> <pre><code>class ProcessOldData &lt; CMDx::Task\n  settings(deprecate: :warn)\n\n  def work\n    # Executes but emits Ruby warning...\n  end\nend\n\nresult = ProcessOldData.execute\nresult.successful? #=&gt; true\n\n# Ruby warning appears in stderr:\n# [ProcessOldData] DEPRECATED: migrate to a replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#declarations","title":"Declarations","text":""},{"location":"deprecation/#symbol-or-string","title":"Symbol or String","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecate: :raise)\n\n  # String\n  settings(deprecate: \"warn\")\nend\n</code></pre>"},{"location":"deprecation/#boolean-or-nil","title":"Boolean or Nil","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Deprecates with default :log mode\n  settings(deprecate: true)\n\n  # Skips deprecation\n  settings(deprecate: false)\n  settings(deprecate: nil)\nend\n</code></pre>"},{"location":"deprecation/#method","title":"Method","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecate: :deprecated?)\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def deprecated?\n    Time.now.year &gt; 2024 ? :raise : false\n  end\nend\n</code></pre>"},{"location":"deprecation/#proc-or-lambda","title":"Proc or Lambda","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Proc\n  settings(deprecate: proc { Rails.env.development? ? :raise : :log })\n\n  # Lambda\n  settings(deprecate: -&gt; { Current.tenant.legacy_mode? ? :warn : :raise })\nend\n</code></pre>"},{"location":"deprecation/#class-or-module","title":"Class or Module","text":"<pre><code>class OutdatedTaskDeprecator\n  def call(task)\n    task.class.name.include?(\"Outdated\")\n  end\nend\n\nclass OutdatedConnector &lt; CMDx::Task\n  # Class or Module\n  settings(deprecate: OutdatedTaskDeprecator)\n\n  # Instance\n  settings(deprecate: OutdatedTaskDeprecator.new)\nend\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Note</p> <p>Documentation reflects the latest code on <code>main</code>. For version-specific documentation, please refer to the <code>docs/</code> directory within that version's tag.</p> <p>CMDx is a Ruby framework for building maintainable, observable business logic through composable command objects. It brings structure, consistency, and powerful developer tools to your business processes.</p> <p>Common challenges:</p> <ul> <li>Inconsistent service object patterns across your codebase</li> <li>Black boxes make debugging a nightmare</li> <li>Fragile error handling erodes confidence</li> </ul> <p>What you get:</p> <ul> <li>Consistent, standardized architecture</li> <li>Built-in flow control and error handling</li> <li>Composable, reusable workflows</li> <li>Comprehensive logging for observability</li> <li>Attribute validation with type coercions</li> </ul>"},{"location":"getting_started/#requirements","title":"Requirements","text":"<ul> <li>Ruby: MRI 3.1+ or JRuby 9.4+</li> <li>Dependencies: None</li> </ul> <p>Rails support is built-in, but it's framework-agnostic at its core.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Add CMDx to your Gemfile:</p> <pre><code>gem install cmdx\n\n# - or -\n\nbundle add cmdx\n</code></pre>"},{"location":"getting_started/#configuration","title":"Configuration","text":"<p>For Rails applications, run the following command to generate a global configuration file in <code>config/initializers/cmdx.rb</code>.</p> <pre><code>rails generate cmdx:install\n</code></pre> <p>If not using Rails, manually copy the configuration file.</p>"},{"location":"getting_started/#the-cero-pattern","title":"The CERO Pattern","text":"<p>CMDx embraces the Compose, Execute, React, Observe (CERO, pronounced \"zero\") pattern\u2014a simple yet powerful approach to building reliable business logic.</p> <pre><code>flowchart LR\n    Compose --&gt; Execute\n    Execute --&gt; React\n    Execute -.-&gt; Observe</code></pre>"},{"location":"getting_started/#compose","title":"Compose","text":"<p>Build reusable, single-responsibility tasks with typed attributes, validation, and callbacks. Tasks can be chained together in workflows to create complex business processes from simple building blocks.</p> Full Featured TaskMinimum Viable Task <pre><code>class AnalyzeMetrics &lt; CMDx::Task\n  register :middleware, CMDx::Middlewares::Correlate, id: -&gt; { Current.request_id }\n\n  on_success :track_analysis_completion!\n\n  required :dataset_id, type: :integer, numeric: { min: 1 }\n  optional :analysis_type, default: \"standard\"\n\n  def work\n    if dataset.nil?\n      fail!(\"Dataset not found\", code: 404)\n    elsif dataset.unprocessed?\n      skip!(\"Dataset not ready for analysis\")\n    else\n      context.result = PValueAnalyzer.execute(dataset:, analysis_type:)\n      context.analyzed_at = Time.now\n\n      SendAnalyzedEmail.execute(user_id: Current.account.manager_id)\n    end\n  end\n\n  private\n\n  def dataset\n    @dataset ||= Dataset.find_by(id: dataset_id)\n  end\n\n  def track_analysis_completion!\n    dataset.update!(analysis_result_id: context.result.id)\n  end\nend\n</code></pre> <pre><code>class SendAnalyzedEmail &lt; CMDx::Task\n  def work\n    user = User.find(context.user_id)\n    MetricsMailer.analyzed(user).deliver_now\n  end\nend\n</code></pre>"},{"location":"getting_started/#execute","title":"Execute","text":"<p>Invoke tasks with a consistent API that always returns a result object. Execution automatically handles validation, type coercion, error handling, and logging. Arguments are validated and coerced before your task logic runs.</p> With argsWithout args <pre><code>result = AnalyzeMetrics.execute(model: \"blackbox\", \"sensitivity\" =&gt; 3)\n</code></pre> <pre><code>result = AnalyzeMetrics.execute\n</code></pre>"},{"location":"getting_started/#react","title":"React","text":"<p>Every execution returns a result object with a clear outcome. Check the result's state (<code>success?</code>, <code>failed?</code>, <code>skipped?</code>) and access returned values, error messages, and metadata to make informed decisions.</p> <pre><code>if result.success?\n  puts \"Metrics analyzed at #{result.context.analyzed_at}\"\nelsif result.skipped?\n  puts \"Skipping analyzation due to: #{result.reason}\"\nelsif result.failed?\n  puts \"Analyzation failed due to: #{result.reason} with code #{result.metadata[:code]}\"\nend\n</code></pre>"},{"location":"getting_started/#observe","title":"Observe","text":"<p>Every task execution generates structured logs with execution chains, runtime metrics, and contextual metadata. Logs can be automatically correlated using chain IDs, making it easy to trace complex workflows and debug issues.</p> <pre><code>I, [2022-07-17T18:42:37.000000 #3784] INFO -- CMDx:\nindex=1 chain_id=\"018c2b95-23j4-2kj3-32kj-3n4jk3n4jknf\" type=\"Task\" class=\"SendAnalyzedEmail\" state=\"complete\" status=\"success\" metadata={runtime: 347}\n\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"AnalyzeMetrics\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n</code></pre> <p>Note</p> <p>This represents a log-only event-sourcing approach, enabling full traceability and a complete, time-ordered view of system behavior.</p>"},{"location":"getting_started/#domain-driven-design","title":"Domain Driven Design","text":"<p>CMDx facilitates Domain Driven Design (DDD) by making business processes explicit and structural.</p> <ul> <li> <p>Ubiquitous Language: Task names like <code>ApproveLoan</code> or <code>ShipOrder</code> mirror the language of domain experts, creating a shared vocabulary that eliminates translation gaps between business requirements and code.</p> </li> <li> <p>Bounded Contexts: Namespaces naturally enforce boundaries. <code>Billing::GenerateInvoice</code> and <code>Shipping::GenerateLabel</code> encapsulate logic within their specific domains, preventing leakage and \"God objects.\"</p> </li> <li> <p>Rich Domain Layer: Move orchestration and rules out of Controllers and ActiveRecord models. Entities focus on state; CMDx tasks handle behavior. This separation prevents \"Fat Models\" and keeps business logic testable and isolated.</p> </li> </ul>"},{"location":"getting_started/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:task ModerateBlogPost\n</code></pre> <p>This creates a new task file with the basic structure:</p> <pre><code># app/tasks/moderate_blog_post.rb\nclass ModerateBlogPost &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + noun for task names, eg: <code>ModerateBlogPost</code>, <code>ScheduleAppointment</code>, <code>ValidateDocument</code></p>"},{"location":"getting_started/#type-safety","title":"Type safety","text":"<p>CMDx includes built-in RBS (Ruby Type Signature) inline annotations throughout the codebase, providing type information for static analysis and editor support.</p> <ul> <li>Type checking \u2014 Catch type errors before runtime using tools like Steep or TypeProf</li> <li>Better IDE support \u2014 Enhanced autocomplete, navigation, and inline documentation</li> <li>Self-documenting code \u2014 Clear method signatures and return types</li> <li>Refactoring confidence \u2014 Type-aware refactoring reduces bugs</li> </ul>"},{"location":"internationalization/","title":"Internationalization (i18n)","text":"<p>CMDx supports 90+ languages out of the box for all error messages, validations, coercions, and faults. Error messages automatically adapt to the current <code>I18n.locale</code>, making it easy to build applications for global audiences.</p>"},{"location":"internationalization/#usage","title":"Usage","text":"<p>All error messages are automatically localized based on your current locale:</p> <pre><code>class ProcessQuote &lt; CMDx::Task\n  attribute :price, type: :float\n\n  def work\n    # Your logic here...\n  end\nend\n\nI18n.with_locale(:fr) do\n  result = ProcessQuote.execute(price: \"invalid\")\n  result.metadata[:messages][:price] #=&gt; [\"impossible de contraindre en float\"]\nend\n</code></pre>"},{"location":"internationalization/#configuration","title":"Configuration","text":"<p>CMDx uses the <code>I18n</code> gem for localization. In Rails, locales load automatically.</p>"},{"location":"internationalization/#copy-locale-files","title":"Copy Locale Files","text":"<p>Copy locale files to your Rails application's <code>config/locales</code> directory:</p> <pre><code>rails generate cmdx:locale [LOCALE]\n\n# Eg: generate french locale\nrails generate cmdx:locale fr\n</code></pre>"},{"location":"internationalization/#available-locales","title":"Available Locales","text":"<ul> <li>af - Afrikaans</li> <li>ar - Arabic</li> <li>az - Azerbaijani</li> <li>be - Belarusian</li> <li>bg - Bulgarian</li> <li>bn - Bengali</li> <li>bs - Bosnian</li> <li>ca - Catalan</li> <li>cnr - Montenegrin</li> <li>cs - Czech</li> <li>cy - Welsh</li> <li>da - Danish</li> <li>de - German</li> <li>dz - Dzongkha</li> <li>el - Greek</li> <li>en - English</li> <li>eo - Esperanto</li> <li>es - Spanish</li> <li>et - Estonian</li> <li>eu - Basque</li> <li>fa - Persian</li> <li>fi - Finnish</li> <li>fr - French</li> <li>fy - Western Frisian</li> <li>gd - Scottish Gaelic</li> <li>gl - Galician</li> <li>he - Hebrew</li> <li>hi - Hindi</li> <li>hr - Croatian</li> <li>hu - Hungarian</li> <li>hy - Armenian</li> <li>id - Indonesian</li> <li>is - Icelandic</li> <li>it - Italian</li> <li>ja - Japanese</li> <li>ka - Georgian</li> <li>kk - Kazakh</li> <li>km - Khmer</li> <li>kn - Kannada</li> <li>ko - Korean</li> <li>lb - Luxembourgish</li> <li>lo - Lao</li> <li>lt - Lithuanian</li> <li>lv - Latvian</li> <li>mg - Malagasy</li> <li>mk - Macedonian</li> <li>ml - Malayalam</li> <li>mn - Mongolian</li> <li>mr-IN - Marathi (India)</li> <li>ms - Malay</li> <li>nb - Norwegian Bokm\u00e5l</li> <li>ne - Nepali</li> <li>nl - Dutch</li> <li>nn - Norwegian Nynorsk</li> <li>oc - Occitan</li> <li>or - Odia</li> <li>pa - Punjabi</li> <li>pl - Polish</li> <li>pt - Portuguese</li> <li>rm - Romansh</li> <li>ro - Romanian</li> <li>ru - Russian</li> <li>sc - Sardinian</li> <li>sk - Slovak</li> <li>sl - Slovenian</li> <li>sq - Albanian</li> <li>sr - Serbian</li> <li>st - Southern Sotho</li> <li>sv - Swedish</li> <li>sw - Swahili</li> <li>ta - Tamil</li> <li>te - Telugu</li> <li>th - Thai</li> <li>tl - Tagalog</li> <li>tr - Turkish</li> <li>tt - Tatar</li> <li>ug - Uyghur</li> <li>uk - Ukrainian</li> <li>ur - Urdu</li> <li>uz - Uzbek</li> <li>vi - Vietnamese</li> <li>wo - Wolof</li> <li>zh-CN - Chinese (Simplified)</li> <li>zh-HK - Chinese (Hong Kong)</li> <li>zh-TW - Chinese (Traditional)</li> <li>zh-YUE - Chinese (Yue)</li> </ul>"},{"location":"logging/","title":"Logging","text":"<p>CMDx automatically logs every task execution with structured data, making debugging and monitoring effortless. Choose from multiple formatters to match your logging infrastructure.</p>"},{"location":"logging/#formatters","title":"Formatters","text":"<p>Choose the format that works best for your logging system:</p> Formatter Use Case Output Style <code>Line</code> Traditional logging Single-line format <code>Json</code> Structured systems Compact JSON <code>KeyValue</code> Log parsing <code>key=value</code> pairs <code>Logstash</code> ELK stack JSON with @version/@timestamp <code>Raw</code> Minimal output Message content only <p>Sample output:</p> <pre><code>&lt;!-- Success (INFO level) --&gt;\nI, [2025-12-23T17:04:07.292614Z #20108] INFO -- cmdx: {index: 1, chain_id: \"019b4c2b-087b-79be-8ef2-96c11b659df5\", type: \"Task\", tags: [], class: \"GenerateInvoice\", dry_run: false, id: \"019b4c2b-0878-704d-ba0b-daa5410123ec\", state: \"complete\", status: \"success\", outcome: \"success\", metadata: {runtime: 187}}\n\n&lt;!-- Skipped (INFO level) --&gt;\nI, [2025-12-23T17:04:11.496881Z #20139] INFO -- cmdx: {index: 2, chain_id: \"019b4c2b-18e8-7af6-a38b-63b042c4fbed\", type: \"Task\", tags: [], class: \"ValidateCustomer\", dry_run: false, id: \"019b4c2b-18e5-7230-af7e-5b4a4bd7cda2\", state: \"interrupted\", status: \"skipped\", outcome: \"skipped\", metadata: {}, reason: \"Customer already validated\", cause: #&lt;CMDx::SkipFault: Customer already validated&gt;, rolled_back: false}\n\n&lt;!-- Failed (INFO level) --&gt;\nI, [2025-12-23T17:04:15.875306Z #20173] INFO -- cmdx: {index: 3, chain_id: \"019b4c2b-2a02-7dbc-b713-b20a7379704f\", type: \"Task\", tags: [], class: \"CalculateTax\", dry_run: false, id: \"019b4c2b-2a00-70b7-9fab-2f14db9139ef\", state: \"interrupted\", status: \"failed\", outcome: \"failed\", metadata: {error_code: \"TAX_SERVICE_UNAVAILABLE\"}, reason: \"Validation failed\", cause: #&lt;CMDx::FailFault: Validation failed&gt;, rolled_back: false}\n\n&lt;!-- Failed Chain --&gt;\nI, [2025-12-23T17:04:20.972539Z #20209] INFO -- cmdx: {index: 0, chain_id: \"019b4c2b-3de9-71f7-bcc3-2a98836bcfd7\", type: \"Workflow\", tags: [], class: \"BillingWorkflow\", dry_run: false, id: \"019b4c2b-3de6-70b9-9c16-5be13b1a463c\", state: \"interrupted\", status: \"failed\", outcome: \"interrupted\", metadata: {}, reason: \"Validation failed\", cause: #&lt;CMDx::FailFault: Validation failed&gt;, rolled_back: false, threw_failure: {index: 3, chain_id: \"019b4c2b-3de9-71f7-bcc3-2a98836bcfd7\", type: \"Task\", tags: [], class: \"CalculateTax\", id: \"019b4c2b-3dec-70b3-969b-c5b7896e3b27\", state: \"interrupted\", status: \"failed\", outcome: \"failed\", metadata: {error_code: \"TAX_SERVICE_UNAVAILABLE\"}, reason: \"Validation failed\", cause: #&lt;CMDx::FailFault: Validation failed&gt;, rolled_back: false}, caused_failure: {index: 3, chain_id: \"019b4c2b-3de9-71f7-bcc3-2a98836bcfd7\", type: \"Task\", tags: [], class: \"CalculateTax\", id: \"019b4c2b-3dec-70b3-969b-c5b7896e3b27\", state: \"interrupted\", status: \"failed\", outcome: \"failed\", metadata: {error_code: \"TAX_SERVICE_UNAVAILABLE\"}, reason: \"Validation failed\", cause: #&lt;CMDx::FailFault: Validation failed&gt;, rolled_back: false}}\n</code></pre> <p>Tip</p> <p>Use logging as a low-level event stream to track all tasks in a request. Combine with correlation for powerful distributed tracing.</p>"},{"location":"logging/#structure","title":"Structure","text":"<p>Every log entry includes rich metadata. Available fields depend on execution context and outcome.</p>"},{"location":"logging/#core-fields","title":"Core Fields","text":"Field Description Example <code>severity</code> Log level <code>INFO</code>, <code>WARN</code>, <code>ERROR</code> <code>timestamp</code> ISO 8601 execution time <code>2022-07-17T18:43:15.000000</code> <code>pid</code> Process ID <code>3784</code>"},{"location":"logging/#task-information","title":"Task Information","text":"Field Description Example <code>index</code> Execution sequence position <code>0</code>, <code>1</code>, <code>2</code> <code>chain_id</code> Unique execution chain ID <code>018c2b95-b764-7615...</code> <code>type</code> Execution unit type <code>Task</code>, <code>Workflow</code> <code>class</code> Task class name <code>GenerateInvoiceTask</code> <code>id</code> Unique task instance ID <code>018c2b95-b764-7615...</code> <code>tags</code> Custom categorization <code>[\"billing\", \"financial\"]</code>"},{"location":"logging/#execution-data","title":"Execution Data","text":"Field Description Example <code>state</code> Lifecycle state <code>complete</code>, <code>interrupted</code> <code>status</code> Business outcome <code>success</code>, <code>skipped</code>, <code>failed</code> <code>outcome</code> Final classification <code>success</code>, <code>interrupted</code> <code>metadata</code> Custom task data <code>{order_id: 123, amount: 99.99}</code>"},{"location":"logging/#failure-chain","title":"Failure Chain","text":"Field Description <code>reason</code> Reason given for the stoppage <code>caused</code> Cause exception details <code>caused_failure</code> Original failing task details <code>threw_failure</code> Task that propagated the failure"},{"location":"logging/#usage","title":"Usage","text":"<p>Access the framework logger directly within tasks:</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  def work\n    logger.debug { \"Activated feature flags: #{Features.active_flags}\" }\n    # Your logic here...\n    logger.info(\"Subscription processed\")\n  end\nend\n</code></pre>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Wrap task execution with middleware for cross-cutting concerns like authentication, caching, timeouts, and monitoring. Think Rack middleware, but for your business logic.</p> <p>See Global Configuration for framework-wide setup.</p>"},{"location":"middlewares/#execution-order","title":"Execution Order","text":"<p>Middleware wraps task execution in layers, like an onion:</p> <p>Note</p> <p>First registered = outermost wrapper. They execute in registration order.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  register :middleware, AuditMiddleware         # 1st: outermost wrapper\n  register :middleware, AuthorizationMiddleware # 2nd: middle wrapper\n  register :middleware, CacheMiddleware         # 3rd: innermost wrapper\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Execution flow:\n# 1. AuditMiddleware (before)\n# 2.   AuthorizationMiddleware (before)\n# 3.     CacheMiddleware (before)\n# 4.       [task execution]\n# 5.     CacheMiddleware (after)\n# 6.   AuthorizationMiddleware (after)\n# 7. AuditMiddleware (after)\n</code></pre>"},{"location":"middlewares/#declarations","title":"Declarations","text":""},{"location":"middlewares/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple middleware logic:</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Proc\n  register :middleware, proc do |task, options, &amp;block|\n    result = block.call\n    Analytics.track(result.status)\n    result\n  end\n\n  # Lambda\n  register :middleware, -&gt;(task, options, &amp;block) {\n    result = block.call\n    Analytics.track(result.status)\n    result\n  }\nend\n</code></pre>"},{"location":"middlewares/#class-or-module","title":"Class or Module","text":"<p>For complex middleware logic, use classes or modules:</p> <pre><code>class TelemetryMiddleware\n  def call(task, options)\n    result = yield\n    Telemetry.record(result.status)\n  ensure\n    result # Always return result\n  end\nend\n\nclass ProcessCampaign &lt; CMDx::Task\n  # Class or Module\n  register :middleware, TelemetryMiddleware\n\n  # Instance\n  register :middleware, TelemetryMiddleware.new\n\n  # With options\n  register :middleware, MonitoringMiddleware, service_key: ENV[\"MONITORING_KEY\"]\n  register :middleware, MonitoringMiddleware.new(ENV[\"MONITORING_KEY\"])\nend\n</code></pre>"},{"location":"middlewares/#removals","title":"Removals","text":"<p>Remove class or module-based middleware globally or per-task:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one middleware. Use multiple calls for batch removals.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Class or Module (no instances)\n  deregister :middleware, TelemetryMiddleware\nend\n</code></pre>"},{"location":"middlewares/#built-in","title":"Built-in","text":""},{"location":"middlewares/#timeout","title":"Timeout","text":"<p>Prevent tasks from running too long:</p> <pre><code>class ProcessReport &lt; CMDx::Task\n  # Default timeout: 3 seconds\n  register :middleware, CMDx::Middlewares::Timeout\n\n  # Seconds (takes Numeric, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, seconds: :max_processing_time\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, unless: -&gt; { self.class.name.include?(\"Quick\") }\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def max_processing_time\n    Rails.env.production? ? 2 : 10\n  end\nend\n\n# Slow task\nresult = ProcessReport.execute\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failure\"\nresult.reason   #=&gt; \"[CMDx::TimeoutError] execution exceeded 3 seconds\"\nresult.cause    #=&gt; &lt;CMDx::TimeoutError&gt;\nresult.metadata #=&gt; { limit: 3 }\n</code></pre>"},{"location":"middlewares/#correlate","title":"Correlate","text":"<p>Add correlation IDs for distributed tracing and request tracking:</p> <pre><code>class ProcessExport &lt; CMDx::Task\n  # Default correlation ID generation\n  register :middleware, CMDx::Middlewares::Correlate\n\n  # Seconds (takes Object, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, id: proc { |task| task.context.session_id }\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, if: :correlation_enabled?\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def correlation_enabled?\n    ENV[\"CORRELATION_ENABLED\"] == \"true\"\n  end\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { correlation_id: \"550e8400-e29b-41d4-a716-446655440000\" }\n</code></pre>"},{"location":"middlewares/#runtime","title":"Runtime","text":"<p>Track task execution time in milliseconds using a monotonic clock:</p> <pre><code>class PerformanceMonitoringCheck\n  def call(task)\n    task.context.tenant.monitoring_enabled?\n  end\nend\n\nclass ProcessExport &lt; CMDx::Task\n  # Default timeout is 3 seconds\n  register :middleware, CMDx::Middlewares::Runtime\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Runtime, if: PerformanceMonitoringCheck\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { runtime: 1247 } (ms)\n</code></pre>"},{"location":"retries/","title":"Retries","text":"<p>CMDx provides automatic retry functionality for tasks that encounter transient failures. This is essential for handling temporary issues like network timeouts, rate limits, or database locks without manual intervention.</p>"},{"location":"retries/#basic-usage","title":"Basic Usage","text":"<p>Configure retries upto n attempts without any delay.</p> <pre><code>class FetchExternalData &lt; CMDx::Task\n  settings retries: 3\n\n  def work\n    response = HTTParty.get(\"https://api.example.com/data\")\n    context.data = response.parsed_response\n  end\nend\n</code></pre> <p>When an exception occurs during execution, CMDx automatically retries up to the configured limit. Each retry attempt is logged at the <code>warn</code> level with retry metadata. If all retries are exhausted, the task fails with the original exception.</p>"},{"location":"retries/#selective-retries","title":"Selective Retries","text":"<p>By default, CMDx retries on <code>StandardError</code> and its subclasses. Narrow this to specific exception types:</p> <pre><code>class ProcessPayment &lt; CMDx::Task\n  settings retries: 5, retry_on: [Stripe::RateLimitError, Net::ReadTimeout]\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Important</p> <p>Only exceptions matching the <code>retry_on</code> configuration will trigger retries. Uncaught exceptions immediately fail the task.</p>"},{"location":"retries/#retry-jitter","title":"Retry Jitter","text":"<p>Add delays between retry attempts to avoid overwhelming external services or to implement exponential backoff strategies.</p>"},{"location":"retries/#fixed-value","title":"Fixed Value","text":"<p>Use a numeric value to calculate linear delay (<code>jitter * current_retry</code>):</p> <pre><code>class ImportRecords &lt; CMDx::Task\n  settings retries: 3, retry_jitter: 0.5\n\n  def work\n    # Delays: 0s, 0.5s (retry 1), 1.0s (retry 2), 1.5s (retry 3)\n    context.records = ExternalAPI.fetch_records\n  end\nend\n</code></pre>"},{"location":"retries/#symbol-references","title":"Symbol References","text":"<p>Define an instance method for custom delay logic:</p> <pre><code>class SyncInventory &lt; CMDx::Task\n  settings retries: 5, retry_jitter: :exponential_backoff\n\n  def work\n    context.inventory = InventoryAPI.sync\n  end\n\n  private\n\n  def exponential_backoff(current_retry)\n    2 ** current_retry # 2s, 4s, 8s, 16s, 32s\n  end\nend\n</code></pre>"},{"location":"retries/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Pass a proc for inline delay calculations:</p> <pre><code>class PollJobStatus &lt; CMDx::Task\n  # Proc\n  settings retries: 10, retry_jitter: proc { |retry_count| [retry_count * 0.5, 5.0].min }\n\n  # Lambda\n  settings retries: 10, retry_jitter: -&gt;(retry_count) { [retry_count * 0.5, 5.0].min }\n\n  def work\n    # Delays: 0.5s, 1.0s, 1.5s, 2.0s, 2.5s, 3.0s, 3.5s, 4.0s, 4.5s, 5.0s (capped)\n    context.status = JobAPI.check_status(context.job_id)\n  end\nend\n</code></pre>"},{"location":"retries/#class-or-module","title":"Class or Module","text":"<p>Implement reusable delay logic in dedicated modules and classes:</p> <pre><code>class ExponentialBackoff\n  def call(task, retry_count)\n    base_delay = task.context.base_delay || 1.0\n    [base_delay * (2 ** retry_count), 60.0].min\n  end\nend\n\nclass FetchUserProfile &lt; CMDx::Task\n  # Class or Module\n  settings retries: 4, retry_jitter: ExponentialBackoff\n\n  # Instance\n  settings retries: 4, retry_jitter: ExponentialBackoff.new\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"retries/#retry-results","title":"Retry Results","text":"<p>After execution, the result object provides methods to inspect retry behavior:</p> <pre><code>result = FetchExternalData.execute\n\nresult.retries   # =&gt; 2 (number of retry attempts made)\nresult.retried?  # =&gt; true (whether any retries occurred)\n</code></pre> <p>Use these methods for logging, metrics, or conditional post-processing based on retry activity.</p>"},{"location":"tips_and_tricks/","title":"Tips and Tricks","text":"<p>Best practices, patterns, and techniques to build maintainable CMDx applications.</p>"},{"location":"tips_and_tricks/#project-organization","title":"Project Organization","text":""},{"location":"tips_and_tricks/#directory-structure","title":"Directory Structure","text":"<p>Create a well-organized command structure for maintainable applications:</p> <pre><code>/app/\n\u2514\u2500\u2500 /tasks/\n    \u251c\u2500\u2500 /invoices/\n    \u2502   \u251c\u2500\u2500 calculate_tax.rb\n    \u2502   \u251c\u2500\u2500 validate_invoice.rb\n    \u2502   \u251c\u2500\u2500 send_invoice.rb\n    \u2502   \u2514\u2500\u2500 process_invoice.rb # workflow\n    \u251c\u2500\u2500 /reports/\n    \u2502   \u251c\u2500\u2500 generate_pdf.rb\n    \u2502   \u251c\u2500\u2500 compile_data.rb\n    \u2502   \u251c\u2500\u2500 export_csv.rb\n    \u2502   \u2514\u2500\u2500 create_reports.rb # workflow\n    \u251c\u2500\u2500 application_task.rb # base class\n    \u251c\u2500\u2500 authenticate_session.rb\n    \u2514\u2500\u2500 activate_account.rb\n</code></pre>"},{"location":"tips_and_tricks/#naming-conventions","title":"Naming Conventions","text":"<p>Follow consistent naming patterns for clarity and maintainability:</p> <pre><code># Verb + Noun\nclass ExportData &lt; CMDx::Task; end\nclass CompressFile &lt; CMDx::Task; end\nclass ValidateSchema &lt; CMDx::Task; end\n\n# Use present tense verbs for actions\nclass GenerateToken &lt; CMDx::Task; end      # \u2713 Good\nclass GeneratingToken &lt; CMDx::Task; end    # \u274c Avoid\nclass TokenGeneration &lt; CMDx::Task; end    # \u274c Avoid\n</code></pre>"},{"location":"tips_and_tricks/#story-telling","title":"Story Telling","text":"<p>Break down complex logic into descriptive methods that read like a narrative:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    charge_payment_method\n    assign_to_warehouse\n    send_notification\n  end\n\n  private\n\n  def charge_payment_method\n    order.primary_payment_method.charge!\n  end\n\n  def assign_to_warehouse\n    order.ready_for_shipping!\n  end\n\n  def send_notification\n    if order.products_out_of_stock?\n      OrderMailer.pending(order).deliver\n    else\n      OrderMailer.preparing(order).deliver\n    end\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#style-guide","title":"Style Guide","text":"<p>Follow this order for consistent, readable tasks:</p> <pre><code>class ExportReport &lt; CMDx::Task\n\n  # 1. Register functions\n  register :middleware, CMDx::Middlewares::Correlate\n  register :validator, :format, FormatValidator\n\n  # 2. Define callbacks\n  before_execution :find_report\n  on_complete :track_export_metrics, if: -&gt;(task) { Current.tenant.analytics? }\n\n  # 3. Declare attributes\n  attributes :user_id\n  required :report_id\n  optional :format_type\n\n  # 4. Define work method\n  def work\n    report.compile!\n    report.export!\n\n    context.exported_at = Time.now\n  end\n\n  # TIP: Favor private business logic to reduce the surface of the public API.\n  private\n\n  # 5. Build helper functions\n  def find_report\n    @report ||= Report.find(report_id)\n  end\n\n  def track_export_metrics\n    Analytics.increment(:report_exported)\n  end\n\nend\n</code></pre>"},{"location":"tips_and_tricks/#attribute-options","title":"Attribute Options","text":"<p>Use <code>with_options</code> to reduce duplication:</p> <pre><code>class ConfigureCompany &lt; CMDx::Task\n  # Apply common options to multiple attributes\n  with_options(type: :string, presence: true) do\n    attributes :website, format: { with: URI::DEFAULT_PARSER.make_regexp(%w[http https]) }\n    required :company_name, :industry\n    optional :description, format: { with: /\\A[\\w\\s\\-\\.,!?]+\\z/ }\n  end\n\n  # Nested attributes with shared prefix\n  required :headquarters do\n    with_options(prefix: :hq_) do\n      attributes :street, :city, :zip_code, type: :string\n      required :country, type: :string, inclusion: { in: VALID_COUNTRIES }\n      optional :region, type: :string\n    end\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#useful-examples","title":"Useful Examples","text":"<ul> <li>Active Job Durability</li> <li>Active Record Database Transaction</li> <li>Active Record Query Tagging</li> <li>Active Support Instrumentation</li> <li>Flipper Feature Flags</li> <li>Paper Trail Whatdunnit</li> <li>PubSub Task Chaining</li> <li>Redis Idempotency</li> <li>Sentry Error Tracking</li> <li>Sidekiq Async Execution</li> <li>Stoplight Circuit Breaker</li> </ul>"},{"location":"workflows/","title":"Workflows","text":"<p>Compose multiple tasks into powerful, sequential pipelines. Workflows provide a declarative way to build complex business processes with conditional execution, shared context, and flexible error handling.</p>"},{"location":"workflows/#declarations","title":"Declarations","text":"<p>Tasks run in declaration order (FIFO), sharing a common context across the pipeline.</p> <p>Warning</p> <p>Don't define a <code>work</code> method in workflows\u2014the module handles execution automatically.</p>"},{"location":"workflows/#task","title":"Task","text":"<pre><code>class OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateUserProfile\n  task SetupAccountPreferences\n\n  tasks SendWelcomeEmail, SendWelcomeSms, CreateDashboard\nend\n</code></pre>"},{"location":"workflows/#group","title":"Group","text":"<p>Group related tasks to share configuration:</p> <p>Important</p> <p>Settings and conditionals apply to all tasks in the group.</p> <pre><code>class ContentModerationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Screening phase\n  tasks ScanForProfanity, CheckForSpam, ValidateImages, breakpoints: [\"skipped\"]\n\n  # Review phase\n  tasks ApplyFilters, ScoreContent, FlagSuspicious\n\n  # Decision phase\n  tasks PublishContent, QueueForReview, NotifyModerators\nend\n</code></pre>"},{"location":"workflows/#conditionals","title":"Conditionals","text":"<p>Conditionals support multiple syntaxes for flexible execution control:</p> <pre><code>class ContentAccessCheck\n  def call(task)\n    task.context.user.can?(:publish_content)\n  end\nend\n\nclass OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # If and/or Unless\n  task SendWelcomeEmail, if: :email_configured?, unless: :email_disabled?\n\n  # Proc\n  task SendWelcomeEmail, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Premium\") }\n\n  # Lambda\n  task SendWelcomeEmail, if: proc { context.features_enabled? }\n\n  # Class or Module\n  task SendWelcomeEmail, unless: ContentAccessCheck\n\n  # Instance\n  task SendWelcomeEmail, if: ContentAccessCheck.new\n\n  # Conditional applies to all tasks of this declaration group\n  tasks SendWelcomeEmail, CreateDashboard, SetupTutorial, if: :email_configured?\n\n  private\n\n  def email_configured?\n    context.user.email_address == true\n  end\n\n  def email_disabled?\n    context.user.communication_preference == :disabled\n  end\nend\n</code></pre>"},{"location":"workflows/#halt-behavior","title":"Halt Behavior","text":"<p>By default, skipped tasks don't stop the workflow\u2014they're treated as no-ops. Configure breakpoints globally or per-task to customize this behavior.</p> <pre><code>class AnalyticsWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CollectMetrics      # If fails \u2192 workflow stops\n  task FilterOutliers      # If skipped \u2192 workflow continues\n  task GenerateDashboard   # Only runs if no failures occurred\nend\n</code></pre>"},{"location":"workflows/#task-configuration","title":"Task Configuration","text":"<p>Configure halt behavior for the entire workflow:</p> <pre><code>class SecurityWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Halt on both failed and skipped results\n  settings(workflow_breakpoints: [\"skipped\", \"failed\"])\n\n  task PerformSecurityScan\n  task ValidateSecurityRules\nend\n\nclass OptionalTasksWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Never halt, always continue\n  settings(breakpoints: [])\n\n  task TryBackupData\n  task TryCleanupLogs\n  task TryOptimizeCache\nend\n</code></pre>"},{"location":"workflows/#group-configuration","title":"Group Configuration","text":"<p>Different task groups can have different halt behavior:</p> <pre><code>class SubscriptionWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateSubscription, ValidatePayment, workflow_breakpoints: [\"skipped\", \"failed\"]\n\n  # Never halt, always continue\n  task SendConfirmationEmail, UpdateBilling, breakpoints: []\nend\n</code></pre>"},{"location":"workflows/#nested-workflows","title":"Nested Workflows","text":"<p>Build hierarchical workflows by composing workflows within workflows:</p> <pre><code>class EmailPreparationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateRecipients\n  task CompileTemplate\nend\n\nclass EmailDeliveryWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks SendEmails, TrackDeliveries\nend\n\nclass CompleteEmailWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task EmailPreparationWorkflow\n  task EmailDeliveryWorkflow, if: proc { context.preparation_successful? }\n  task GenerateDeliveryReport\nend\n</code></pre>"},{"location":"workflows/#parallel-execution","title":"Parallel Execution","text":"<p>Run tasks concurrently using the Parallel gem which automatically uses all available processors for maximum throughput.</p> <pre><code>class SendWelcomeNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Default options (dynamically calculated to available processors)\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel\n\n  # Fix number of threads\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_threads: 2\n\n  # Fix number of forked processes\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_processes: 2\n\n  # NOTE: Reactors are not supported\nend\n</code></pre> <p>Note</p> <p>This feature depends on the <code>parallel</code> gem being installed in your application or execution environment.</p> <p>Warning</p> <p>Context is read-only during parallel execution. Load all required data beforehand.</p>"},{"location":"workflows/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx workflow tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:workflow SendNotifications\n</code></pre> <p>This creates a new workflow task file with the basic structure:</p> <pre><code># app/tasks/send_notifications.rb\nclass SendNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks Task1, Task2\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + pluralized noun for workflow task names, eg: <code>SendNotifications</code>, <code>DownloadFiles</code>, <code>ValidateDocuments</code></p>"},{"location":"attributes/coercions/","title":"Attributes - Coercions","text":"<p>Automatically convert inputs to expected types. Coercions handle everything from simple string-to-integer conversions to JSON parsing.</p> <p>See Global Configuration for custom coercion setup.</p>"},{"location":"attributes/coercions/#usage","title":"Usage","text":"<p>Define attribute types to enable automatic coercion:</p> <pre><code>class ParseMetrics &lt; CMDx::Task\n  # Coerce into a symbol\n  attribute :measurement_type, type: :symbol\n\n  # Coerce into a rational fallback to big decimal\n  attribute :value, type: [:rational, :big_decimal]\n\n  # Coerce with options\n  attribute :recorded_at, type: :date, strptime: \"%m-%d-%Y\"\n\n  def work\n    measurement_type #=&gt; :temperature\n    recorded_at      #=&gt; &lt;Date 2024-01-23&gt;\n    value            #=&gt; 98.6 (Float)\n  end\nend\n\nParseMetrics.execute(\n  measurement_type: \"temperature\",\n  recorded_at: \"01-23-2020\",\n  value: \"98.6\"\n)\n</code></pre> <p>Tip</p> <p>Specify multiple coercion types for attributes that could be a variety of value formats. CMDx attempts each type in order until one succeeds.</p>"},{"location":"attributes/coercions/#built-in-coercions","title":"Built-in Coercions","text":"Type Options Description Examples <code>:array</code> Array conversion with JSON support <code>\"val\"</code> \u2192 <code>[\"val\"]</code><code>\"[1,2,3]\"</code> \u2192 <code>[1, 2, 3]</code> <code>:big_decimal</code> <code>:precision</code> High-precision decimal <code>\"123.456\"</code> \u2192 <code>BigDecimal(\"123.456\")</code> <code>:boolean</code> Boolean with text patterns <code>\"yes\"</code> \u2192 <code>true</code>, <code>\"no\"</code> \u2192 <code>false</code> <code>:complex</code> Complex numbers <code>\"1+2i\"</code> \u2192 <code>Complex(1, 2)</code> <code>:date</code> <code>:strptime</code> Date objects <code>\"2024-01-23\"</code> \u2192 <code>Date.new(2024, 1, 23)</code> <code>:datetime</code> <code>:strptime</code> DateTime objects <code>\"2024-01-23 10:30\"</code> \u2192 <code>DateTime.new(2024, 1, 23, 10, 30)</code> <code>:float</code> Floating-point numbers <code>\"123.45\"</code> \u2192 <code>123.45</code> <code>:hash</code> Hash conversion with JSON support <code>'{\"a\":1}'</code> \u2192 <code>{\"a\" =&gt; 1}</code> <code>:integer</code> Integer with hex/octal support <code>\"0xFF\"</code> \u2192 <code>255</code>, <code>\"077\"</code> \u2192 <code>63</code> <code>:rational</code> Rational numbers <code>\"1/2\"</code> \u2192 <code>Rational(1, 2)</code> <code>:string</code> String conversion <code>123</code> \u2192 <code>\"123\"</code> <code>:symbol</code> Symbol conversion <code>\"abc\"</code> \u2192 <code>:abc</code> <code>:time</code> <code>:strptime</code> Time objects <code>\"10:30:00\"</code> \u2192 <code>Time.new(2024, 1, 23, 10, 30)</code>"},{"location":"attributes/coercions/#declarations","title":"Declarations","text":"<p>Important</p> <p>Custom coercions must raise <code>CMDx::CoercionError</code> with a descriptive message.</p>"},{"location":"attributes/coercions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple coercion logic:</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  # Proc\n  register :callback, :geolocation, proc do |value, options = {}|\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  end\n\n  # Lambda\n  register :callback, :geolocation, -&gt;(value, options = {}) {\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/coercions/#class-or-module","title":"Class or Module","text":"<p>Register custom coercion logic for specialized type handling:</p> <pre><code>class GeolocationCoercion\n  def self.call(value, options = {})\n    Geolocation(value)\n  rescue StandardError\n    raise CMDx::CoercionError, \"could not convert into a geolocation\"\n  end\nend\n\nclass TransformCoordinates &lt; CMDx::Task\n  register :coercion, :geolocation, GeolocationCoercion\n\n  attribute :latitude, type: :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#removals","title":"Removals","text":"<p>Remove unwanted coercions:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one coercion. Use multiple calls for batch removals.</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  deregister :coercion, :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#error-handling","title":"Error Handling","text":"<p>Coercion failures provide detailed error information including attribute paths, attempted types, and specific failure reasons:</p> <pre><code>class AnalyzePerformance &lt; CMDx::Task\n  attribute  :iterations, type: :integer\n  attribute  :score, type: [:float, :big_decimal]\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = AnalyzePerformance.execute(\n  iterations: \"not-a-number\",\n  score: \"invalid-float\"\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"iterations could not coerce into an integer. score could not coerce into one of: float, big_decimal.\",\n                #       messages: {\n                #         iterations: [\"could not coerce into an integer\"],\n                #         score: [\"could not coerce into one of: float, big_decimal\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/defaults/","title":"Attributes - Defaults","text":"<p>Provide fallback values for optional attributes. Defaults kick in when values aren't provided or are <code>nil</code>.</p>"},{"location":"attributes/defaults/#declarations","title":"Declarations","text":"<p>Defaults work seamlessly with coercions, validations, and nested attributes:</p>"},{"location":"attributes/defaults/#static-values","title":"Static Values","text":"<pre><code>class OptimizeDatabase &lt; CMDx::Task\n  attribute :strategy, default: :incremental\n  attribute :level, default: \"basic\"\n  attribute :notify_admin, default: true\n  attribute :timeout_minutes, default: 30\n  attribute :indexes, default: []\n  attribute :options, default: {}\n\n  def work\n    strategy        #=&gt; :incremental\n    level           #=&gt; \"basic\"\n    notify_admin    #=&gt; true\n    timeout_minutes #=&gt; 30\n    indexes         #=&gt; []\n    options         #=&gt; {}\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic default values:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :granularity, default: :default_granularity\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def default_granularity\n    Current.user.premium? ? \"hourly\" : \"daily\"\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic default values:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, default: proc { Current.tenant.cache_duration || 24 }\n\n  # Lambda\n  attribute :compression, default: -&gt; { Current.tenant.premium? ? \"gzip\" : \"none\" }\nend\n</code></pre>"},{"location":"attributes/defaults/#coercions-and-validations","title":"Coercions and Validations","text":"<p>Defaults follow the same coercion and validation rules as provided values:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, default: \"7\", type: :integer\n\n  # Validations\n  optional :frequency, default: \"daily\", inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/definitions/","title":"Attributes - Definitions","text":"<p>Attributes define your task's interface with automatic validation, type coercion, and accessor generation. They're the contract between callers and your business logic.</p>"},{"location":"attributes/definitions/#declarations","title":"Declarations","text":"<p>Important</p> <p>Attributes are order-dependent, so if you need to reference them as a source or use them in conditions, make sure they\u2019re defined in the correct order.</p> <p>Tip</p> <p>Prefer using the <code>required</code> and <code>optional</code> alias for <code>attributes</code> for brevity and to clearly signal intent.</p>"},{"location":"attributes/definitions/#optional","title":"Optional","text":"<p>Optional attributes return <code>nil</code> when not provided.</p> <pre><code>class ScheduleEvent &lt; CMDx::Task\n  attribute :title\n  attributes :duration, :location\n\n  # Alias for attributes (preferred)\n  optional :description\n  optional :visibility, :attendees\n\n  def work\n    title       #=&gt; \"Team Standup\"\n    duration    #=&gt; 30\n    location    #=&gt; nil\n    description #=&gt; nil\n    visibility  #=&gt; nil\n    attendees   #=&gt; [\"alice@company.com\", \"bob@company.com\"]\n  end\nend\n\n# Attributes passed as keyword arguments\nScheduleEvent.execute(\n  title: \"Team Standup\",\n  duration: 30,\n  attendees: [\"alice@company.com\", \"bob@company.com\"]\n)\n</code></pre>"},{"location":"attributes/definitions/#required","title":"Required","text":"<p>Required attributes must be provided in call arguments or task execution will fail.</p> <pre><code>class PublishArticle &lt; CMDx::Task\n  attribute :title, required: true\n  attributes :content, :author_id, required: true\n\n  # Alias for attributes =&gt; required: true (preferred)\n  required :category\n  required :status, :tags\n\n  # Conditionally required\n  required :publisher, if: :magazine?\n  attribute :approver, required: true, unless: proc { status == :published }\n\n  def work\n    title     #=&gt; \"Getting Started with Ruby\"\n    content   #=&gt; \"This is a comprehensive guide...\"\n    author_id #=&gt; 42\n    category  #=&gt; \"programming\"\n    status    #=&gt; :published\n    tags      #=&gt; [\"ruby\", \"beginner\"]\n    publisher #=&gt; \"Eastbay\"\n    approver  #=&gt; #&lt;Editor ...&gt;\n  end\n\n  private\n\n  def magazine?\n    context.title.ends_with?(\"[M]\")\n  end\nend\n</code></pre> <p>Note</p> <p>When a required attribute's condition evaluates to <code>false</code>, the attribute behaves as optional. All other attribute features such as coercions, validations, defaults, and transformations still apply normally.</p>"},{"location":"attributes/definitions/#sources","title":"Sources","text":"<p>Attributes read from any accessible object\u2014not just context. Use sources to pull data from models, services, or any callable:</p>"},{"location":"attributes/definitions/#context","title":"Context","text":"<pre><code>class BackupDatabase &lt; CMDx::Task\n  # Default source is :context\n  required :database_name\n  optional :compression_level\n\n  # Explicitly specify context source\n  attribute :backup_path, source: :context\n\n  def work\n    database_name     #=&gt; context.database_name\n    backup_path       #=&gt; context.backup_path\n    compression_level #=&gt; context.compression_level\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  attributes :host, :credentials, source: :database_config\n\n  # Access from declared attributes\n  attribute :connection_string, source: :credentials\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def database_config\n    @database_config ||= DatabaseConfig.find(context.database_name)\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  # Proc\n  attribute :timestamp, source: proc { Time.current }\n\n  # Lambda\n  attribute :server, source: -&gt; { Current.server }\nend\n</code></pre>"},{"location":"attributes/definitions/#class-or-module","title":"Class or Module","text":"<p>For complex source logic, use classes or modules:</p> <pre><code>class DatabaseResolver\n  def self.call(task)\n    Database.find(task.context.database_name)\n  end\nend\n\nclass BackupDatabase &lt; CMDx::Task\n  # Class or Module\n  attribute :schema, source: DatabaseResolver\n\n  # Instance\n  attribute :metadata, source: DatabaseResolver.new\nend\n</code></pre>"},{"location":"attributes/definitions/#description","title":"Description","text":"<p>Add metadata to attributes for documentation or introspection purposes.</p> <pre><code>class CreateUser &lt; CMDx::Task\n  required :email, description: \"The user's primary email address\"\n\n  # Alias :desc\n  optional :phone, desc: \"Primary contact number\"\n\n  # Bulk definition - description applies to all\n  attributes :first_name, :last_name, desc: \"Part of user's legal name\"\nend\n</code></pre>"},{"location":"attributes/definitions/#nesting","title":"Nesting","text":"<p>Build complex structures with nested attributes. Children inherit their parent as source and support all attribute options:</p> <p>Note</p> <p>Nested attributes support all features: naming, coercions, validations, defaults, and more.</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  # Required parent with required children\n  required :network_config do\n    required :hostname, :port, :protocol, :subnet\n    optional :load_balancer\n    attribute :firewall_rules\n  end\n\n  # Optional parent with conditional children\n  optional :ssl_config do\n    required :certificate_path, :private_key # Only required if ssl_config provided\n    optional :enable_http2, prefix: true\n  end\n\n  # Multi-level nesting\n  attribute :monitoring do\n    required :provider\n\n    optional :alerting do\n      required :threshold_percentage\n      optional :notification_channel\n    end\n  end\n\n  def work\n    network_config   #=&gt; { hostname: \"api.company.com\" ... }\n    hostname         #=&gt; \"api.company.com\"\n    load_balancer    #=&gt; nil\n  end\nend\n\nConfigureServer.execute(\n  server_id: \"srv-001\",\n  network_config: {\n    hostname: \"api.company.com\",\n    port: 443,\n    protocol: \"https\",\n    subnet: \"10.0.1.0/24\",\n    firewall_rules: \"allow_web_traffic\"\n  },\n  monitoring: {\n    provider: \"datadog\",\n    alerting: {\n      threshold_percentage: 85.0,\n      notification_channel: \"slack\"\n    }\n  }\n)\n</code></pre> <p>Important</p> <p>Child requirements only apply when the parent is provided\u2014perfect for optional structures.</p>"},{"location":"attributes/definitions/#error-handling","title":"Error Handling","text":"<p>Validation failures provide detailed, structured error messages:</p> <p>Note</p> <p>Nested attributes are only validated when their parent is present and valid.</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  required :server_id, :environment\n  required :network_config do\n    required :hostname, :port\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Missing required top-level attributes\nresult = ConfigureServer.execute(server_id: \"srv-001\")\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"environment is required. network_config is required.\",\n                #       messages: {\n                #         environment: [\"is required\"],\n                #         network_config: [\"is required\"]\n                #       }\n                #     }\n                #   }\n\n# Missing required nested attributes\nresult = ConfigureServer.execute(\n  server_id: \"srv-001\",\n  environment: \"production\",\n  network_config: { hostname: \"api.company.com\" } # Missing port\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"port is required.\",\n                #       messages: {\n                #         port: [\"is required\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/naming/","title":"Attributes - Naming","text":"<p>Customize accessor method names to avoid conflicts and improve clarity. Affixing changes only the generated methods\u2014not the original attribute names.</p> <p>Note</p> <p>Use naming when attributes conflict with existing methods or need better clarity in your code.</p>"},{"location":"attributes/naming/#prefix","title":"Prefix","text":"<p>Adds a prefix to the generated accessor method name.</p> <pre><code>class GenerateReport &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :template, prefix: true\n\n  # Static\n  attribute :format, prefix: \"report_\"\n\n  def work\n    context_template #=&gt; \"monthly_sales\"\n    report_format    #=&gt; \"pdf\"\n  end\nend\n\n# Attributes passed as original attribute names\nGenerateReport.execute(template: \"monthly_sales\", format: \"pdf\")\n</code></pre>"},{"location":"attributes/naming/#suffix","title":"Suffix","text":"<p>Adds a suffix to the generated accessor method name.</p> <pre><code>class DeployApplication &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :branch, suffix: true\n\n  # Static\n  attribute :version, suffix: \"_tag\"\n\n  def work\n    branch_context #=&gt; \"main\"\n    version_tag    #=&gt; \"v1.2.3\"\n  end\nend\n\n# Attributes passed as original attribute names\nDeployApplication.execute(branch: \"main\", version: \"v1.2.3\")\n</code></pre>"},{"location":"attributes/naming/#as","title":"As","text":"<p>Completely renames the generated accessor method.</p> <pre><code>class ScheduleMaintenance &lt; CMDx::Task\n  attribute :scheduled_at, as: :when\n\n  def work\n    when #=&gt; &lt;DateTime&gt;\n  end\nend\n\n# Attributes passed as original attribute names\nScheduleMaintenance.execute(scheduled_at: DateTime.new(2024, 12, 15, 2, 0, 0))\n</code></pre>"},{"location":"attributes/transformations/","title":"Attributes - Transformations","text":"<p>Modify attribute values after coercion but before validation. Perfect for normalization, formatting, and data cleanup.</p>"},{"location":"attributes/transformations/#declarations","title":"Declarations","text":""},{"location":"attributes/transformations/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic value transformations:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :options, transform: :compact_blank\nend\n</code></pre>"},{"location":"attributes/transformations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic value transformations:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, transform: proc { |v| v * 2 }\n\n  # Lambda\n  attribute :compression, transform: -&gt;(v) { v.to_s.upcase.strip[0..2]  }\nend\n</code></pre>"},{"location":"attributes/transformations/#class-or-module","title":"Class or Module","text":"<p>Use any object that responds to <code>call</code> for reusable transformation logic:</p> <pre><code>class EmailNormalizer\n  def call(value)\n    value.to_s.downcase.strip\n  end\nend\n\nclass ProcessContacts &lt; CMDx::Task\n  # Class or Module\n  attribute :email, transform: EmailNormalizer\n\n  # Instance\n  attribute :email, transform: EmailNormalizer.new\nend\n</code></pre>"},{"location":"attributes/transformations/#validations","title":"Validations","text":"<p>Validations run on transformed values, ensuring data consistency:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, type: :integer, transform: proc { |v| v.clamp(1, 5) }\n\n  # Validations\n  optional :frequency, transform: :downcase, inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/validations/","title":"Attributes - Validations","text":"<p>Ensure inputs meet requirements before execution. Validations run after coercions, giving you declarative data integrity checks.</p> <p>See Global Configuration for custom validator setup.</p>"},{"location":"attributes/validations/#usage","title":"Usage","text":"<p>Define validation rules on attributes to enforce data requirements:</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  # Required field with presence validation\n  attribute :user_id, presence: true\n\n  # String with length constraints\n  optional :preferences, length: { minimum: 10, maximum: 500 }\n\n  # Numeric range validation\n  required :tier_level, inclusion: { in: 1..5 }\n\n  # Format validation for email\n  attribute :contact_email, format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    user_id       #=&gt; \"98765\"\n    preferences   #=&gt; \"Send weekly digest emails\"\n    tier_level    #=&gt; 3\n    contact_email #=&gt; \"user@company.com\"\n  end\nend\n\nProcessSubscription.execute(\n  user_id: \"98765\",\n  preferences: \"Send weekly digest emails\",\n  tier_level: 3,\n  contact_email: \"user@company.com\"\n)\n</code></pre> <p>Tip</p> <p>Validations run after coercions, so you can validate the final coerced values rather than raw input.</p>"},{"location":"attributes/validations/#built-in-validators","title":"Built-in Validators","text":""},{"location":"attributes/validations/#common-options","title":"Common Options","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  # Allow nil\n  attribute :tier_level, inclusion: {\n    in: 1..5,\n    allow_nil: true\n  }\n\n  # Conditionals\n  optional :contact_email, format: {\n    with: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i,\n    if: -&gt;(value) { value.includes?(\"@\") }\n  }\n  required :status, exclusion: {\n    in: %w[recalled archived],\n    unless: :product_sunsetted?\n  }\n\n  # Custom message\n  attribute :title, length: {\n    within: 5..100,\n    message: \"must be in optimal size\"\n  }\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def product_defunct?(value)\n    context.company.out_of_business? || value == \"deprecated\"\n  end\nend\n</code></pre> <p>This list of options is available to all validators:</p> Option Description <code>:allow_nil</code> Skip validation when value is <code>nil</code> <code>:if</code> Symbol, proc, lambda, or callable determining when to validate <code>:unless</code> Symbol, proc, lambda, or callable determining when to skip validation <code>:message</code> Custom error message for validation failures"},{"location":"attributes/validations/#absence","title":"Absence","text":"<pre><code>class CreateUser &lt; CMDx::Task\n  attribute :honey_pot, absence: true\n\n  attribute :honey_pot, absence: { message: \"must be empty\" }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>true</code> Ensures value is nil, empty string, or whitespace"},{"location":"attributes/validations/#exclusion","title":"Exclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :status, exclusion: { in: %w[recalled archived] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of forbidden values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value exclusions <code>:in_message</code> Custom message for range-based exclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#format","title":"Format","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :sku, format: /\\A[A-Z]{3}-[0-9]{4}\\z/\n\n  attribute :sku, format: { with: /\\A[A-Z]{3}-[0-9]{4}\\z/ }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>regexp</code> Alias for :with option <code>:with</code> Regex pattern that the value must match <code>:without</code> Regex pattern that the value must not match"},{"location":"attributes/validations/#inclusion","title":"Inclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :availability, inclusion: { in: %w[available limited] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of allowed values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value inclusions <code>:in_message</code> Custom message for range-based inclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#length","title":"Length","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :title, length: { within: 5..100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the length must fall within (inclusive) <code>:not_within</code> Range that the length must not fall within <code>:in</code> Alias for :within <code>:not_in</code> Range that the length must not fall within <code>:min</code> Minimum allowed length <code>:max</code> Maximum allowed length <code>:is</code> Exact required length <code>:is_not</code> Length that is not allowed <code>:within_message</code> Custom message for within/range validations <code>:in_message</code> Custom message for :in validation <code>:not_within_message</code> Custom message for not_within validation <code>:not_in_message</code> Custom message for not_in validation <code>:min_message</code> Custom message for minimum length validation <code>:max_message</code> Custom message for maximum length validation <code>:is_message</code> Custom message for exact length validation <code>:is_not_message</code> Custom message for is_not validation"},{"location":"attributes/validations/#numeric","title":"Numeric","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :word_count, numeric: { min: 100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the value must fall within (inclusive) <code>:not_within</code> Range that the value must not fall within <code>:in</code> Alias for :within option <code>:not_in</code> Alias for :not_within option <code>:min</code> Minimum allowed value (inclusive, &gt;=) <code>:max</code> Maximum allowed value (inclusive, &lt;=) <code>:is</code> Exact value that must match <code>:is_not</code> Value that must not match <code>:within_message</code> Custom message for range validations <code>:not_within_message</code> Custom message for exclusion validations <code>:min_message</code> Custom message for minimum validation <code>:max_message</code> Custom message for maximum validation <code>:is_message</code> Custom message for exact match validation <code>:is_not_message</code> Custom message for exclusion validation"},{"location":"attributes/validations/#presence","title":"Presence","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :content, presence: true\n\n  attribute :content, presence: { message: \"cannot be blank\" }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>true</code> Ensures value is not nil, empty string, or whitespace"},{"location":"attributes/validations/#declarations","title":"Declarations","text":"<p>Important</p> <p>Custom validators must raise <code>CMDx::ValidationError</code> with a descriptive message.</p>"},{"location":"attributes/validations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple validation logic:</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  # Proc\n  register :validator, :api_key, proc do |value, options = {}|\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\n\n  # Lambda\n  register :validator, :api_key, -&gt;(value, options = {}) {\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/validations/#class-or-module","title":"Class or Module","text":"<p>Register custom validation logic for specialized requirements:</p> <pre><code>class ApiKeyValidator\n  def self.call(value, options = {})\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\nend\n\nclass SetupApplication &lt; CMDx::Task\n  register :validator, :api_key, ApiKeyValidator\n\n  attribute :access_key, api_key: true\nend\n</code></pre>"},{"location":"attributes/validations/#removals","title":"Removals","text":"<p>Remove unwanted validators:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one validator. Use multiple calls for batch removals.</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  deregister :validator, :api_key\nend\n</code></pre>"},{"location":"attributes/validations/#error-handling","title":"Error Handling","text":"<p>Validation failures provide detailed, structured error messages:</p> <pre><code>class CreateProject &lt; CMDx::Task\n  attribute :project_name,\n    presence: true,\n    length: { minimum: 3, maximum: 50 }\n  optional :budget,\n    numeric: { greater_than: 1000, less_than: 1000000 }\n  required :priority,\n    inclusion: { in: [:low, :medium, :high] }\n  attribute :contact_email,\n    format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = CreateProject.execute(\n  project_name: \"AB\",           # Too short\n  budget: 500,                  # Too low\n  priority: :urgent,            # Not in allowed list\n  contact_email: \"invalid-email\"    # Invalid format\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"project_name is too short (minimum is 3 characters). budget must be greater than 1000. priority is not included in the list. contact_email is invalid.\",\n                #       messages: {\n                #         project_name: [\"is too short (minimum is 3 characters)\"],\n                #         budget: [\"must be greater than 1000\"],\n                #         priority: [\"is not included in the list\"],\n                #         contact_email: [\"is invalid\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"basics/chain/","title":"Basics - Chain","text":"<p>Chains automatically track related task executions within a thread. Think of them as execution traces that help you understand what happened and in what order.</p>"},{"location":"basics/chain/#management","title":"Management","text":"<p>Each thread maintains its own isolated chain using thread-local storage.</p> <p>Warning</p> <p>Chains are thread-local. Don't share chain references across threads\u2014it causes race conditions.</p> <pre><code># Thread A\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch1.csv\")\n  result.chain.id    #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nend\n\n# Thread B (completely separate chain)\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch2.csv\")\n  result.chain.id    #=&gt; \"z3a42b95-c821-7892-b156-dd7c921fe2a3\"\nend\n\n# Access current thread's chain\nCMDx::Chain.current  #=&gt; Returns current chain or nil\nCMDx::Chain.clear    #=&gt; Clears current thread's chain\n</code></pre>"},{"location":"basics/chain/#links","title":"Links","text":"<p>Tasks automatically create or join the current thread's chain:</p> <p>Important</p> <p>Chain management is automatic\u2014no manual lifecycle handling needed.</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    # First task creates new chain\n    result1 = ValidateHeaders.execute(file_path: context.file_path)\n    result1.chain.id           #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\n    result1.chain.results.size #=&gt; 1\n\n    # Second task joins existing chain\n    result2 = SendNotification.execute(to: \"admin@company.com\")\n    result2.chain.id == result1.chain.id  #=&gt; true\n    result2.chain.results.size            #=&gt; 2\n\n    # Both results reference the same chain\n    result1.chain.results == result2.chain.results #=&gt; true\n  end\nend\n</code></pre>"},{"location":"basics/chain/#inheritance","title":"Inheritance","text":"<p>Subtasks automatically inherit the current thread's chain, building a unified execution trail:</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    context.dataset = Dataset.find(context.dataset_id)\n\n    # Subtasks automatically inherit current chain\n    ValidateSchema.execute\n    TransformData.execute!(context)\n    SaveToDatabase.execute(dataset_id: context.dataset_id)\n  end\nend\n\nresult = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# All tasks share the same chain\nchain.results.size #=&gt; 4 (main task + 3 subtasks)\nchain.results.map { |r| r.task.class }\n#=&gt; [ImportDataset, ValidateSchema, TransformData, SaveToDatabase]\n</code></pre>"},{"location":"basics/chain/#structure","title":"Structure","text":"<p>Chains expose comprehensive execution information:</p> <p>Important</p> <p>Chain state reflects the first (outermost) task result. Subtasks maintain their own states.</p> <pre><code>result = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# Chain identification\nchain.id      #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nchain.results #=&gt; Array of all results in execution order\n\n# State delegation (from first/outer-most result)\nchain.state   #=&gt; \"complete\"\nchain.status  #=&gt; \"success\"\nchain.outcome #=&gt; \"success\"\n\n# Access individual results\nchain.results.each_with_index do |result, index|\n  puts \"#{index}: #{result.task.class} - #{result.status}\"\nend\n</code></pre>"},{"location":"basics/context/","title":"Basics - Context","text":"<p>Context is your data container for inputs, intermediate values, and outputs. It makes sharing data between tasks effortless.</p>"},{"location":"basics/context/#assigning-data","title":"Assigning Data","text":"<p>Context automatically captures all task inputs, normalizing keys to symbols:</p> <pre><code># Direct execution\nCalculateShipping.execute(weight: 2.5, destination: \"CA\")\n\n# Instance creation\nCalculateShipping.new(weight: 2.5, \"destination\" =&gt; \"CA\")\n</code></pre> <p>Important</p> <p>String keys convert to symbols automatically. Prefer symbols for consistency.</p>"},{"location":"basics/context/#accessing-data","title":"Accessing Data","text":"<p>Access context data using method notation, hash keys, or safe accessors:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Method style access (preferred)\n    weight = context.weight\n    destination = context.destination\n\n    # Hash style access\n    service_type = context[:service_type]\n    options = context[\"options\"]\n\n    # Safe access with defaults\n    rush_delivery = context.fetch!(:rush_delivery, false)\n    carrier = context.dig(:options, :carrier)\n\n    # Shorter alias\n    cost = ctx.weight * ctx.rate_per_pound  # ctx aliases context\n  end\nend\n</code></pre> <p>Important</p> <p>Undefined attributes return <code>nil</code> instead of raising errors\u2014perfect for optional data.</p>"},{"location":"basics/context/#modifying-context","title":"Modifying Context","text":"<p>Context supports dynamic modification during task execution:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Direct assignment\n    context.carrier = Carrier.find_by(code: context.carrier_code)\n    context.package = Package.new(weight: context.weight)\n    context.calculated_at = Time.now\n\n    # Hash-style assignment\n    context[:status] = \"calculating\"\n    context[\"tracking_number\"] = \"SHIP#{SecureRandom.hex(6)}\"\n\n    # Conditional assignment\n    context.insurance_included ||= false\n\n    # Batch updates\n    context.merge!(\n      status: \"completed\",\n      shipping_cost: calculate_cost,\n      estimated_delivery: Time.now + 3.days\n    )\n\n    # Remove sensitive data\n    context.delete!(:credit_card_token)\n\n    # Clear all data\n    context.clear!\n  end\n\n  private\n\n  def calculate_cost\n    base_rate = context.weight * context.rate_per_pound\n    base_rate + (base_rate * context.tax_percentage)\n  end\nend\n</code></pre> <p>Tip</p> <p>Use context for both input values and intermediate results. This creates natural data flow through your task execution pipeline.</p>"},{"location":"basics/context/#data-sharing","title":"Data Sharing","text":"<p>Share context across tasks for seamless data flow:</p> <pre><code># During execution\nclass CalculateShipping &lt; CMDx::Task\n  def work\n    # Validate shipping data\n    validation_result = ValidateAddress.execute(context)\n\n    # Via context\n    CalculateInsurance.execute(context)\n\n    # Via result\n    NotifyShippingCalculated.execute(validation_result)\n\n    # Context now contains accumulated data from all tasks\n    context.address_validated    #=&gt; true (from validation)\n    context.insurance_calculated #=&gt; true (from insurance)\n    context.notification_sent    #=&gt; true (from notification)\n  end\nend\n\n# After execution\nresult = CalculateShipping.execute(destination: \"New York, NY\")\n\nCreateShippingLabel.execute(result)\n</code></pre>"},{"location":"basics/execution/","title":"Basics - Execution","text":"<p>CMDx offers two execution methods with different error handling approaches. Choose based on your needs: safe result handling or exception-based control flow.</p>"},{"location":"basics/execution/#execution-methods","title":"Execution Methods","text":"<p>Both methods return results, but handle failures differently:</p> Method Returns Exceptions Use Case <code>execute</code> Always returns <code>CMDx::Result</code> Never raises Predictable result handling <code>execute!</code> Returns <code>CMDx::Result</code> on success Raises <code>CMDx::Fault</code> when skipped or failed Exception-based control flow <pre><code>flowchart LR\n    subgraph Methods\n        E[execute]\n        EB[execute!]\n    end\n\n    subgraph Returns [Returns CMDx::Result]\n        Success\n        Failed\n        Skipped\n    end\n\n    subgraph Raises [Raises CMDx::Fault]\n        FailFault\n        SkipFault\n    end\n\n    E --&gt; Success\n    E --&gt; Failed\n    E --&gt; Skipped\n\n    EB --&gt; Success\n    EB --&gt; FailFault\n    EB --&gt; SkipFault</code></pre>"},{"location":"basics/execution/#non-bang-execution","title":"Non-bang Execution","text":"<p>Always returns a <code>CMDx::Result</code>, never raises exceptions. Perfect for most use cases.</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Check execution state\nresult.success?         #=&gt; true/false\nresult.failed?          #=&gt; true/false\nresult.skipped?         #=&gt; true/false\n\n# Access result data\nresult.context.email    #=&gt; \"user@example.com\"\nresult.state            #=&gt; \"complete\"\nresult.status           #=&gt; \"success\"\n</code></pre>"},{"location":"basics/execution/#bang-execution","title":"Bang Execution","text":"<p>Raises <code>CMDx::Fault</code> exceptions on failure or skip. Returns results only on success.</p> Exception Raised When <code>CMDx::FailFault</code> Task execution fails <code>CMDx::SkipFault</code> Task execution is skipped <p>Important</p> <p>Behavior depends on <code>task_breakpoints</code> or <code>workflow_breakpoints</code> config. Default: only failures raise exceptions.</p> <pre><code>begin\n  result = CreateAccount.execute!(email: \"user@example.com\")\n  SendWelcomeEmail.execute(result.context)\nrescue CMDx::FailFault =&gt; e\n  ScheduleAccountRetryJob.perform_later(e.result.context.email)\nrescue CMDx::SkipFault =&gt; e\n  Rails.logger.info(\"Account creation skipped: #{e.result.reason}\")\nrescue Exception =&gt; e\n  ErrorTracker.capture(unhandled_exception: e)\nend\n</code></pre>"},{"location":"basics/execution/#direct-instantiation","title":"Direct Instantiation","text":"<p>Tasks can be instantiated directly for advanced use cases, testing, and custom execution patterns:</p> <pre><code># Direct instantiation\ntask = CreateAccount.new(email: \"user@example.com\", send_welcome: true)\n\n# Access properties before execution\ntask.id                      #=&gt; \"abc123...\" (unique task ID)\ntask.context.email           #=&gt; \"user@example.com\"\ntask.context.send_welcome    #=&gt; true\ntask.result.state            #=&gt; \"initialized\"\ntask.result.status           #=&gt; \"success\"\n\n# Manual execution\ntask.execute\n# or\ntask.execute!\n\ntask.result.success?         #=&gt; true/false\n</code></pre>"},{"location":"basics/execution/#result-details","title":"Result Details","text":"<p>The <code>Result</code> object provides comprehensive execution information:</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Execution metadata\nresult.id           #=&gt; \"abc123...\"  (unique execution ID)\nresult.task         #=&gt; CreateAccount instance (frozen)\nresult.chain        #=&gt; Task execution chain\n\n# Context and metadata\nresult.context      #=&gt; Context with all task data\nresult.metadata     #=&gt; Hash with execution metadata\n</code></pre>"},{"location":"basics/execution/#dry-run","title":"Dry Run","text":"<p>Execute tasks in dry-run mode to simulate execution without performing side effects. Pass <code>dry_run: true</code> in the context when initializing or executing the task.</p> <p>Inside your task, use the <code>dry_run?</code> method to conditionally skip side effects.</p> <pre><code>class CloseStripeCard &lt; CMDx::Task\n  def work\n    context.stripe_result =\n      if dry_run?\n        FactoryBot.build(:stripe_closed_card)\n      else\n        StripeApi.close_card(context.card_id)\n      end\n  end\nend\n\n# Execute in dry-run mode\nresult = CloseStripeCard.execute(card_id: \"card_abc123\", dry_run: true)\nresult.success? # =&gt; true\n\n# FactoryBot object\nresult.context.stripe_result = {\n  card_id: \"card_abc123\",\n  status: \"closed\"\n}\n</code></pre>"},{"location":"basics/setup/","title":"Basics - Setup","text":"<p>Tasks are the heart of CMDx\u2014self-contained units of business logic with built-in validation, error handling, and execution tracking.</p>"},{"location":"basics/setup/#structure","title":"Structure","text":"<p>Tasks need only two things: inherit from <code>CMDx::Task</code> and define a <code>work</code> method:</p> <pre><code>class ValidateDocument &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Without a <code>work</code> method, execution raises <code>CMDx::UndefinedMethodError</code>.</p> <pre><code>class IncompleteTask &lt; CMDx::Task\n  # No `work` method defined\nend\n\nIncompleteTask.execute #=&gt; raises CMDx::UndefinedMethodError\n</code></pre>"},{"location":"basics/setup/#rollback","title":"Rollback","text":"<p>Undo any operations linked to the given status, helping to restore a pristine state.</p> <pre><code>class ChargeCard &lt; CMDx::Task\n  def work\n    # Your logic here, ex: charge $100\n  end\n\n  # Called automatically if a later step in the workflow fails\n  def rollback\n    # Your undo logic, ex: void $100 charge\n  end\nend\n</code></pre>"},{"location":"basics/setup/#inheritance","title":"Inheritance","text":"<p>Share configuration across tasks using inheritance:</p> <pre><code>class ApplicationTask &lt; CMDx::Task\n  register :middleware, SecurityMiddleware\n\n  before_execution :initialize_request_tracking\n\n  attribute :session_id\n\n  private\n\n  def initialize_request_tracking\n    context.tracking_id ||= SecureRandom.uuid\n  end\nend\n\nclass SyncInventory &lt; ApplicationTask\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"basics/setup/#lifecycle","title":"Lifecycle","text":"<p>Tasks follow a predictable execution pattern:</p> <pre><code>stateDiagram-v2\n    Initialized: Instantiation\n    Initialized --&gt; Validating: execute\n    Validating --&gt; Executing: Valid?\n    Validating --&gt; Failed: Invalid\n    Executing --&gt; Success: Work done\n    Executing --&gt; Skipped: skip!\n    Executing --&gt; Failed: fail! / Exception\n    Executed\n\n    state Executed {\n        Success\n        Skipped\n        Failed\n        Rollback\n\n        Skipped --&gt; Rollback\n        Failed --&gt; Rollback\n    }</code></pre> <p>Caution</p> <p>Tasks are single-use objects. Once executed, they're frozen and immutable.</p> Stage State Status Description Instantiation <code>initialized</code> <code>success</code> Task created with context Validation <code>executing</code> <code>success</code>/<code>failed</code> Attributes validated Execution <code>executing</code> <code>success</code>/<code>failed</code>/<code>skipped</code> <code>work</code> method runs Completion <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Result finalized Freezing <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Task becomes immutable Rollback <code>executed</code> <code>failed</code>/<code>skipped</code> Work undone"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/getting-started-with-cmdx/","title":"Getting Started with CMDx: Taming Business Logic in Ruby","text":"<p>I've spent years wrestling with service objects. You know the pattern\u2014create a class, throw some business logic in a <code>call</code> method, cross your fingers, and hope for the best. The problem? Every team member writes them differently. Every project invents its own conventions. And when something breaks at 2 AM, good luck tracing what actually happened.</p> <p>That frustration led me to create CMDx.</p>"},{"location":"blog/getting-started-with-cmdx/#the-problem-with-service-objects","title":"The Problem with Service Objects","text":"<p>Let's be honest about what we're dealing with. Your typical Rails service object looks something like this:</p> <pre><code>class ProcessOrder\n  def initialize(order_id, user)\n    @order_id = order_id\n    @user = user\n  end\n\n  def call\n    order = Order.find(@order_id)\n    return false if order.processed?\n\n    order.process!\n    OrderMailer.confirmation(@user).deliver_now\n    true\n  rescue =&gt; e\n    Rails.logger.error(\"Order processing failed: #{e.message}\")\n    false\n  end\nend\n</code></pre> <p>What's wrong with this? Everything and nothing. It works, but:</p> <ul> <li>Inconsistent patterns \u2014 Does it return <code>true</code>/<code>false</code>? An object? Raises exceptions? Every service decides differently.</li> <li>Black box execution \u2014 When something fails in production, you're left grepping logs hoping someone remembered to add useful output.</li> <li>Fragile error handling \u2014 That <code>rescue =&gt; e</code> catches everything. Validation errors, network timeouts, database issues\u2014all get the same treatment.</li> </ul> <p>These aren't hypothetical problems. They're the Monday morning fire drills that eat your week.</p>"},{"location":"blog/getting-started-with-cmdx/#why-i-built-cmdx","title":"Why I Built CMDx","text":"<p>I wanted something simple enough for a junior dev to pick up in an afternoon, but powerful enough to handle complex business processes. CMDx is built around a straightforward pattern I call CERO: Compose, Execute, React, Observe.</p> <p>The idea is that every piece of business logic should:</p> <ol> <li>Be composed as a self-contained task</li> <li>Execute with consistent, predictable behavior</li> <li>Return a result you can react to</li> <li>Be observable through structured logging</li> </ol> <p>Let me show you what this looks like in practice.</p>"},{"location":"blog/getting-started-with-cmdx/#your-first-cmdx-task","title":"Your First CMDx Task","text":"<p>Here's the simplest possible task:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    order = Order.find(context.order_id)\n    order.process!\n    context.processed_at = Time.current\n  end\nend\n</code></pre> <p>That's it. Inherit from <code>CMDx::Task</code>, define a <code>work</code> method, and you're done.</p> <p>The <code>context</code> object is your data container\u2014it holds everything you pass in and everything you want to pass out. No instance variables to juggle, no wondering what data is available where.</p> <p>Let's execute it:</p> <pre><code>result = ProcessOrder.execute(order_id: 42)\n</code></pre> <p>Every execution returns a <code>Result</code> object. Always. No exceptions (pun intended\u2014we'll get to those).</p>"},{"location":"blog/getting-started-with-cmdx/#reacting-to-outcomes","title":"Reacting to Outcomes","text":"<p>Here's where CMDx starts earning its keep. The result tells you exactly what happened:</p> <pre><code>result = ProcessOrder.execute(order_id: 42)\n\nif result.success?\n  puts \"Order processed at #{result.context.processed_at}\"\nelsif result.skipped?\n  puts \"Order was skipped: #{result.reason}\"\nelsif result.failed?\n  puts \"Order failed: #{result.reason}\"\nend\n</code></pre> <p>Three possible statuses: <code>success</code>, <code>skipped</code>, or <code>failed</code>. That's it. No mystery booleans, no exceptions to catch (unless you want them), no guessing what happened.</p>"},{"location":"blog/getting-started-with-cmdx/#controlling-execution-flow","title":"Controlling Execution Flow","text":"<p>Real business logic isn't a straight line. Sometimes you need to stop early, sometimes things go wrong. CMDx gives you two explicit methods for this: <code>skip!</code> and <code>fail!</code>.</p>"},{"location":"blog/getting-started-with-cmdx/#skipping-when-theres-nothing-to-do","title":"Skipping: When There's Nothing to Do","text":"<p>Use <code>skip!</code> when the task legitimately shouldn't run. It's a no-op, not an error:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    order = Order.find(context.order_id)\n\n    if order.already_processed?\n      skip!(\"Order was already processed on #{order.processed_at}\")\n    end\n\n    order.process!\n    context.processed_at = Time.current\n  end\nend\n</code></pre> <p>Skipped tasks are considered successful outcomes\u2014the task did exactly what it should by recognizing there was nothing to do.</p>"},{"location":"blog/getting-started-with-cmdx/#failing-when-something-goes-wrong","title":"Failing: When Something Goes Wrong","text":"<p>Use <code>fail!</code> when the task cannot complete. This is an intentional, controlled failure:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    order = Order.find_by(id: context.order_id)\n\n    if order.nil?\n      fail!(\"Order not found\", code: :not_found)\n    elsif order.expired?\n      fail!(\"Order has expired\", code: :expired, expired_at: order.expired_at)\n    end\n\n    order.process!\n    context.processed_at = Time.current\n  end\nend\n</code></pre> <p>Notice the metadata I'm passing\u2014<code>code</code>, <code>expired_at</code>. This gets captured in the result:</p> <pre><code>result = ProcessOrder.execute(order_id: 999)\n\nif result.failed?\n  puts result.reason              # =&gt; \"Order not found\"\n  puts result.metadata[:code]     # =&gt; :not_found\nend\n</code></pre>"},{"location":"blog/getting-started-with-cmdx/#handling-real-exceptions","title":"Handling Real Exceptions","text":"<p>What about actual exceptions\u2014database timeouts, network failures, unexpected nil values? CMDx catches these and converts them to failures automatically:</p> <pre><code>result = ProcessOrder.execute(order_id: 42)\n\nif result.failed?\n  puts result.reason  # =&gt; \"[ActiveRecord::ConnectionError] Connection timed out\"\n  puts result.cause   # =&gt; The actual exception object\nend\n</code></pre> <p>Your code doesn't change. The result still tells you what happened, the exception is still available if you need it for debugging, but your calling code doesn't need a <code>rescue</code> block.</p>"},{"location":"blog/getting-started-with-cmdx/#observing-everything","title":"Observing Everything","text":"<p>This is my favorite part. Every CMDx execution automatically logs what happened:</p> <pre><code>I, [2025-01-07T14:32:15.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"ProcessOrder\" state=\"complete\" status=\"success\" metadata={runtime: 47}\n</code></pre> <p>Every execution. Automatically. With timing, chain correlation, and outcome status.</p> <p>When something fails:</p> <pre><code>I, [2025-01-07T14:32:17.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-c921-8834-b234-dd6c721fe3a7\" type=\"Task\" class=\"ProcessOrder\" state=\"interrupted\" status=\"failed\" metadata={code: :not_found} reason=\"Order not found\"\n</code></pre> <p>You can also log from within your task:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    logger.debug { \"Looking up order #{context.order_id}\" }\n\n    order = Order.find(context.order_id)\n    order.process!\n\n    logger.info \"Order #{order.id} processed successfully\"\n    context.processed_at = Time.current\n  end\nend\n</code></pre>"},{"location":"blog/getting-started-with-cmdx/#whats-next","title":"What's Next","text":"<p>This introduction covers the foundation\u2014tasks, execution, halting, and observability. But CMDx has more to offer:</p> <ul> <li>Attributes with type coercion and validation</li> <li>Callbacks for cross-cutting concerns</li> <li>Workflows for orchestrating multi-step processes</li> <li>Middlewares for wrapping execution with custom behavior</li> <li>Retries for handling transient failures</li> </ul> <p>Check out the full documentation to explore these features.</p> <p>The goal of CMDx is simple: make your business logic predictable, observable, and maintainable. No more 2 AM mysteries. No more inconsistent patterns. Just clean, focused tasks that tell you exactly what they did.</p> <p>Give it a try! I'd love to hear how it works for you.</p>"},{"location":"blog/mastering-cmdx-attributes/","title":"Mastering CMDx Attributes: Your Task's Contract with the World","text":"<p>Attributes in CMDx are deceptively simple. You define what data your task needs, and the framework handles the rest\u2014coercion, validation, defaults, the works. But there's real depth here. After building dozens of production systems with CMDx, I've found that well-designed attributes are the difference between tasks that \"just work\" and tasks that fight you at every turn.</p> <p>Let me show you what I mean.</p>"},{"location":"blog/mastering-cmdx-attributes/#starting-simple-required-vs-optional","title":"Starting Simple: Required vs Optional","text":"<p>Every task starts with a question: what data do I need? Let's build a simple user registration task:</p> <pre><code>class RegisterUser &lt; CMDx::Task\n  required :email\n  required :password\n  optional :name\n\n  def work\n    user = User.create!(\n      email: email,\n      password: password,\n      name: name\n    )\n    context.user = user\n  end\nend\n</code></pre> <p>The <code>required</code> and <code>optional</code> helpers make intent crystal clear. When you call this task:</p> <pre><code># This works\nresult = RegisterUser.execute(email: \"alice@example.com\", password: \"secret123\")\n\n# This fails immediately\nresult = RegisterUser.execute(password: \"secret123\")\nresult.failed?           # =&gt; true\nresult.metadata[:errors] # =&gt; { messages: { email: [\"is required\"] } }\n</code></pre> <p>No exceptions to catch, no mystery failures buried in a stack trace. The task tells you exactly what went wrong.</p>"},{"location":"blog/mastering-cmdx-attributes/#how-attributes-become-methods","title":"How Attributes Become Methods","text":"<p>You might have noticed something in that example: I'm calling <code>email</code> and <code>password</code> directly, not <code>context.email</code> or <code>@email</code>. That's because each attribute definition creates an instance method on your task (Ruby FTW \ud83c\udfc6).</p> <p>When you write:</p> <pre><code>class RegisterUser &lt; CMDx::Task\n  required :email\n  required :password\n  optional :name\nend\n</code></pre> <p>CMDx generates something equivalent to:</p> <pre><code>def email\n  attributes[:email]\nend\n\ndef password\n  attributes[:password]\nend\n\ndef name\n  attributes[:name]\nend\n</code></pre> <p>These methods return the fully processed value\u2014sourced, coerced, transformed, and validated. The <code>attributes</code> hash is where CMDx stores all your processed attribute values, separate from the raw <code>context</code>.</p> <p>This design gives you several benefits:</p> <ol> <li>Clean code \u2014 <code>email</code> reads better than <code>context.email</code> or <code>context[:email]</code></li> <li>Encapsulation \u2014 The method returns the processed value, not the raw input</li> <li>IDE support \u2014 Your editor can autocomplete and navigate to attribute definitions</li> <li>Conflict detection \u2014 CMDx raises an error if an attribute would shadow an existing method</li> </ol> <p>That last point is important. If you try this:</p> <pre><code>class BadTask &lt; CMDx::Task\n  required :context  # Conflicts with CMDx::Task#context\nend\n</code></pre> <p>You'll get a clear error:</p> <pre><code>The method :context is already defined on the BadTask task.\nThis may be due to conflicts with one of the task's user defined or internal methods/attributes.\n\nUse :as, :prefix, and/or :suffix attribute options to avoid conflicts with existing methods.\n</code></pre> <p>We'll cover those naming options later, but the key insight is: attributes aren't just data declarations\u2014they're method definitions.</p>"},{"location":"blog/mastering-cmdx-attributes/#type-coercion-let-the-framework-do-the-heavy-lifting","title":"Type Coercion: Let the Framework Do the Heavy Lifting","text":"<p>Here's where things get interesting. Real-world data is messy. Form submissions send everything as strings. JSON payloads might have numbers where you expect integers. CMDx handles this automatically:</p> <pre><code>class ProcessPayment &lt; CMDx::Task\n  required :amount, type: :big_decimal\n  required :currency, type: :symbol\n  optional :metadata, type: :hash\n  optional :processed_at, type: :datetime\n\n  def work\n    amount       # =&gt; BigDecimal(\"99.99\") (was \"99.99\")\n    currency     # =&gt; :usd (was \"usd\")\n    metadata     # =&gt; {\"source\" =&gt; \"web\"} (was '{\"source\":\"web\"}')\n    processed_at # =&gt; DateTime object (was \"2025-01-07T10:30:00Z\")\n  end\nend\n\nProcessPayment.execute(\n  amount: \"99.99\",\n  currency: \"usd\",\n  metadata: '{\"source\":\"web\"}',\n  processed_at: \"2025-01-07T10:30:00Z\"\n)\n</code></pre> <p>The built-in coercions cover most cases:</p> Type What it does <code>:integer</code> Handles strings, hex (<code>0xFF</code>), octal (<code>077</code>) <code>:float</code> Parses numeric strings <code>:big_decimal</code> High-precision decimals <code>:boolean</code> Understands \"yes\"/\"no\", \"true\"/\"false\", 1/0 <code>:symbol</code> Converts strings to symbols <code>:array</code> Wraps single values, parses JSON arrays <code>:hash</code> Parses JSON objects <code>:date</code> / <code>:datetime</code> / <code>:time</code> Flexible date parsing <p>When data can come in multiple formats, specify fallbacks:</p> <pre><code>class ImportRecord &lt; CMDx::Task\n  # Try rational first, fall back to big_decimal\n  required :value, type: [:rational, :big_decimal]\nend\n</code></pre> <p>CMDx attempts each type in order until one succeeds.</p>"},{"location":"blog/mastering-cmdx-attributes/#validation-declarative-data-integrity","title":"Validation: Declarative Data Integrity","text":"<p>Coercion gets your data into the right shape. Validation ensures it makes sense:</p> <pre><code>class CreateProject &lt; CMDx::Task\n  required :name,\n    presence: true,\n    length: { minimum: 3, maximum: 100 }\n\n  required :budget,\n    type: :big_decimal,\n    numeric: { min: 1000, max: 1_000_000 }\n\n  required :priority,\n    type: :symbol,\n    inclusion: { in: [:low, :medium, :high, :critical] }\n\n  optional :contact_email,\n    format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    Project.create!(\n      name: name,\n      budget: budget,\n      priority: priority,\n      contact_email: contact_email\n    )\n  end\nend\n</code></pre> <p>Validation happens after coercion, so you're validating the final value, not the raw input. This is exactly what you want\u2014validate <code>BigDecimal(\"1000\")</code>, not the string <code>\"1000\"</code>.</p> <p>The error messages are structured and actionable:</p> <pre><code>result = CreateProject.execute(\n  name: \"AB\",\n  budget: \"500\",\n  priority: \"urgent\",\n  contact_email: \"not-an-email\"\n)\n\nresult.metadata[:errors]\n# =&gt; {\n#      full_message: \"name is too short (minimum is 3 characters). budget must be at least 1000. priority is not included in the list. contact_email is invalid.\",\n#      messages: {\n#        name: [\"is too short (minimum is 3 characters)\"],\n#        budget: [\"must be at least 1000\"],\n#        priority: [\"is not included in the list\"],\n#        contact_email: [\"is invalid\"]\n#      }\n#    }\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#defaults-smart-fallbacks","title":"Defaults: Smart Fallbacks","text":"<p>Sometimes attributes should have sensible defaults. Static values work great:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  required :database_name\n  optional :retention_days, default: 7\n  optional :compression, default: \"gzip\"\n  optional :notify, default: true\n\n  def work\n    retention_days # =&gt; 7 (when not provided)\n    compression    # =&gt; \"gzip\"\n    notify         # =&gt; true\n  end\nend\n</code></pre> <p>But often defaults need context. Use procs for dynamic defaults:</p> <pre><code>class GenerateReport &lt; CMDx::Task\n  required :user_id\n  optional :timezone, default: -&gt; { Current.user&amp;.timezone || \"UTC\" }\n  optional :format, default: proc { context.user_id.to_s.start_with?(\"admin\") ? \"detailed\" : \"summary\" }\n\n  def work\n    # timezone and format resolved at execution time\n  end\nend\n</code></pre> <p>Or reference a method for complex logic:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  required :account_id\n  optional :granularity, default: :default_granularity\n\n  def work\n    granularity # =&gt; \"hourly\" for premium, \"daily\" for free\n  end\n\n  private\n\n  def default_granularity\n    account.premium? ? \"hourly\" : \"daily\"\n  end\n\n  def account\n    @account ||= Account.find(context.account_id)\n  end\nend\n</code></pre> <p>Defaults are coerced and validated like any other value:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Default \"7\" gets coerced to integer, then validated\n  optional :retention_days,\n    default: \"7\",\n    type: :integer,\n    numeric: { min: 1, max: 30 }\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#transformations-clean-data-before-validation","title":"Transformations: Clean Data Before Validation","text":"<p>Sometimes you need to normalize data before validating it. Transformations run after coercion but before validation:</p> <pre><code>class ProcessContact &lt; CMDx::Task\n  required :email,\n    transform: -&gt;(v) { v.to_s.downcase.strip },\n    format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  required :phone,\n    transform: -&gt;(v) { v.gsub(/\\D/, \"\") },  # Strip non-digits\n    length: { is: 10 }\n\n  optional :preferences,\n    type: :hash,\n    transform: :compact_blank  # Remove empty values\n\n  def work\n    email       # =&gt; \"alice@example.com\" (was \"  ALICE@Example.COM  \")\n    phone       # =&gt; \"5551234567\" (was \"(555) 123-4567\")\n    preferences # =&gt; { theme: \"dark\" } (was { theme: \"dark\", other: \"\" })\n  end\nend\n</code></pre> <p>For reusable transformations, use a class:</p> <pre><code>class EmailNormalizer\n  def self.call(value)\n    value.to_s.downcase.strip.gsub(/\\s+/, \"\")\n  end\nend\n\nclass ProcessContact &lt; CMDx::Task\n  required :email, transform: EmailNormalizer\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#sources-reading-from-anywhere","title":"Sources: Reading from Anywhere","text":"<p>By default, attributes read from the context. But sometimes your data lives elsewhere:</p> <pre><code>class UpdateUserProfile &lt; CMDx::Task\n  required :user_id\n\n  # Read from a method that returns an object\n  required :current_plan, source: :user\n  required :email, source: :user\n\n  # Read from a lambda\n  optional :feature_flags, source: -&gt; { Current.feature_flags }\n\n  # Read from a class\n  optional :server_config, source: ConfigResolver\n\n  def work\n    current_plan  # =&gt; user.current_plan\n    email         # =&gt; user.email\n    feature_flags # =&gt; Current.feature_flags[:user_id]\n  end\n\n  private\n\n  def user\n    @user ||= User.find(context.user_id)\n  end\nend\n</code></pre> <p>This is powerful for building tasks that aggregate data from multiple sources without cluttering your context.</p>"},{"location":"blog/mastering-cmdx-attributes/#nested-attributes-handling-complex-structures","title":"Nested Attributes: Handling Complex Structures","text":"<p>Real APIs send nested data. CMDx handles this elegantly:</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  required :server_id\n\n  required :network do\n    required :hostname, format: /\\A[a-z0-9\\-\\.]+\\z/i\n    required :port, type: :integer, numeric: { min: 1, max: 65535 }\n    optional :protocol, default: \"https\", inclusion: { in: %w[http https] }\n  end\n\n  optional :ssl do\n    required :certificate_path, presence: true\n    required :private_key_path, presence: true\n    optional :passphrase\n  end\n\n  optional :monitoring do\n    required :provider, inclusion: { in: %w[datadog newrelic prometheus] }\n\n    optional :alerting do\n      required :threshold, type: :integer, numeric: { min: 1, max: 100 }\n      optional :channel, default: \"slack\"\n    end\n  end\n\n  def work\n    # Access nested values directly\n    hostname  # =&gt; \"api.example.com\"\n    port      # =&gt; 443\n    protocol  # =&gt; \"https\"\n    threshold # =&gt; 85 (from monitoring.alerting.threshold)\n    channel   # =&gt; \"slack\"\n\n    # Or access the whole structure\n    network   # =&gt; { hostname: \"api.example.com\", port: 443, protocol: \"https\" }\n  end\nend\n</code></pre> <p>The key insight: child requirements only apply when the parent is provided. If <code>ssl</code> isn't passed, <code>certificate_path</code> and <code>private_key_path</code> aren't required. But if you pass <code>ssl: {}</code>, they become required.</p> <pre><code># Valid - ssl is optional, so no ssl config needed\nConfigureServer.execute(\n  server_id: \"srv-001\",\n  network: { hostname: \"api.example.com\", port: 443 }\n)\n\n# Invalid - ssl provided but missing required children\nConfigureServer.execute(\n  server_id: \"srv-001\",\n  network: { hostname: \"api.example.com\", port: 443 },\n  ssl: {}  # Missing certificate_path and private_key_path!\n)\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#naming-avoiding-conflicts","title":"Naming: Avoiding Conflicts","text":"<p>Sometimes attribute names conflict with existing methods. Use naming options to work around this:</p> <pre><code>class ProcessData &lt; CMDx::Task\n  # Conflicts with Object#class\n  required :class, as: :category\n\n  # Add context for clarity\n  required :template, prefix: true  # =&gt; context_template\n  required :version, suffix: \"_tag\" # =&gt; version_tag\n\n  def work\n    category         # =&gt; \"premium\"\n    context_template # =&gt; \"monthly_report\"\n    version_tag      # =&gt; \"v2.1.0\"\n  end\nend\n\n# Still pass original names\nProcessData.execute(class: \"premium\", template: \"monthly_report\", version: \"v2.1.0\")\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#conditional-requirements","title":"Conditional Requirements","text":"<p>Sometimes an attribute is only required under certain conditions:</p> <pre><code>class PublishContent &lt; CMDx::Task\n  required :title\n  required :content\n  required :status, inclusion: { in: %w[draft published scheduled] }\n\n  # Only required when scheduled\n  required :publish_at, type: :datetime, if: :scheduled?\n\n  # Only required for published content\n  required :author_id, unless: proc { status == \"draft\" }\n\n  def work\n    # ...\n  end\n\n  private\n\n  def scheduled?\n    context.status == \"scheduled\"\n  end\nend\n</code></pre> <p>When the condition is false, the attribute becomes optional. All other features\u2014coercion, validation, defaults\u2014still apply.</p>"},{"location":"blog/mastering-cmdx-attributes/#custom-coercions-and-validators","title":"Custom Coercions and Validators","text":"<p>For domain-specific types, register your own coercions:</p> <pre><code>class GeoCoercion\n  def self.call(value, options = {})\n    case value\n    when Array then Geo::Point.new(*value)\n    when String then Geo::Point.parse(value)\n    when Geo::Point then value\n    else raise CMDx::CoercionError, \"cannot convert to geographic point\"\n    end\n  end\nend\n\nclass DeliverPackage &lt; CMDx::Task\n  register :coercion, :geo_point, GeoCoercion\n\n  required :origin, type: :geo_point\n  required :destination, type: :geo_point\n\n  def work\n    origin      # =&gt; Geo::Point instance\n    destination # =&gt; Geo::Point instance\n  end\nend\n</code></pre> <p>Same pattern for validators:</p> <pre><code>class UUIDValidator\n  UUID_PATTERN = /\\A[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\z/i\n\n  def self.call(value, options = {})\n    return if value.nil? &amp;&amp; options[:allow_nil]\n    raise CMDx::ValidationError, \"is not a valid UUID\" unless value.to_s.match?(UUID_PATTERN)\n  end\nend\n\nclass ProcessEntity &lt; CMDx::Task\n  register :validator, :uuid, UUIDValidator\n\n  required :entity_id, uuid: true\n\n  def work\n    entity_id # Guaranteed to be a valid UUID format\n  end\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#putting-it-all-together","title":"Putting It All Together","text":"<p>Here's a real-world example combining everything\u2014a task that processes subscription upgrades:</p> <pre><code>class UpgradeSubscription &lt; CMDx::Task\n  # Core identifiers\n  required :user_id, uuid: true\n  required :subscription_id, uuid: true\n\n  # Plan details with validation\n  required :new_plan,\n    type: :symbol,\n    inclusion: { in: [:starter, :professional, :enterprise] }\n\n  # Payment info (conditionally required)\n  required :payment_method_id, uuid: true, unless: :enterprise_invoicing?\n\n  optional :billing do\n    required :address_line1, presence: true\n    optional :address_line2\n    required :city, presence: true\n    required :postal_code, format: /\\A\\d{5}(-\\d{4})?\\z/\n    required :country, inclusion: { in: ISO3166::Country.codes }\n  end\n\n  # Proration settings\n  optional :prorate, default: true, type: :boolean\n  optional :proration_date,\n    type: :datetime,\n    default: -&gt; { Time.current }\n\n  # Contact preferences\n  optional :notification_email,\n    transform: -&gt;(v) { v.to_s.downcase.strip },\n    format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    subscription = Subscription.find(subscription_id)\n\n    subscription.upgrade!(\n      plan: new_plan,\n      payment_method_id: payment_method_id,\n      prorate: prorate,\n      proration_date: proration_date,\n      billing_address: billing\n    )\n\n    if notification_email\n      SubscriptionMailer.upgrade_confirmation(notification_email, subscription).deliver_later\n    end\n\n    context.subscription = subscription\n  end\n\n  private\n\n  def enterprise_invoicing?\n    context.new_plan == :enterprise\n  end\nend\n</code></pre> <p>Every attribute has a clear purpose. Types are explicit. Validations are declarative. The task's interface is self-documenting.</p>"},{"location":"blog/mastering-cmdx-attributes/#the-payoff","title":"The Payoff","text":"<p>Well-designed attributes give you:</p> <ol> <li>Self-documenting interfaces \u2014 One glance tells you what data the task needs</li> <li>Fail-fast behavior \u2014 Invalid data never reaches your business logic</li> <li>Consistent error handling \u2014 Structured errors, every time</li> <li>Less defensive coding \u2014 Trust your attributes, focus on business logic</li> </ol> <p>The time you invest in thoughtful attribute design pays dividends in debugging time saved and confidence gained. Your future self (and your teammates) will thank you.</p> <p>Next time you're building a task, start with the attributes. Ask yourself: What data do I need? What shape should it be in? What makes it valid? Answer those questions with attributes, and the rest follows naturally.</p>"},{"location":"blog/mastering-cmdx-attributes/#references","title":"References","text":"<ul> <li>Attribute Definitions</li> <li>Coercions</li> <li>Validations</li> <li>Defaults</li> <li>Transformations</li> <li>Naming</li> </ul>"},{"location":"blog/mastering-cmdx-fundamentals/","title":"Mastering CMDx Fundamentals: Tasks, Context, Execution, and Chains","text":"<p>When I first started building CMDx, I focused obsessively on four concepts: tasks, context, execution, and chains. These aren't just implementation details\u2014they're the mental model that makes everything else click. Once you understand how they work together, you'll write cleaner business logic and debug issues faster.</p> <p>Let me walk you through each piece, building from a simple task to a fully orchestrated task.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#the-task-your-unit-of-work","title":"The Task: Your Unit of Work","text":"<p>A task is where your business logic lives. It's a single, focused unit of work. No more, no less.</p> <pre><code>class SendWelcomeEmail &lt; CMDx::Task\n  def work\n    user = User.find(context.user_id)\n    WelcomeMailer.deliver(user.email)\n    context.email_sent_at = Time.current\n  end\nend\n</code></pre> <p>That's the entire contract: inherit from <code>CMDx::Task</code>, define a <code>work</code> method. If you forget the <code>work</code> method, CMDx reminds you immediately:</p> <pre><code>class IncompleteTask &lt; CMDx::Task\n  # Oops, forgot work\nend\n\nIncompleteTask.execute #=&gt; raises CMDx::UndefinedMethodError\n</code></pre> <p>I designed tasks to be single-use. Once executed, they freeze. You can't run the same task instance twice\u2014that's intentional. Each execution is isolated, traceable, and predictable.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#the-task-lifecycle","title":"The Task Lifecycle","text":"<p>Every task follows the same path:</p> <ol> <li>Instantiation \u2014 Task created, context initialized</li> <li>Validation \u2014 Attributes checked (if you've defined any)</li> <li>Execution \u2014 Your <code>work</code> method runs</li> <li>Completion \u2014 Result finalized, task frozen</li> </ol> <p>Here's what that looks like in practice:</p> <pre><code>task = SendWelcomeEmail.new(user_id: 42)\n\n# Before execution\ntask.result.state   #=&gt; \"initialized\"\ntask.result.status  #=&gt; \"success\"\n\n# Execute\ntask.execute\n\n# After execution\ntask.result.state   #=&gt; \"complete\"\ntask.result.status  #=&gt; \"success\"\ntask.frozen?        #=&gt; true\n</code></pre>"},{"location":"blog/mastering-cmdx-fundamentals/#undoing-work-with-rollback","title":"Undoing Work with Rollback","text":"<p>Sometimes things go wrong downstream and you need to undo what you did. That's what <code>rollback</code> is for:</p> <pre><code>class ChargeCard &lt; CMDx::Task\n  def work\n    context.charge = Stripe::Charge.create(\n      amount: context.amount_cents,\n      customer: context.stripe_customer_id\n    )\n  end\n\n  def rollback\n    Stripe::Refund.create(charge: context.charge.id) if context.charge\n  end\nend\n</code></pre> <p>Rollbacks trigger automatically when a task fails. Your charge goes through, the next step bombs, and CMDx calls your <code>rollback</code> to void it. No manual cleanup orchestration needed.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#context-your-data-container","title":"Context: Your Data Container","text":"<p>Context isn\u2019t an abstraction accident\u2014it exists to solve deterministic data flow between tasks. Unlike instance variables, it explicitly models inputs, outputs, and intermediate values as a shared contract.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#putting-data-in","title":"Putting Data In","text":"<p>Every key-value pair you pass becomes part of the context:</p> <pre><code>result = ProcessOrder.execute(\n  order_id: 123,\n  user: current_user,\n  options: { expedite: true }\n)\n</code></pre> <p>String keys automatically convert to symbols. You can pass a hash, keyword arguments, or even an existing context from a previous task (it's what makes Ruby powerful IMHO \ud83c\udf1f).</p>"},{"location":"blog/mastering-cmdx-fundamentals/#getting-data-out","title":"Getting Data Out","text":"<p>Access context data however feels natural:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    # Method style (my preference)\n    order = Order.find(context.order_id)\n\n    # Hash style\n    user = context[:user]\n\n    # Safe access with defaults\n    expedite = context.fetch(:expedite, false)\n\n    # Nested digging\n    carrier = context.dig(:options, :preferred_carrier)\n\n    # Shorter alias works too\n    priority = ctx.priority\n  end\nend\n</code></pre> <p>Accessing undefined keys returns <code>nil</code> instead of raising errors. That's intentional\u2014optional data shouldn't require defensive coding.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#modifying-context","title":"Modifying Context","text":"<p>Context is your scratchpad during execution:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    order = Order.find(context.order_id)\n\n    # Direct assignment\n    context.order = order\n    context.processed_at = Time.current\n\n    # Conditional assignment\n    context.tracking_number ||= generate_tracking_number\n\n    # Batch updates\n    context.merge!(\n      status: \"processing\",\n      estimated_ship_date: 3.days.from_now\n    )\n\n    # Remove sensitive data before logging\n    context.delete!(:credit_card_number)\n  end\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-fundamentals/#sharing-context-between-tasks","title":"Sharing Context Between Tasks","text":"<p>Here's where context really shines. Tasks naturally chain together:</p> <pre><code>class CreateOrder &lt; CMDx::Task\n  def work\n    context.order = Order.create!(\n      user_id: context.user_id,\n      items: context.items\n    )\n  end\nend\n\nclass ProcessPayment &lt; CMDx::Task\n  def work\n    # context.order is available from the previous task\n    charge = PaymentGateway.charge(\n      amount: context.order.total,\n      customer_id: context.user_id\n    )\n    context.payment = charge\n  end\nend\n\nclass SendConfirmation &lt; CMDx::Task\n  def work\n    # Both order and payment are available\n    OrderMailer.confirmation(\n      order: context.order,\n      payment: context.payment\n    ).deliver_now\n  end\nend\n</code></pre> <p>In a workflow, each task builds on what came before:</p> <pre><code># Execute first task\nresult = CreateOrder.execute(user_id: 42, items: cart_items)\n\n# Pass context to next task\nProcessPayment.execute(result.context)\n\n# And the next\nSendConfirmation.execute(result.context)\n</code></pre> <p>The context accumulates data as it flows through your pipeline. No global state, no hidden dependencies\u2014just explicit data flow.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#execution-two-flavors-one-result","title":"Execution: Two Flavors, One Result","text":"<p>CMDx gives you two ways to run tasks: <code>execute</code> and <code>execute!</code>. Choose based on how you want to handle problems.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#the-safe-path-execute","title":"The Safe Path: <code>execute</code>","text":"<p>Always returns a result, never raises:</p> <pre><code>result = SendWelcomeEmail.execute(user_id: 42)\n\nif result.success?\n  puts \"Email sent at #{result.context.email_sent_at}\"\nelsif result.failed?\n  puts \"Failed: #{result.reason}\"\n  log_failure(result.cause) if result.cause # Original exception\nelsif result.skipped?\n  puts \"Skipped: #{result.reason}\"\nend\n</code></pre> <p>I use this 90% of the time. The result tells me everything I need to know without try/catch ceremony.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#the-assertive-path-execute","title":"The Assertive Path: <code>execute!</code>","text":"<p>Raises exceptions on failure, returns results only on success:</p> <pre><code>begin\n  result = CreateAccount.execute!(email: params[:email])\n  redirect_to dashboard_path\n\nrescue CMDx::FailFault =&gt; e\n  flash[:error] = e.result.reason\n  render :new\n\nrescue CMDx::SkipFault =&gt; e\n  flash[:notice] = \"Account already exists\"\n  redirect_to login_path\nend\n</code></pre> <p>Use <code>execute!</code> when a failure should halt everything. It's great for controller actions where you want to handle the exception at a higher level.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#inspecting-results","title":"Inspecting Results","text":"<p>The result object is packed with useful information:</p> <pre><code>result = ProcessOrder.execute(order_id: 123)\n\n# What happened?\nresult.state      #=&gt; \"complete\"\nresult.status     #=&gt; \"success\"\nresult.success?   #=&gt; true\nresult.failed?    #=&gt; false\nresult.skipped?   #=&gt; false\n\n# The data\nresult.context    #=&gt; Context with all accumulated data\nresult.metadata   #=&gt; Execution metadata hash\n\n# Traceability\nresult.id         #=&gt; Unique execution ID\nresult.task       #=&gt; The frozen task instance\nresult.chain      #=&gt; The execution chain\n</code></pre>"},{"location":"blog/mastering-cmdx-fundamentals/#dry-run-mode","title":"Dry Run Mode","text":"<p>Sometimes you want to simulate execution without side effects. Pass <code>dry_run: true</code>:</p> <pre><code>class CancelSubscription &lt; CMDx::Task\n  def work\n    if dry_run?\n      context.would_cancel = true\n      context.refund_amount = calculate_prorated_refund\n    else\n      Stripe::Subscription.delete(context.subscription_id)\n      context.cancelled_at = Time.current\n    end\n  end\nend\n\n# Simulate\nresult = CancelSubscription.execute(subscription_id: \"sub_123\", dry_run: true)\nresult.context.would_cancel   #=&gt; true\nresult.context.refund_amount  #=&gt; 47.50\n\n# For real\nresult = CancelSubscription.execute(subscription_id: \"sub_123\")\nresult.context.cancelled_at   #=&gt; 2025-01-08 14:32:15 UTC\n</code></pre> <p>Perfect for preview features, admin dashboards, or testing what would happen.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#chains-your-execution-trail","title":"Chains: Your Execution Trail","text":"<p>Every task execution creates or joins a chain. Think of it as an automatic audit trail that tracks what happened, in what order, across related tasks.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#automatic-chain-management","title":"Automatic Chain Management","text":"<p>You don't have to think about chains\u2014they happen automatically:</p> <pre><code>class ImportData &lt; CMDx::Task\n  def work\n    # First subtask starts a chain (or joins existing)\n    result1 = ValidateSchema.execute(context)\n\n    # Second subtask joins the same chain\n    result2 = TransformData.execute(context)\n\n    # Third subtask, same chain\n    result3 = SaveRecords.execute(context)\n\n    # All share the same chain ID\n    result1.chain.id == result2.chain.id  #=&gt; true\n    result2.chain.id == result3.chain.id  #=&gt; true\n  end\nend\n\nresult = ImportData.execute(file_path: \"/data/import.csv\")\nchain = result.chain\n\nchain.id             #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nchain.results.size   #=&gt; 4 (parent + 3 subtasks)\nchain.results.map { |r| r.task.class.name }\n#=&gt; [\"ImportData\", \"ValidateSchema\", \"TransformData\", \"SaveRecords\"]\n</code></pre>"},{"location":"blog/mastering-cmdx-fundamentals/#thread-safety","title":"Thread Safety","text":"<p>Chains are thread-local. Each thread gets its own isolated chain:</p> <pre><code>Thread.new do\n  result = BatchJob.execute(batch_id: 1)\n  result.chain.id  #=&gt; \"abc123...\"\nend\n\nThread.new do\n  result = BatchJob.execute(batch_id: 2)\n  result.chain.id  #=&gt; \"xyz789...\"  # Completely different\nend\n</code></pre> <p>This means parallel job workers never step on each other's chains. No race conditions, no cross-contamination.</p>"},{"location":"blog/mastering-cmdx-fundamentals/#chain-state","title":"Chain State","text":"<p>The chain's state reflects the outermost task:</p> <pre><code>result = ImportData.execute(file_path: \"/data/import.csv\")\nchain = result.chain\n\nchain.state   #=&gt; \"complete\"\nchain.status  #=&gt; \"success\"\nchain.outcome #=&gt; \"success\"\n\n# Individual subtask results maintain their own states\nchain.results.each do |r|\n  puts \"#{r.task.class}: #{r.status}\"\nend\n# ImportData: success\n# ValidateSchema: success\n# TransformData: skipped  (maybe data was already transformed)\n# SaveRecords: success\n</code></pre>"},{"location":"blog/mastering-cmdx-fundamentals/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Tasks are single-purpose \u2014 One <code>work</code> method, one responsibility. Use <code>rollback</code> for cleanup.</p> </li> <li> <p>Context is your data pipeline \u2014 Pass it between tasks. Let it accumulate. Don't fight it with instance variables.</p> </li> <li> <p>Choose your execution style \u2014 <code>execute</code> for result-based flow, <code>execute!</code> for exception-based control.</p> </li> <li> <p>Chains are automatic \u2014 They track everything. Use them for debugging, logging, and auditing.</p> </li> <li> <p>Dry run for safety \u2014 Preview what would happen before doing it for real.</p> </li> </ol> <p>These fundamentals are the foundation for everything else in CMDx\u2014attributes, callbacks, workflows, middlewares. Master these four concepts and you'll be building robust business logic in no time.</p> <p>Happy coding!</p>"},{"location":"blog/mastering-cmdx-fundamentals/#references","title":"References","text":"<ul> <li>Setup</li> <li>Context</li> <li>Execution</li> <li>Chain</li> </ul>"},{"location":"blog/mastering-cmdx-interruptions/","title":"Mastering CMDx Interruptions: Controlling Flow When Things Go Sideways","text":"<p>Business logic isn't always a straight line. Orders get cancelled. Users don't have permissions. External APIs timeout. What separates robust code from fragile code is how gracefully you handle these interruptions.</p> <p>CMDx gives you three tools for this: halt methods (<code>skip!</code> and <code>fail!</code>), exception handling, and faults. Together, they form a complete system for controlling execution flow\u2014whether you're stopping intentionally, handling errors, or propagating failures across tasks.</p>"},{"location":"blog/mastering-cmdx-interruptions/#the-basics-stopping-execution-on-purpose","title":"The Basics: Stopping Execution on Purpose","text":"<p>Let's start simple. You're building a task and something happens that means you shouldn't continue. CMDx gives you two explicit methods: <code>skip!</code> and <code>fail!</code>.</p>"},{"location":"blog/mastering-cmdx-interruptions/#skipping-when-theres-nothing-to-do","title":"Skipping: When There's Nothing to Do","text":"<p>Use <code>skip!</code> when the task legitimately shouldn't run. It's not an error\u2014it's a no-op:</p> <pre><code>class ProcessRefund &lt; CMDx::Task\n  def work\n    refund = Refund.find(context.refund_id)\n\n    if refund.already_processed?\n      skip!(\"Refund was already processed on #{refund.processed_at}\")\n    end\n\n    refund.process!\n    context.refund = refund\n  end\nend\n</code></pre> <p>The key insight: skipped tasks are considered successful outcomes. The task succeeded by recognizing there was nothing to do.</p> <pre><code>result = ProcessRefund.execute(refund_id: 456)\n\nresult.status   #=&gt; \"skipped\"\nresult.reason   #=&gt; \"Refund was already processed on 2025-01-08\"\nresult.good?    #=&gt; true  # Not a failure!\nresult.bad?     #=&gt; true  # But not success either\n</code></pre> <p>I use <code>skip!</code> constantly. Feature flags, already-processed checks, business hours validation\u2014anywhere that \"do nothing\" is the correct outcome.</p>"},{"location":"blog/mastering-cmdx-interruptions/#failing-when-something-goes-wrong","title":"Failing: When Something Goes Wrong","text":"<p>Use <code>fail!</code> when the task cannot complete. This is intentional, controlled failure:</p> <pre><code>class ChargeSubscription &lt; CMDx::Task\n  def work\n    subscription = Subscription.find(context.subscription_id)\n\n    if subscription.cancelled?\n      fail!(\"Cannot charge cancelled subscription\")\n    elsif subscription.payment_method.expired?\n      fail!(\"Payment method has expired\", code: :payment_expired)\n    end\n\n    charge = PaymentGateway.charge(subscription)\n    context.charge = charge\n  end\nend\n</code></pre> <p>Unlike <code>skip!</code>, failed tasks are bad outcomes:</p> <pre><code>result = ChargeSubscription.execute(subscription_id: 789)\n\nresult.status #=&gt; \"failed\"\nresult.reason #=&gt; \"Payment method has expired\"\nresult.good?  #=&gt; false\nresult.bad?   #=&gt; true\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#adding-context-with-metadata","title":"Adding Context with Metadata","text":"<p>Both <code>skip!</code> and <code>fail!</code> accept metadata for richer debugging:</p> <pre><code>class ProcessLicense &lt; CMDx::Task\n  def work\n    license = License.find(context.license_key)\n\n    unless license.renewable?\n      fail!(\n        \"License not eligible for renewal\",\n        error_code: \"LICENSE.NOT_RENEWABLE\",\n        expires_at: license.expires_at,\n        retry_after: license.next_renewal_window\n      )\n    end\n\n    license.renew!\n  end\nend\n\nresult = ProcessLicense.execute(license_key: \"ABC-123\")\n\nresult.metadata[:error_code]   #=&gt; \"LICENSE.NOT_RENEWABLE\"\nresult.metadata[:retry_after]  #=&gt; 2025-02-01 00:00:00 UTC\n</code></pre> <p>This metadata shows up in logs and is available in exception handlers. I always include error codes for API responses and retry hints for transient failures.</p>"},{"location":"blog/mastering-cmdx-interruptions/#exception-handling-when-the-unexpected-happens","title":"Exception Handling: When the Unexpected Happens","text":"<p><code>skip!</code> and <code>fail!</code> are for expected problems. But what about actual exceptions\u2014database timeouts, network failures, nil pointer errors?</p> <p>CMDx handles these differently depending on which execution method you use.</p>"},{"location":"blog/mastering-cmdx-interruptions/#non-bang-execution-capture-everything","title":"Non-bang Execution: Capture Everything","text":"<p>With <code>execute</code>, exceptions become failed results:</p> <pre><code>class FetchExternalData &lt; CMDx::Task\n  def work\n    response = HTTP.get(\"https://api.example.com/data\")\n    context.data = JSON.parse(response.body)\n  end\nend\n\nresult = FetchExternalData.execute\nresult.failed?  #=&gt; true\nresult.reason   #=&gt; \"[HTTP::TimeoutError] Connection timed out after 30s\"\nresult.cause    #=&gt; &lt;HTTP::TimeoutError: Connection timed out after 30s&gt;\n</code></pre> <p>Your calling code doesn't need a <code>rescue</code> block. The result tells you what happened, and the original exception is preserved in <code>cause</code> for debugging.</p> <p>This is my default approach. One consistent pattern, no try/catch ceremony, and the exception is still available if I need to inspect it.</p>"},{"location":"blog/mastering-cmdx-interruptions/#bang-execution-let-exceptions-fly","title":"Bang Execution: Let Exceptions Fly","text":"<p>With <code>execute!</code>, exceptions propagate naturally:</p> <pre><code>begin\n  FetchExternalData.execute!\nrescue HTTP::TimeoutError =&gt; e\n  # Handle network failure\n  fallback_to_cache\nrescue JSON::ParserError =&gt; e\n  # Handle malformed response\n  report_api_degradation\nend\n</code></pre> <p>Use <code>execute!</code> when you want standard Ruby error handling or when failures should halt a larger process.</p>"},{"location":"blog/mastering-cmdx-interruptions/#sending-exceptions-to-apm-tools","title":"Sending Exceptions to APM Tools","text":"<p>When using <code>execute</code> (non-bang), exceptions get captured into results\u2014but you might still want to send them to Sentry, Datadog, or your APM of choice. Configure an exception handler:</p> <pre><code>class ReportingTask &lt; CMDx::Task\n  settings exception_handler: -&gt;(task, exception) {\n    Sentry.capture_exception(exception, extra: {\n      task_class: task.class.name,\n      task_id: task.id,\n      context: task.context.to_h\n    })\n  }\n\n  def work\n    # If this raises, exception goes to Sentry AND becomes a failed result\n    risky_operation!\n  end\nend\n</code></pre> <p>The exception handler fires before the result is finalized, so you get notification while still returning a clean result object.</p>"},{"location":"blog/mastering-cmdx-interruptions/#faults-structured-exceptions-for-halts","title":"Faults: Structured Exceptions for Halts","text":"<p>When you use <code>execute!</code> and a task calls <code>skip!</code> or <code>fail!</code>, CMDx raises a fault\u2014a special exception that carries rich execution context.</p> <pre><code>begin\n  ProcessPayment.execute!(order_id: 123)\nrescue CMDx::SkipFault =&gt; e\n  # Task called skip!\n  puts \"Skipped: #{e.message}\"\nrescue CMDx::FailFault =&gt; e\n  # Task called fail!\n  puts \"Failed: #{e.message}\"\n  puts \"Error code: #{e.result.metadata[:error_code]}\"\nrescue CMDx::Fault =&gt; e\n  # Catch-all for any halt\n  puts \"Interrupted: #{e.message}\"\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#accessing-fault-data","title":"Accessing Fault Data","text":"<p>Faults expose everything about the execution:</p> <pre><code>begin\n  ActivateLicense.execute!(license_key: key)\nrescue CMDx::Fault =&gt; e\n  # Result information\n  e.result.state       #=&gt; \"interrupted\"\n  e.result.status      #=&gt; \"failed\"\n  e.result.reason      #=&gt; \"License already activated\"\n  e.result.metadata    #=&gt; { error_code: \"ALREADY_ACTIVE\" }\n\n  # Task information\n  e.task.class.name    #=&gt; \"ActivateLicense\"\n  e.task.id            #=&gt; \"abc123...\"\n\n  # Context data\n  e.context.license_key #=&gt; \"ABC-123-DEF\"\n\n  # Chain information (if part of a larger flow)\n  e.chain.id           #=&gt; \"def456...\"\n  e.chain.size         #=&gt; 3\nend\n</code></pre> <p>This is invaluable for error reporting. Instead of just \"something failed,\" you get the full picture: what task, what data, what chain of execution.</p>"},{"location":"blog/mastering-cmdx-interruptions/#task-specific-fault-matching","title":"Task-Specific Fault Matching","text":"<p>Sometimes you only want to catch faults from specific tasks. Use <code>for?</code>:</p> <pre><code>begin\n  OrderWorkflow.execute!(order_data: data)\nrescue CMDx::FailFault.for?(PaymentProcessor, FraudCheck) =&gt; e\n  # Only catches failures from these specific tasks\n  handle_payment_failure(e)\nrescue CMDx::SkipFault.for?(InventoryCheck) =&gt; e\n  # Only catches skips from InventoryCheck\n  notify_warehouse(e.context.order_id)\nrescue CMDx::Fault =&gt; e\n  # Everything else\n  generic_error_handler(e)\nend\n</code></pre> <p>This is powerful for workflows where different subtasks need different handling.</p>"},{"location":"blog/mastering-cmdx-interruptions/#custom-matching-logic","title":"Custom Matching Logic","text":"<p>For complex matching, use <code>matches?</code> with a block:</p> <pre><code>begin\n  BatchProcessor.execute!(items: large_batch)\nrescue CMDx::Fault.matches? { |f| f.context.items.size &gt; 1000 } =&gt; e\n  # Large batch failures get special handling\n  split_and_retry(e.context.items)\nrescue CMDx::FailFault.matches? { |f| f.result.metadata[:retryable] } =&gt; e\n  # Retryable failures\n  schedule_retry(e)\nrescue CMDx::Fault =&gt; e\n  # Non-retryable failures\n  abandon_batch(e)\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#propagating-failures-with-throw","title":"Propagating Failures with <code>throw!</code>","text":"<p>Real workflows have nested tasks. When a subtask fails, you often want to propagate that failure up\u2014preserving all the context about what went wrong.</p> <p>That's what <code>throw!</code> does:</p> <pre><code>class GenerateReport &lt; CMDx::Task\n  def work\n    validation_result = ValidateData.execute(context)\n\n    if validation_result.failed?\n      throw!(validation_result)  # Propagates the failure\n    end\n\n    # Only runs if validation succeeded\n    generate_report\n  end\nend\n</code></pre> <p>The <code>throw!</code> method copies the state, status, reason, and metadata from the subtask result. The failure bubbles up with full context about where it originated.</p>"},{"location":"blog/mastering-cmdx-interruptions/#conditional-propagation","title":"Conditional Propagation","text":"<p>You can be selective about what you propagate:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    # Always throw failures\n    inventory_result = CheckInventory.execute(context)\n    throw!(inventory_result) if inventory_result.failed?\n\n    # Only throw skips for certain conditions\n    shipping_result = CalculateShipping.execute(context)\n    if shipping_result.skipped? &amp;&amp; context.requires_shipping\n      throw!(shipping_result)\n    end\n\n    finalize_order\n  end\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#enriching-propagated-failures","title":"Enriching Propagated Failures","text":"<p>Add metadata when propagating:</p> <pre><code>class BatchProcessor &lt; CMDx::Task\n  def work\n    step_result = ProcessItem.execute(context)\n\n    if step_result.failed?\n      throw!(\n        step_result,\n        batch_stage: \"item_processing\",\n        item_index: context.current_index\n      )\n    end\n  end\nend\n</code></pre> <p>The metadata merges with the original failure's metadata, giving you a complete picture.</p>"},{"location":"blog/mastering-cmdx-interruptions/#tracing-failures-through-chains","title":"Tracing Failures Through Chains","text":"<p>When a failure propagates through multiple tasks, you can trace its origin:</p> <pre><code>result = OrderWorkflow.execute(invalid_order_data)\n\nif result.failed?\n  # Find the original failure\n  original = result.caused_failure\n  if original\n    puts \"Original failure: #{original.task.class.name}\"\n    puts \"Reason: #{original.reason}\"\n  end\n\n  # Find what propagated it\n  thrower = result.threw_failure\n  if thrower &amp;&amp; thrower != original\n    puts \"Propagated by: #{thrower.task.class.name}\"\n  end\n\n  # Determine failure type\n  if result.caused_failure?\n    puts \"This task was the original source\"\n  elsif result.thrown_failure?\n    puts \"This task failed due to propagation\"\n  end\nend\n</code></pre> <p>This is incredibly useful for debugging complex workflows. Instead of \"order processing failed,\" you get \"ValidateAddress failed with 'Invalid ZIP code', propagated through ProcessShipping.\"</p>"},{"location":"blog/mastering-cmdx-interruptions/#state-and-status-transitions","title":"State and Status Transitions","text":"<p>Understanding the state model helps you handle results correctly:</p> Method State Status <code>good?</code> <code>bad?</code> (success) <code>complete</code> <code>success</code> <code>true</code> <code>false</code> <code>skip!</code> <code>interrupted</code> <code>skipped</code> <code>true</code> <code>true</code> <code>fail!</code> <code>interrupted</code> <code>failed</code> <code>false</code> <code>true</code> <p>The key distinction: - State tells you how execution ended (complete vs interrupted) - Status tells you what the outcome was (success, skipped, failed) - <code>good?</code> means \"not a failure\" (success or skip) - <code>bad?</code> means \"not a success\" (skip or fail)</p> <p>Use these for conditional logic:</p> <pre><code>result = ProcessOrder.execute(order_id: 123)\n\ncase result.status\nwhen \"success\"\n  puts \"Order processed: #{result.context.order.id}\"\nwhen \"skipped\"\n  puts \"Order skipped: #{result.reason}\"\nwhen \"failed\"\n  puts \"Order failed: #{result.reason}\"\n  handle_failure(result.metadata[:error_code])\nend\n</code></pre> <p>Or with the <code>on</code> callback:</p> <pre><code>ProcessOrder.execute(order_id: 123)\n  .on(:success) { |r| notify_customer(r.context.order) }\n  .on(:skipped) { |r| log_skip(r.reason) }\n  .on(:failed)  { |r| alert_support(r) }\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#best-practices","title":"Best Practices","text":"<p>After building dozens of Ruby applications with CMDx, here's what I've learned:</p>"},{"location":"blog/mastering-cmdx-interruptions/#1-always-provide-reasons","title":"1. Always Provide Reasons","text":"<pre><code># Good: Clear, actionable\nfail!(\"Payment declined: insufficient funds\", code: :insufficient_funds)\nskip!(\"Order already shipped on #{order.shipped_at}\")\n\n# Bad: Vague, unhelpful\nfail!(\"Error\")\nskip!  # Uses default \"Unspecified\"\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#2-use-metadata-for-machine-readable-context","title":"2. Use Metadata for Machine-Readable Context","text":"<pre><code>fail!(\n  \"Rate limit exceeded\",\n  error_code: \"RATE_LIMIT\",\n  retry_after: 60,\n  requests_remaining: 0\n)\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#3-prefer-skip-over-early-returns","title":"3. Prefer <code>skip!</code> Over Early Returns","text":"<pre><code># Good: Intent is clear\nif already_processed?\n  skip!(\"Already processed\")\nend\n\n# Bad: Silent no-op, unclear intent\nreturn if already_processed?\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#4-use-execute-for-most-cases-execute-for-critical-paths","title":"4. Use <code>execute</code> for Most Cases, <code>execute!</code> for Critical Paths","text":"<pre><code># Most code: result-based flow\nresult = ProcessOrder.execute(order_id: id)\nhandle_result(result)\n\n# Critical paths: exception-based control\ndef create_account\n  CreateUser.execute!(params)  # Failure = controller exception\n  redirect_to dashboard_path\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#5-match-faults-specifically-when-it-matters","title":"5. Match Faults Specifically When It Matters","text":"<pre><code>begin\n  Workflow.execute!(data)\nrescue CMDx::FailFault.for?(CriticalTask) =&gt; e\n  escalate_immediately(e)  # Critical tasks need immediate attention\nrescue CMDx::Fault =&gt; e\n  standard_error_handling(e)  # Everything else\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-interruptions/#conclusion","title":"Conclusion","text":"<p>That's the power of CMDx interruptions: explicit control flow, rich context, and clean error handling. No more mystery failures at 2 AM.</p> <p>Happy coding!</p>"},{"location":"blog/mastering-cmdx-interruptions/#references","title":"References","text":"<ul> <li>Halt</li> <li>Faults</li> <li>Exceptions</li> </ul>"},{"location":"blog/mastering-cmdx-outcomes/","title":"Mastering CMDx Outcomes: Results, States, and Statuses","text":"<p>If you've ever found yourself asking \"What does this service object actually return?\", you're not alone. Does it return <code>true</code>? The record it created? A hash with errors? Or does it just raise an exception and hope someone catches it?</p> <p>In my experience, inconsistent return values are the silent killers of maintainable Ruby code. That's why CMDx standardizes everything into a single, powerful concept: the Result.</p>"},{"location":"blog/mastering-cmdx-outcomes/#the-result-object","title":"The Result Object","text":"<p>When you execute a CMDx task, you always get a <code>Result</code> object back. It doesn't matter if the task succeeded, failed, skipped, or exploded with an exception\u2014the interface is consistent.</p> <pre><code>result = CreateInvoice.execute(amount: 100, user: current_user)\n</code></pre> <p>This result object is your single source of truth. It's immutable (so you can pass it around safely), and it carries everything you need to know about what just happened:</p> <ul> <li>Context: The data that went in and came out (<code>result.context</code>)</li> <li>Outcome: Whether it worked (<code>result.success?</code>)</li> <li>Metadata: Error codes, timing information, and more (<code>result.metadata</code>)</li> </ul> <p>But here's where it gets interesting. CMDx breaks down the \"outcome\" into two distinct concepts: State and Status.</p>"},{"location":"blog/mastering-cmdx-outcomes/#state-vs-status-the-critical-distinction","title":"State vs. Status: The Critical Distinction","text":"<p>I often see developers conflate \"lifecycle\" with \"outcome\". In CMDx, we separate them cleanly.</p>"},{"location":"blog/mastering-cmdx-outcomes/#state-the-lifecycle","title":"State: The Lifecycle","text":"<p>State tells you how far the execution got. It answers: \"Did the code finish running?\"</p> <ul> <li><code>initialized</code>: The task was created but hasn't started.</li> <li><code>executing</code>: The code is currently running (transient).</li> <li><code>complete</code>: The code finished from top to bottom without interruption.</li> <li><code>interrupted</code>: The execution was stopped early (by a failure, a manual halt, or an exception).</li> </ul>"},{"location":"blog/mastering-cmdx-outcomes/#status-the-business-outcome","title":"Status: The Business Outcome","text":"<p>Status tells you what happened in business terms. It answers: \"Did we do what we intended?\"</p> <ul> <li><code>success</code>: We did the thing! (Default)</li> <li><code>skipped</code>: We didn't do the thing, but that's okay (e.g., \"Invoice already sent\").</li> <li><code>failed</code>: We couldn't do the thing (e.g., \"Validation error\").</li> </ul>"},{"location":"blog/mastering-cmdx-outcomes/#the-matrix","title":"The Matrix","text":"<p>Understanding how these combine is powerful. Here are the most common scenarios:</p> State Status What it means <code>complete</code> <code>success</code> The happy path. Code ran, job done. <code>interrupted</code> <code>failed</code> Something broke or we called <code>fail!</code>. <code>interrupted</code> <code>skipped</code> We called <code>skip!</code> to stop early. <code>complete</code> <code>skipped</code> We ran everything but decided to mark it as skipped at the end. <p>This separation lets you write precise logic. You might want to log all <code>interrupted</code> tasks for debugging, but only alert on <code>failed</code> statuses.</p>"},{"location":"blog/mastering-cmdx-outcomes/#handling-outcomes-like-a-pro","title":"Handling Outcomes Like a Pro","text":"<p>Now that we have this rich data, how do we use it? CMDx gives you three ways to handle results, ranging from simple to sophisticated.</p>"},{"location":"blog/mastering-cmdx-outcomes/#1-the-predicate-check-simple","title":"1. The Predicate Check (Simple)","text":"<p>Good for simple control flow:</p> <pre><code>result = CreateInvoice.execute(amount: 100)\n\nif result.success?\n  redirect_to invoice_path(result.context.invoice)\nelsif result.skipped?\n  flash[:notice] = \"Invoice already exists.\"\n  redirect_to invoice_path(result.context.invoice)\nelse\n  # result.failed?\n  @errors = result.reason\n  render :new\nend\n</code></pre> <p>You also have helpful grouping predicates like <code>result.good?</code> (success or skipped) and <code>result.bad?</code> (failed or skipped).</p>"},{"location":"blog/mastering-cmdx-outcomes/#2-the-fluent-handlers-functional","title":"2. The Fluent Handlers (Functional)","text":"<p>My personal favorite. This style keeps your controller or caller code extremely clean:</p> <pre><code>CreateInvoice.execute(amount: 100)\n  .on(:success) { |result| redirect_to result.context.invoice }\n  .on(:failed)  { |result| render_errors(result.reason) }\n  .on(:skipped) { |result| log_skip(result) }\n</code></pre> <p>You can even combine them. Use <code>.on(:executed)</code> to run cleanup logic regardless of success or failure.</p>"},{"location":"blog/mastering-cmdx-outcomes/#3-pattern-matching-ruby-30","title":"3. Pattern Matching (Ruby 3.0+)","text":"<p>For complex logic, nothing beats Ruby's pattern matching. CMDx results deconstruct beautifully into both arrays and hashes.</p> <p>Array deconstruction gives you <code>[state, status]</code>:</p> <pre><code>case result\nin [\"complete\", \"success\"]\n  # ...\nin [\"interrupted\", \"failed\"]\n  # ...\nend\n</code></pre> <p>Hash deconstruction is where the magic happens. You can match against specific metadata or error codes:</p> <pre><code>case result\nin { status: \"failed\", metadata: { code: :insufficient_funds } }\n  prompt_to_add_credit_card\nin { status: \"failed\", reason: msg }\n  show_generic_error(msg)\nin { success: true }\n  show_success_confetti\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-outcomes/#digging-deeper-chain-analysis","title":"Digging Deeper: Chain Analysis","text":"<p>When you're running complex workflows (chains of tasks), a failure might happen deep down in the stack. The top-level result wraps everything, but you can trace the origin.</p> <pre><code>result = ProcessOrderWorkflow.execute(order_id: 123)\n\nif result.failed? &amp;&amp; result.caused_failure\n  # Who actually blew up?\n  culprit = result.caused_failure.task.class.name\n  puts \"Workflow failed because #{culprit} failed!\"\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-outcomes/#conclusion","title":"Conclusion","text":"<p>By standardizing on a robust <code>Result</code> object, CMDx takes the guesswork out of your application's flow. You stop writing defensive checks for <code>nil</code> or rescuing generic <code>StandardError</code> everywhere. Instead, you get a clear, typed contract for every operation in your system.</p> <p>So next time you're writing a service object, ask yourself: What is this actually returning? If the answer isn't \"a consistent Result object,\" give CMDx a look.</p>"},{"location":"blog/mastering-cmdx-outcomes/#references","title":"References","text":"<ul> <li>Result</li> <li>States</li> <li>Statuses</li> </ul>"},{"location":"blog/mastering-cmdx-workflows/","title":"Mastering CMDx Workflows: Orchestrating Complex Business Logic","text":"<p>I remember when my service objects started getting messy. I'd have a <code>PlaceOrder</code> service that began as a simple 10-line script but slowly mutated into a 500-line monster handling validation, payments, inventory, shipping, and a dozen notification types. It was a nightmare to test and even harder to read.</p> <p>That's exactly why I built CMDx Workflows. They allow you to decompose complex processes into small, focused tasks and orchestrate them declaratively. It turns your business logic from a tangled mess of <code>if</code> statements into a clean, readable pipeline.</p> <p>Let's dive into how workflows can transform your Ruby application's architecture.</p>"},{"location":"blog/mastering-cmdx-workflows/#the-workflow-pattern","title":"The Workflow Pattern","text":"<p>At its core, a workflow is just a <code>CMDx::Task</code> that coordinates other tasks. Instead of writing a <code>work</code> method with a bunch of procedural code, you declare a sequence of tasks that should run.</p> <p>Here's the simplest possible workflow:</p> <pre><code>class PlaceOrder &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateCart\n  task ReserveInventory\n  task ChargeCard\n  task SendReceipt\nend\n</code></pre> <p>When you run <code>PlaceOrder.execute</code>, CMDx runs these tasks in order. They share the same context, so if <code>ValidateCart</code> sets <code>context.cart_total</code>, <code>ChargeCard</code> can read it immediately. It's seamless data flow without the plumbing code.</p>"},{"location":"blog/mastering-cmdx-workflows/#conditional-logic","title":"Conditional Logic","text":"<p>Real world processes are rarely linear. You have edge cases, optional steps, and business rules.</p> <p>In my order processing example, we faced a common problem: we sold both physical and digital goods. Physical goods need shipping; digital goods need a download link.</p> <p>CMDx Workflows handle this elegantly with <code>if</code> and <code>unless</code> conditionals:</p> <pre><code>class PlaceOrder &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateCart\n  task ReserveInventory\n  task ChargeCard\n\n  # Only run for physical goods\n  task CreateShippingLabel, if: :physical_goods?\n\n  # Only run for digital goods\n  task GenerateDownloadLink, unless: :physical_goods?\n\n  task SendReceipt\n\n  private\n\n  def physical_goods?\n    context.items.any?(&amp;:physical?)\n  end\nend\n</code></pre> <p>You can use methods, Procs, lambdas, or even other classes as conditions. It keeps the high-level flow visible at a glance while hiding the implementation details.</p>"},{"location":"blog/mastering-cmdx-workflows/#grouping-tasks","title":"Grouping Tasks","text":"<p>As our application grew, we added more notifications\u2014SMS, Slack alerts for high-value orders, and email. Instead of repeating conditions for every single task, I used Groups:</p> <pre><code>class PlaceOrder &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # ... core order logic ...\n\n  # All these tasks share the 'if: :success?' condition\n  tasks SendEmailReceipt, SendSmsConfirmation, NotifyAdmins, if: :order_successful?\nend\n</code></pre> <p>This is huge for readability. You can see immediately that this entire block of functionality is conditional.</p>"},{"location":"blog/mastering-cmdx-workflows/#handling-failure-breakpoints","title":"Handling Failure (Breakpoints)","text":"<p>By default, if a task in a workflow is skipped, the workflow continues. But if a task fails? You usually want to stop everything.</p> <p>CMDx lets you control this \"halt behavior\" precisely using breakpoints.</p> <pre><code>class PlaceOrder &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # If validation or inventory fails, stop immediately.\n  # We don't want to charge a card for out-of-stock items!\n  settings(workflow_breakpoints: [\"failed\"])\n\n  task ValidateCart\n  task ReserveInventory\n  task ChargeCard\nend\n</code></pre> <p>If <code>ReserveInventory</code> fails, <code>ChargeCard</code> never runs. The workflow returns a failed result, and you can handle the error gracefully at the controller level.</p>"},{"location":"blog/mastering-cmdx-workflows/#composing-workflows-nested-workflows","title":"Composing Workflows (Nested Workflows)","text":"<p>The most powerful feature of workflows is that they are composable. A workflow is just a task, which means a workflow can include other workflows.</p> <p>This allowed us to extract complex subsystems into their own domains. Our fulfillment logic became so complex it needed its own team:</p> <pre><code>class FulfillmentWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task LocateItems\n  task PrintPackingSlip\n  task RequestCourierPickup\nend\n\nclass PlaceOrder &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateCart\n  task ChargeCard\n\n  # Just drop in the sub-workflow\n  task FulfillmentWorkflow, if: :physical_goods?\nend\n</code></pre> <p><code>PlaceOrder</code> doesn't need to know how fulfillment works; it just knows it needs to happen. This encapsulation is key to maintaining large Ruby codebases.</p>"},{"location":"blog/mastering-cmdx-workflows/#parallel-execution","title":"Parallel Execution","text":"<p>Some tasks don't depend on each other and can run simultaneously. Sending notifications is a perfect example\u2014email, SMS, and push notifications are all independent operations.</p> <p>CMDx supports parallel execution out of the box using the <code>strategy: :parallel</code> option:</p> <pre><code>class PlaceOrder &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateCart\n  task ChargeCard\n\n  # These run concurrently\u2014no waiting for email to finish before SMS\n  tasks SendEmailReceipt, SendSmsConfirmation, NotifySlack, strategy: :parallel\n\n  task UpdateAnalytics\nend\n</code></pre> <p>This uses the Parallel gem under the hood (must be installed in your app or execution environment), automatically utilizing all available processors. You can also fine-tune with <code>in_threads</code> or <code>in_processes</code>:</p> <pre><code># Fixed thread pool\ntasks SendEmailReceipt, SendSmsConfirmation, strategy: :parallel, in_threads: 2\n\n# Forked processes (for CPU-bound work)\ntasks GeneratePdf, GenerateCsv, strategy: :parallel, in_processes: 2\n</code></pre> <p>One gotcha: context is read-only during parallel execution. Since tasks run simultaneously, allowing writes would create race conditions. Load all the data you need before the parallel block, and aggregate results afterward.</p>"},{"location":"blog/mastering-cmdx-workflows/#wrapping-up","title":"Wrapping Up","text":"<p>Workflows changed how I think about service objects. Instead of writing code that does things, I write code that describes what should be done.</p> <ol> <li>Start simple: List your steps as tasks.</li> <li>Add flow control: Use <code>if</code>/<code>unless</code> for logic branches.</li> <li>Group related tasks: Keep your definitions DRY.</li> <li>Compose: Break big workflows into smaller sub-workflows.</li> <li>Parallelization: Execute multiple tasks simultaneously.</li> </ol> <p>Give it a try on your next complex feature. You'll find yourself writing less glue code and more focused business logic.</p>"},{"location":"blog/mastering-cmdx-workflows/#references","title":"References","text":"<ul> <li>Workflows</li> </ul>"},{"location":"interruptions/exceptions/","title":"Interruptions - Exceptions","text":"<p>Exception handling differs between <code>execute</code> and <code>execute!</code>. Choose the method that matches your error handling strategy.</p>"},{"location":"interruptions/exceptions/#exception-handling","title":"Exception Handling","text":"<p>Important</p> <p>Prefer <code>skip!</code> and <code>fail!</code> over raising exceptions\u2014they signal intent more clearly.</p>"},{"location":"interruptions/exceptions/#non-bang-execution","title":"Non-bang execution","text":"<p>Captures all exceptions and returns them as failed results:</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nresult = CompressDocument.execute(document_id: \"unknown-doc-id\")\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.failed?  #=&gt; true\nresult.reason   #=&gt; \"[ActiveRecord::NotFoundError] record not found\"\nresult.cause    #=&gt; &lt;ActiveRecord::NotFoundError&gt;\n</code></pre> <p>Note</p> <p>Use <code>exception_handler</code> with <code>execute</code> to send exceptions to APM tools before they become failed results.</p>"},{"location":"interruptions/exceptions/#bang-execution","title":"Bang execution","text":"<p>Lets exceptions propagate naturally for standard Ruby error handling:</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nbegin\n  CompressDocument.execute!(document_id: \"unknown-doc-id\")\nrescue ActiveRecord::NotFoundError =&gt; e\n  puts \"Handle exception: #{e.message}\"\nend\n</code></pre>"},{"location":"interruptions/faults/","title":"Interruptions - Faults","text":"<p>Faults are exceptions raised by <code>execute!</code> when tasks halt. They carry rich context about execution state, enabling sophisticated error handling patterns.</p>"},{"location":"interruptions/faults/#fault-types","title":"Fault Types","text":"Type Triggered By Use Case <code>CMDx::Fault</code> Base class Catch-all for any interruption <code>CMDx::SkipFault</code> <code>skip!</code> method Optional processing, early returns <code>CMDx::FailFault</code> <code>fail!</code> method Validation errors, processing failures <p>Important</p> <p>All faults inherit from <code>CMDx::Fault</code> and expose result, task, context, and chain data.</p>"},{"location":"interruptions/faults/#fault-handling","title":"Fault Handling","text":"<pre><code>begin\n  ProcessTicket.execute!(ticket_id: 456)\nrescue CMDx::SkipFault =&gt; e\n  logger.info \"Ticket processing skipped: #{e.message}\"\n  schedule_retry(e.context.ticket_id)\nrescue CMDx::FailFault =&gt; e\n  logger.error \"Ticket processing failed: #{e.message}\"\n  notify_admin(e.context.assigned_agent, e.result.metadata[:error_code])\nrescue CMDx::Fault =&gt; e\n  logger.warn \"Ticket processing interrupted: #{e.message}\"\n  rollback_changes\nend\n</code></pre>"},{"location":"interruptions/faults/#data-access","title":"Data Access","text":"<p>Access rich execution data from fault exceptions:</p> <pre><code>begin\n  LicenseActivation.execute!(license_key: key, machine_id: machine)\nrescue CMDx::Fault =&gt; e\n  # Result information\n  e.result.state     #=&gt; \"interrupted\"\n  e.result.status    #=&gt; \"failed\" or \"skipped\"\n  e.result.reason    #=&gt; \"License key already activated\"\n\n  # Task information\n  e.task.class       #=&gt; &lt;LicenseActivation&gt;\n  e.task.id          #=&gt; \"abc123...\"\n\n  # Context data\n  e.context.license_key #=&gt; \"ABC-123-DEF\"\n  e.context.machine_id  #=&gt; \"[FILTERED]\"\n\n  # Chain information\n  e.chain.id         #=&gt; \"def456...\"\n  e.chain.size       #=&gt; 3\nend\n</code></pre>"},{"location":"interruptions/faults/#advanced-matching","title":"Advanced Matching","text":""},{"location":"interruptions/faults/#task-specific-matching","title":"Task-Specific Matching","text":"<p>Handle faults only from specific tasks using <code>for?</code>:</p> <pre><code>begin\n  DocumentWorkflow.execute!(document_data: data)\nrescue CMDx::FailFault.for?(FormatValidator, ContentProcessor) =&gt; e\n  # Handle only document-related failures\n  retry_with_alternate_parser(e.context)\nrescue CMDx::SkipFault.for?(VirusScanner, ContentFilter) =&gt; e\n  # Handle security-related skips\n  quarantine_for_review(e.context.document_id)\nend\n</code></pre>"},{"location":"interruptions/faults/#custom-logic-matching","title":"Custom Logic Matching","text":"<pre><code>begin\n  ReportGenerator.execute!(report: report_data)\nrescue CMDx::Fault.matches? { |f| f.context.data_size &gt; 10_000 } =&gt; e\n  escalate_large_dataset_failure(e)\nrescue CMDx::FailFault.matches? { |f| f.result.metadata[:attempt_count] &gt; 3 } =&gt; e\n  abandon_report_generation(e)\nrescue CMDx::Fault.matches? { |f| f.result.metadata[:error_type] == \"memory\" } =&gt; e\n  increase_memory_and_retry(e)\nend\n</code></pre>"},{"location":"interruptions/faults/#fault-propagation","title":"Fault Propagation","text":"<p>Propagate failures with <code>throw!</code> to preserve context and maintain the error chain:</p>"},{"location":"interruptions/faults/#basic-propagation","title":"Basic Propagation","text":"<pre><code>class ReportGenerator &lt; CMDx::Task\n  def work\n    # Throw if skipped or failed\n    validation_result = DataValidator.execute(context)\n    throw!(validation_result)\n\n    # Only throw if skipped\n    check_permissions = CheckPermissions.execute(context)\n    throw!(check_permissions) if check_permissions.skipped?\n\n    # Only throw if failed\n    data_result = DataProcessor.execute(context)\n    throw!(data_result) if data_result.failed?\n\n    # Continue processing\n    generate_report\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#additional-metadata","title":"Additional Metadata","text":"<pre><code>class BatchProcessor &lt; CMDx::Task\n  def work\n    step_result = FileValidation.execute(context)\n\n    if step_result.failed?\n      throw!(step_result, {\n        batch_stage: \"validation\",\n        can_retry: true,\n        next_step: \"file_repair\"\n      })\n    end\n\n    continue_batch\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#chain-analysis","title":"Chain Analysis","text":"<p>Trace fault origins and propagation through the execution chain:</p> <pre><code>result = DocumentWorkflow.execute(invalid_data)\n\nif result.failed?\n  # Trace the original failure\n  original = result.caused_failure\n  if original\n    puts \"Original failure: #{original.task.class.name}\"\n    puts \"Reason: #{original.reason}\"\n  end\n\n  # Find what propagated the failure\n  thrower = result.threw_failure\n  puts \"Propagated by: #{thrower.task.class.name}\" if thrower\n\n  # Analyze failure type\n  case\n  when result.caused_failure?\n    puts \"This task was the original source\"\n  when result.threw_failure?\n    puts \"This task propagated a failure\"\n  when result.thrown_failure?\n    puts \"This task failed due to propagation\"\n  end\nend\n</code></pre>"},{"location":"interruptions/halt/","title":"Interruptions - Halt","text":"<p>Stop task execution intentionally using <code>skip!</code> or <code>fail!</code>. Both methods signal clear intent about why execution stopped.</p>"},{"location":"interruptions/halt/#skipping","title":"Skipping","text":"<p>Use <code>skip!</code> when the task doesn't need to run. It's a no-op, not an error.</p> <p>Important</p> <p>Skipped tasks are considered \"good\" outcomes\u2014they succeeded by doing nothing.</p> <pre><code>class ProcessInventory &lt; CMDx::Task\n  def work\n    # Without a reason\n    skip! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    # With a reason\n    skip!(\"Warehouse closed\") unless Time.now.hour.between?(8, 18)\n\n    inventory = Inventory.find(context.inventory_id)\n\n    if inventory.already_counted?\n      skip!(\"Inventory already counted today\")\n    else\n      inventory.count!\n    end\n  end\nend\n\nresult = ProcessInventory.execute(inventory_id: 456)\n\n# Executed\nresult.status #=&gt; \"skipped\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Warehouse closed\"\n</code></pre>"},{"location":"interruptions/halt/#failing","title":"Failing","text":"<p>Use <code>fail!</code> when the task can't complete successfully. It signals controlled, intentional failure:</p> <pre><code>class ProcessRefund &lt; CMDx::Task\n  def work\n    # Without a reason\n    fail! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    refund = Refund.find(context.refund_id)\n\n    # With a reason\n    if refund.expired?\n      fail!(\"Refund period has expired\")\n    elsif !refund.amount.positive?\n      fail!(\"Refund amount must be positive\")\n    else\n      refund.process!\n    end\n  end\nend\n\nresult = ProcessRefund.execute(refund_id: 789)\n\n# Executed\nresult.status #=&gt; \"failed\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Refund period has expired\"\n</code></pre>"},{"location":"interruptions/halt/#metadata-enrichment","title":"Metadata Enrichment","text":"<p>Enrich halt calls with metadata for better debugging and error handling:</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    license = License.find(context.license_id)\n\n    if license.already_renewed?\n      # Without metadata\n      skip!(\"License already renewed\")\n    end\n\n    unless license.renewal_eligible?\n      # With metadata\n      fail!(\n        \"License not eligible for renewal\",\n        error_code: \"LICENSE.NOT_ELIGIBLE\",\n        retry_after: Time.current + 30.days\n      )\n    end\n\n    process_renewal\n  end\nend\n\nresult = ProcessRenewal.execute(license_id: 567)\n\n# Without metadata\nresult.metadata #=&gt; {}\n\n# With metadata\nresult.metadata #=&gt; {\n                #     error_code: \"LICENSE.NOT_ELIGIBLE\",\n                #     retry_after: &lt;Time 30 days from now&gt;\n                #   }\n</code></pre>"},{"location":"interruptions/halt/#state-transitions","title":"State Transitions","text":"<p>Halt methods trigger specific state and status transitions:</p> Method State Status Outcome <code>skip!</code> <code>interrupted</code> <code>skipped</code> <code>good? = true</code>, <code>bad? = true</code> <code>fail!</code> <code>interrupted</code> <code>failed</code> <code>good? = false</code>, <code>bad? = true</code> <pre><code>result = ProcessRenewal.execute(license_id: 567)\n\n# State information\nresult.state        #=&gt; \"interrupted\"\nresult.status       #=&gt; \"skipped\" or \"failed\"\nresult.interrupted? #=&gt; true\nresult.complete?    #=&gt; false\n\n# Outcome categorization\nresult.good?        #=&gt; true for skipped, false for failed\nresult.bad?         #=&gt; true for both skipped and failed\n</code></pre>"},{"location":"interruptions/halt/#execution-behavior","title":"Execution Behavior","text":"<p>Halt methods behave differently depending on the call method used:</p>"},{"location":"interruptions/halt/#non-bang-execution","title":"Non-bang execution","text":"<p>Returns result object without raising exceptions:</p> <pre><code>result = ProcessRefund.execute(refund_id: 789)\n\ncase result.status\nwhen \"success\"\n  puts \"Refund processed: $#{result.context.refund.amount}\"\nwhen \"skipped\"\n  puts \"Refund skipped: #{result.reason}\"\nwhen \"failed\"\n  puts \"Refund failed: #{result.reason}\"\n  handle_refund_error(result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#bang-execution","title":"Bang execution","text":"<p>Raises exceptions for halt conditions based on <code>task_breakpoints</code> configuration:</p> <pre><code>begin\n  result = ProcessRefund.execute!(refund_id: 789)\n  puts \"Success: Refund processed\"\nrescue CMDx::SkipFault =&gt; e\n  puts \"Skipped: #{e.message}\"\nrescue CMDx::FailFault =&gt; e\n  puts \"Failed: #{e.message}\"\n  handle_refund_failure(e.result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#best-practices","title":"Best Practices","text":"<p>Always provide a reason for better debugging and clearer exception messages:</p> <pre><code># Good: Clear, specific reason\nskip!(\"Document processing paused for compliance review\")\nfail!(\"File format not supported by processor\", code: \"FORMAT_UNSUPPORTED\")\n\n# Acceptable: Generic, non-specific reason\nskip!(\"Paused\")\nfail!(\"Unsupported\")\n\n# Bad: Default, cannot determine reason\nskip! #=&gt; \"Unspecified\"\nfail! #=&gt; \"Unspecified\"\n</code></pre>"},{"location":"interruptions/halt/#manual-errors","title":"Manual Errors","text":"<p>For rare cases, manually add errors before halting:</p> <p>Important</p> <p>Manual errors don't stop execution\u2014you still need to call <code>fail!</code> or <code>skip!</code>.</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    if document.nonrenewable?\n      errors.add(:document, \"not renewable\")\n      fail!(\"document could not be renewed\")\n    else\n      document.renew!\n    end\n  end\nend\n</code></pre>"},{"location":"outcomes/result/","title":"Outcomes - Result","text":"<p>Results are your window into task execution. They expose everything: outcome, state, timing, context, and metadata.</p>"},{"location":"outcomes/result/#result-attributes","title":"Result Attributes","text":"<p>Access essential execution information:</p> <p>Important</p> <p>Results are immutable after execution completes.</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Object data\nresult.task     #=&gt; &lt;BuildApplication&gt;\nresult.context  #=&gt; &lt;CMDx::Context&gt;\nresult.chain    #=&gt; &lt;CMDx::Chain&gt;\n\n# Execution data\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\n\n# Fault data\nresult.reason   #=&gt; \"Build tool not found\"\nresult.cause    #=&gt; &lt;CMDx::FailFault&gt;\nresult.metadata #=&gt; { error_code: \"BUILD_TOOL.NOT_FOUND\" }\n</code></pre>"},{"location":"outcomes/result/#lifecycle-information","title":"Lifecycle Information","text":"<p>Check execution state, status, and rollback with predicate methods:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# State predicates (execution lifecycle)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\nresult.executed?    #=&gt; true (execution finished)\n\n# Status predicates (execution outcome)\nresult.success?     #=&gt; true (successful execution)\nresult.failed?      #=&gt; false (no failure)\nresult.skipped?     #=&gt; false (not skipped)\n\n# Outcome categorization\nresult.good?        #=&gt; true (success or skipped)\nresult.bad?         #=&gt; false (skipped or failed)\n\n# Retry Status\nresult.retries      #=&gt; 2\nresult.retried?     #=&gt; true (execution was retried)\n\n# Rollback Status\nresult.rolled_back? #=&gt; true (execution was rolled back)\n</code></pre>"},{"location":"outcomes/result/#outcome-analysis","title":"Outcome Analysis","text":"<p>Get a unified outcome string combining state and status:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\nresult.outcome #=&gt; \"success\" (state and status)\n</code></pre>"},{"location":"outcomes/result/#chain-analysis","title":"Chain Analysis","text":"<p>Trace fault origins and propagation:</p> <pre><code>result = DeploymentWorkflow.execute(app_name: \"webapp\")\n\nif result.failed?\n  # Find the original cause of failure\n  if original_failure = result.caused_failure\n    puts \"Root cause: #{original_failure.task.class.name}\"\n    puts \"Reason: #{original_failure.reason}\"\n  end\n\n  # Find what threw the failure to this result\n  if throwing_task = result.threw_failure\n    puts \"Failure source: #{throwing_task.task.class.name}\"\n    puts \"Reason: #{throwing_task.reason}\"\n  end\n\n  # Failure classification\n  result.caused_failure?  #=&gt; true if this result was the original cause\n  result.threw_failure?   #=&gt; true if this result threw a failure\n  result.thrown_failure?  #=&gt; true if this result received a thrown failure\nend\n</code></pre>"},{"location":"outcomes/result/#index-and-position","title":"Index and Position","text":"<p>Results track their position within execution chains:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Position in execution sequence\nresult.index #=&gt; 0 (first task in chain)\n\n# Access via chain\nresult.chain.results[result.index] == result #=&gt; true\n</code></pre>"},{"location":"outcomes/result/#block-yield","title":"Block Yield","text":"<p>Execute code with direct result access:</p> <pre><code>BuildApplication.execute(version: \"1.2.3\") do |result|\n  if result.success?\n    notify_deployment_ready(result)\n  elsif result.failed?\n    handle_build_failure(result)\n  else\n    log_skip_reason(result)\n  end\nend\n</code></pre>"},{"location":"outcomes/result/#handlers","title":"Handlers","text":"<p>Handle outcomes with functional-style methods. Handlers return the result for chaining:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Status-based handlers\nresult\n  .on(:success) { |result| notify_deployment_ready(result) }\n  .on(:failed) { |result| handle_build_failure(result) }\n  .on(:skipped) { |result| log_skip_reason(result) }\n\n# State-based handlers\nresult\n  .on(:complete) { |result| update_build_status(result) }\n  .on(:interrupted) { |result| cleanup_partial_artifacts(result) }\n  .on(:executed) { |result| alert_operations_team(result) } #=&gt; .on(:complete, :interrupted)\n\n# Outcome-based handlers\nresult\n  .on(:good) { |result| increment_success_counter(result) } #=&gt; .on(:success, :skipped)\n  .on(:bad) { |result| alert_operations_team(result) }      #=&gt; .on(:failed, :skipped)\n</code></pre>"},{"location":"outcomes/result/#pattern-matching","title":"Pattern Matching","text":"<p>Use Ruby 3.0+ pattern matching for elegant outcome handling:</p> <p>Important</p> <p>Pattern matching works with both array and hash deconstruction.</p>"},{"location":"outcomes/result/#array-pattern","title":"Array Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin [\"complete\", \"success\"]\n  redirect_to build_success_page\nin [\"interrupted\", \"failed\"]\n  retry_build_with_backoff(result)\nin [\"interrupted\", \"skipped\"]\n  log_skip_and_continue\nend\n</code></pre>"},{"location":"outcomes/result/#hash-pattern","title":"Hash Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin { state: \"complete\", status: \"success\" }\n  celebrate_build_success\nin { status: \"failed\", metadata: { retryable: true } }\n  schedule_build_retry(result)\nin { bad: true, metadata: { reason: String =&gt; reason } }\n  escalate_build_error(\"Build failed: #{reason}\")\nend\n</code></pre>"},{"location":"outcomes/result/#pattern-guards","title":"Pattern Guards","text":"<pre><code>case result\nin { status: \"failed\", metadata: { attempts: n } } if n &lt; 3\n  retry_build_with_delay(result, n * 2)\nin { status: \"failed\", metadata: { attempts: n } } if n &gt;= 3\n  mark_build_permanently_failed(result)\nin { runtime: time } if time &gt; performance_threshold\n  investigate_build_performance(result)\nend\n</code></pre>"},{"location":"outcomes/states/","title":"Outcomes - States","text":"<p>States track where a task is in its execution lifecycle\u2014from creation through completion or interruption.</p>"},{"location":"outcomes/states/#definitions","title":"Definitions","text":"State Description <code>initialized</code> Task created but execution not yet started. Default state for new tasks. <code>executing</code> Task is actively running its business logic. Transient state during execution. <code>complete</code> Task finished execution successfully without any interruption or halt. <code>interrupted</code> Task execution was stopped due to a fault, exception, or explicit halt. <p>State-Status combinations:</p> State Status Meaning <code>initialized</code> <code>success</code> Task created, not yet executed <code>executing</code> <code>success</code> Task currently running <code>complete</code> <code>success</code> Task finished successfully <code>complete</code> <code>skipped</code> Task finished by skipping execution <code>interrupted</code> <code>failed</code> Task stopped due to failure <code>interrupted</code> <code>skipped</code> Task stopped by skip condition"},{"location":"outcomes/states/#transitions","title":"Transitions","text":"<p>Caution</p> <p>States are managed automatically\u2014never modify them manually.</p> <pre><code># Valid state transition flow\ninitialized \u2192 executing \u2192 complete    (successful execution)\ninitialized \u2192 executing \u2192 interrupted (skipped/failed execution)\n</code></pre>"},{"location":"outcomes/states/#predicates","title":"Predicates","text":"<p>Use state predicates to check the current execution lifecycle:</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state checks\nresult.initialized? #=&gt; false (after execution)\nresult.executing?   #=&gt; false (after execution)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\n\n# State categorization\nresult.executed?    #=&gt; true (complete OR interrupted)\n</code></pre>"},{"location":"outcomes/states/#handlers","title":"Handlers","text":"<p>Handle lifecycle events with state-based handlers. Use <code>on(:executed)</code> for cleanup that runs regardless of outcome:</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state handlers\nresult\n  .on(:complete) { |result| send_upload_notification(result) }\n  .on(:interrupted) { |result| cleanup_temp_files(result) }\n  .on(:executed) { |result| log_upload_metrics(result) } #=&gt; .on(:complete, :interrupted)\n</code></pre>"},{"location":"outcomes/statuses/","title":"Outcomes - Statuses","text":"<p>Statuses represent the business outcome\u2014did the task succeed, skip, or fail? This differs from state, which tracks the execution lifecycle.</p>"},{"location":"outcomes/statuses/#definitions","title":"Definitions","text":"Status Description <code>success</code> Task execution completed successfully with expected business outcome. Default status for all tasks. <code>skipped</code> Task intentionally stopped execution because conditions weren't met or continuation was unnecessary. <code>failed</code> Task stopped execution due to business rule violations, validation errors, or exceptions."},{"location":"outcomes/statuses/#transitions","title":"Transitions","text":"<p>Important</p> <p>Status transitions are final and unidirectional. Once skipped or failed, tasks can't return to success.</p> <pre><code># Valid status transitions\nsuccess \u2192 skipped    # via skip!\nsuccess \u2192 failed     # via fail! or exception\n\n# Invalid transitions (will raise errors)\nskipped \u2192 success    # \u274c Cannot transition\nskipped \u2192 failed     # \u274c Cannot transition\nfailed \u2192 success     # \u274c Cannot transition\nfailed \u2192 skipped     # \u274c Cannot transition\n</code></pre>"},{"location":"outcomes/statuses/#predicates","title":"Predicates","text":"<p>Use status predicates to check execution outcomes:</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status checks\nresult.success? #=&gt; true/false\nresult.skipped? #=&gt; true/false\nresult.failed?  #=&gt; true/false\n\n# Outcome categorization\nresult.good?    #=&gt; true if success OR skipped\nresult.bad?     #=&gt; true if skipped OR failed (not success)\n</code></pre>"},{"location":"outcomes/statuses/#handlers","title":"Handlers","text":"<p>Branch business logic with status-based handlers. Use <code>on(:good)</code> and <code>on(:bad)</code> for success/skip vs failed outcomes:</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status handlers\nresult\n  .on(:success) { |result| mark_notification_sent(result) }\n  .on(:skipped) { |result| log_notification_skipped(result) }\n  .on(:failed){ |result| queue_retry_notification(result) }\n\n# Outcome-based handlers\nresult\n  .on(:good) { |result| update_message_stats(result) }  #=&gt; .on(:success, :skipped)\n  .on(:bad) { |result| track_delivery_failure(result) } #=&gt; .on(:failed, :skipped)\n</code></pre>"},{"location":"blog/archive/2026/","title":"February 2026","text":""},{"location":"blog/category/tutorials/","title":"Tutorials","text":""}]}