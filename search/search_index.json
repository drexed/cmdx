{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CMDxCMDx","text":"<p>Build business logic that's powerful, predictable, and maintainable.</p> <p> </p> <p>Say goodbye to messy service objects. CMDx (pronounced \"Command X\") helps you design business logic with clarity and consistency\u2014build faster, debug easier, and ship with confidence.</p> <p>Note</p> <p>Documentation reflects the latest code on <code>main</code>. For version-specific documentation, please refer to the <code>docs/</code> directory within that version's tag.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Ruby: MRI 3.1+ or JRuby 9.4+</li> <li>Dependencies: None</li> </ul> <p>Rails support is built-in, but it's framework-agnostic at its core.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>gem install cmdx\n\n# - or -\n\nbundle add cmdx\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Build powerful business logic in four simple steps:</p>"},{"location":"#1-compose","title":"1. Compose","text":"Full Featured TaskMinimum Viable Task <pre><code>class AnalyzeMetrics &lt; CMDx::Task\n  register :middleware, CMDx::Middlewares::Correlate, id: -&gt; { Current.request_id }\n\n  on_success :track_analysis_completion!\n\n  required :dataset_id, type: :integer, numeric: { min: 1 }\n  optional :analysis_type, default: \"standard\"\n\n  def work\n    if dataset.nil?\n      fail!(\"Dataset not found\", code: 404)\n    elsif dataset.unprocessed?\n      skip!(\"Dataset not ready for analysis\")\n    else\n      context.result = PValueAnalyzer.execute(dataset:, analysis_type:)\n      context.analyzed_at = Time.now\n\n      SendAnalyzedEmail.execute(user_id: Current.account.manager_id)\n    end\n  end\n\n  private\n\n  def dataset\n    @dataset ||= Dataset.find_by(id: dataset_id)\n  end\n\n  def track_analysis_completion!\n    dataset.update!(analysis_result_id: context.result.id)\n  end\nend\n</code></pre> <pre><code>class SendAnalyzedEmail &lt; CMDx::Task\n  def work\n    user = User.find(context.user_id)\n    MetricsMailer.analyzed(user).deliver_now\n  end\nend\n</code></pre>"},{"location":"#2-execute","title":"2. Execute","text":"<pre><code>result = AnalyzeMetrics.execute(\n  dataset_id: 123,\n  \"analysis_type\" =&gt; \"advanced\"\n)\n</code></pre>"},{"location":"#3-react","title":"3. React","text":"<pre><code>if result.success?\n  puts \"Metrics analyzed at #{result.context.analyzed_at}\"\nelsif result.skipped?\n  puts \"Skipping analyzation due to: #{result.reason}\"\nelsif result.failed?\n  puts \"Analyzation failed due to: #{result.reason} with code #{result.metadata[:code]}\"\nend\n</code></pre>"},{"location":"#4-observe","title":"4. Observe","text":"<pre><code>I, [2022-07-17T18:42:37.000000 #3784] INFO -- CMDx:\nindex=1 chain_id=\"018c2b95-23j4-2kj3-32kj-3n4jk3n4jknf\" type=\"Task\" class=\"SendAnalyzedEmail\" state=\"complete\" status=\"success\" metadata={runtime: 347}\n\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"AnalyzeMetrics\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n</code></pre> <p>Ready to dive in? Check out the Getting Started guide to learn more.</p>"},{"location":"#ecosystem","title":"Ecosystem","text":"<ul> <li>cmdx-rspec - RSpec test matchers</li> </ul> <p>For backwards compatibility of certain functionality:</p> <ul> <li>cmdx-i18n - 85+ translations, <code>v1.5.0</code> - <code>v1.6.2</code></li> <li>cmdx-parallel - Parallel workflow tasks, <code>v1.6.1</code> - <code>v1.6.2</code></li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Bug reports and pull requests are welcome at https://github.com/drexed/cmdx. We're committed to fostering a welcoming, collaborative community. Please follow our code of conduct.</p>"},{"location":"#license","title":"License","text":"<p>The gem is available as open source under the terms of the LGPLv3 License.</p>"},{"location":"callbacks/","title":"Callbacks","text":"<p>Run custom logic at specific points during task execution. Callbacks have full access to task context and results, making them perfect for logging, notifications, cleanup, and more.</p> <p>See Global Configuration for framework-wide callback setup.</p> <p>Important</p> <p>Callbacks execute in declaration order (FIFO). Multiple callbacks of the same type run sequentially.</p>"},{"location":"callbacks/#available-callbacks","title":"Available Callbacks","text":"<p>Callbacks execute in a predictable lifecycle order:</p> <pre><code>1. before_validation           # Pre-validation setup\n2. before_execution            # Prepare for execution\n\n# --- Task#work executes ---\n\n3. on_[complete|interrupted]   # State-based (execution lifecycle)\n4. on_executed                 # Always runs after work completes\n5. on_[success|skipped|failed] # Status-based (business outcome)\n6. on_[good|bad]               # Outcome-based (success/skip vs fail)\n</code></pre>"},{"location":"callbacks/#declarations","title":"Declarations","text":""},{"location":"callbacks/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for simple callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  before_execution :find_reservation\n\n  # Batch declarations (works for any type)\n  on_complete :notify_guest, :update_availability\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def find_reservation\n    @reservation ||= Reservation.find(context.reservation_id)\n  end\n\n  def notify_guest\n    GuestNotifier.call(context.guest, result)\n  end\n\n  def update_availability\n    AvailabilityService.update(context.room_ids, result)\n  end\nend\n</code></pre>"},{"location":"callbacks/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for inline callback logic:</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Proc\n  on_interrupted proc { ReservationSystem.pause! }\n\n  # Lambda\n  on_complete -&gt; { ReservationSystem.resume! }\nend\n</code></pre>"},{"location":"callbacks/#class-or-module","title":"Class or Module","text":"<p>Implement reusable callback logic in dedicated modules and classes:</p> <pre><code>class BookingConfirmationCallback\n  def call(task)\n    if task.result.success?\n      MessagingApi.send_confirmation(task.context.guest)\n    else\n      MessagingApi.send_issue_alert(task.context.manager)\n    end\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # Class or Module\n  on_success BookingConfirmationCallback\n\n  # Instance\n  on_interrupted BookingConfirmationCallback.new\nend\n</code></pre>"},{"location":"callbacks/#conditional-execution","title":"Conditional Execution","text":"<p>Control callback execution with conditional logic:</p> <pre><code>class MessagingPermissionCheck\n  def call(task)\n    task.context.guest.can?(:receive_messages)\n  end\nend\n\nclass ProcessBooking &lt; CMDx::Task\n  # If and/or Unless\n  before_execution :notify_guest, if: :messaging_enabled?, unless: :messaging_blocked?\n\n  # Proc\n  on_failure :increment_failure, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Legacy\") }\n\n  # Lambda\n  on_success :ping_housekeeping, if: proc { context.rooms_need_cleaning? }\n\n  # Class or Module\n  on_complete :send_confirmation, unless: MessagingPermissionCheck\n\n  # Instance\n  on_complete :send_confirmation, if: MessagingPermissionCheck.new\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def messaging_enabled?\n    context.guest.messaging_preference == true\n  end\n\n  def messaging_blocked?\n    context.guest.communication_status == :blocked\n  end\nend\n</code></pre>"},{"location":"callbacks/#callback-removal","title":"Callback Removal","text":"<p>Remove unwanted callbacks dynamically:</p> <p>Important</p> <p>Each <code>deregister</code> call removes one callback. Use multiple calls for batch removals.</p> <pre><code>class ProcessBooking &lt; CMDx::Task\n  # Symbol\n  deregister :callback, :before_execution, :notify_guest\n\n  # Class or Module (no instances)\n  deregister :callback, :on_complete, BookingConfirmationCallback\nend\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>Configure CMDx to customize framework behavior, register components, and control execution flow through global defaults with task-level overrides.</p>"},{"location":"configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>CMDx uses a straightforward two-tier configuration system:</p> <ol> <li>Global Configuration \u2014 Framework-wide defaults</li> <li>Task Settings \u2014 Class-level overrides using <code>settings</code></li> </ol> <p>Important</p> <p>Task settings take precedence over global config. Settings are inherited from parent classes and can be overridden in subclasses.</p>"},{"location":"configuration/#global-configuration","title":"Global Configuration","text":"<p>Configure framework-wide defaults that apply to all tasks. These settings come with sensible defaults out of the box.</p>"},{"location":"configuration/#breakpoints","title":"Breakpoints","text":"<p>Control when <code>execute!</code> raises a <code>CMDx::Fault</code> based on task status.</p> <pre><code>CMDx.configure do |config|\n  config.task_breakpoints = \"failed\" # String or Array[String]\nend\n</code></pre> <p>For workflows, configure which statuses halt the execution pipeline:</p> <pre><code>CMDx.configure do |config|\n  config.workflow_breakpoints = [\"skipped\", \"failed\"]\nend\n</code></pre>"},{"location":"configuration/#rollback","title":"Rollback","text":"<p>Control when a <code>rollback</code> of task execution is called.</p> <pre><code>CMDx.configure do |config|\n  config.rollback_on = [\"failed\"] # String or Array[String]\nend\n</code></pre>"},{"location":"configuration/#backtraces","title":"Backtraces","text":"<p>Enable detailed backtraces for non-fault exceptions to improve debugging. Optionally clean up stack traces to remove framework noise.</p> <p>Note</p> <p>In Rails environments, <code>backtrace_cleaner</code> defaults to <code>Rails.backtrace_cleaner.clean</code>.</p> <pre><code>CMDx.configure do |config|\n  # Truthy\n  config.backtrace = true\n\n  # Via callable (must respond to `call(backtrace)`)\n  config.backtrace_cleaner = AdvanceCleaner.new\n\n  # Via proc or lambda\n  config.backtrace_cleaner = -&gt;(backtrace) { backtrace[0..5] }\nend\n</code></pre>"},{"location":"configuration/#exception-handlers","title":"Exception Handlers","text":"<p>Register handlers that run when non-fault exceptions occur.</p> <p>Tip</p> <p>Use exception handlers to send errors to your APM of choice.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, exception)`)\n  config.exception_handler = NewRelicReporter\n\n  # Via proc or lambda\n  config.exception_handler = proc do |task, exception|\n    APMService.report(exception, extra_data: { task: task.name, id: task.id })\n  end\nend\n</code></pre>"},{"location":"configuration/#logging","title":"Logging","text":"<pre><code>CMDx.configure do |config|\n  config.logger = CustomLogger.new($stdout)\nend\n</code></pre>"},{"location":"configuration/#middlewares","title":"Middlewares","text":"<p>See the Middlewares docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(task, options)`)\n  config.middlewares.register CMDx::Middlewares::Timeout\n\n  # Via proc or lambda\n  config.middlewares.register proc { |task, options|\n    start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    result = yield\n    end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n    Rails.logger.debug { \"task completed in #{((end_time - start_time) * 1000).round(2)}ms\" }\n    result\n  }\n\n  # With options\n  config.middlewares.register AuditTrailMiddleware, service_name: \"document_processor\"\n\n  # Remove middleware\n  config.middlewares.deregister CMDx::Middlewares::Timeout\nend\n</code></pre> <p>Note</p> <p>Middlewares are executed in registration order. Each middleware wraps the next, creating an execution chain around task logic.</p>"},{"location":"configuration/#callbacks","title":"Callbacks","text":"<p>See the Callbacks docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via method\n  config.callbacks.register :before_execution, :initialize_user_session\n\n  # Via callable (must respond to `call(task)`)\n  config.callbacks.register :on_success, LogUserActivity\n\n  # Via proc or lambda\n  config.callbacks.register :on_complete, proc { |task|\n    execution_time = task.metadata[:runtime]\n    Metrics.timer(\"task.execution_time\", execution_time, tags: [\"task:#{task.class.name.underscore}\"])\n  }\n\n  # With options\n  config.callbacks.register :on_failure, :send_alert_notification, if: :critical_task?\n\n  # Remove callback\n  config.callbacks.deregister :on_success, LogUserActivity\nend\n</code></pre>"},{"location":"configuration/#coercions","title":"Coercions","text":"<p>See the Attributes - Coercions docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.coercions.register :currency, CurrencyCoercion\n\n  # Via method (must match signature `def coordinates_coercion(value, options)`)\n  config.coercions.register :coordinates, :coordinates_coercion\n\n  # Via proc or lambda\n  config.coercions.register :tag_list, proc { |value, options|\n    delimiter = options[:delimiter] || ','\n    max_tags = options[:max_tags] || 50\n\n    tags = value.to_s.split(delimiter).map(&amp;:strip).reject(&amp;:empty?)\n    tags.first(max_tags)\n  }\n\n  # Remove coercion\n  config.coercions.deregister :currency\nend\n</code></pre>"},{"location":"configuration/#validators","title":"Validators","text":"<p>See the Attributes - Validations docs for task level configurations.</p> <pre><code>CMDx.configure do |config|\n  # Via callable (must respond to `call(value, options)`)\n  config.validators.register :username, UsernameValidator\n\n  # Via method (must match signature `def url_validator(value, options)`)\n  config.validators.register :url, :url_validator\n\n  # Via proc or lambda\n  config.validators.register :access_token, proc { |value, options|\n    expected_prefix = options[:prefix] || \"tok_\"\n    minimum_length = options[:min_length] || 40\n\n    value.start_with?(expected_prefix) &amp;&amp; value.length &gt;= minimum_length\n  }\n\n  # Remove validator\n  config.validators.deregister :username\nend\n</code></pre>"},{"location":"configuration/#task-configuration","title":"Task Configuration","text":""},{"location":"configuration/#settings","title":"Settings","text":"<p>Override global configuration for specific tasks using <code>settings</code>:</p> <pre><code>class GenerateInvoice &lt; CMDx::Task\n  settings(\n    # Global configuration overrides\n    task_breakpoints: [\"failed\"],                # Breakpoint override\n    workflow_breakpoints: [],                    # Breakpoint override\n    backtrace: true,                             # Toggle backtrace\n    backtrace_cleaner: -&gt;(bt) { bt[0..5] },      # Backtrace cleaner\n    logger: CustomLogger.new($stdout),           # Custom logger\n\n    # Task configuration settings\n    breakpoints: [\"failed\"],                     # Contextual pointer for :task_breakpoints and :workflow_breakpoints\n    log_level: :info,                            # Log level override\n    log_formatter: CMDx::LogFormatters::Json.new # Log formatter override\n    tags: [\"billing\", \"financial\"],              # Logging tags\n    deprecated: true,                            # Task deprecations\n    retries: 3,                                  # Non-fault exception retries\n    retry_on: [External::ApiError],              # List of exceptions to retry on\n    retry_jitter: 1,                             # Space between retry iteration, eg: current retry num + 1\n    rollback_on: [\"failed\", \"skipped\"],          # Rollback on override\n  )\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Important</p> <p>Retries reuse the same context. By default, all <code>StandardError</code> exceptions (including faults) are retried unless you specify <code>retry_on</code> option for specific matches.</p>"},{"location":"configuration/#registrations","title":"Registrations","text":"<p>Register or deregister middlewares, callbacks, coercions, and validators for specific tasks:</p> <pre><code>class SendCampaignEmail &lt; CMDx::Task\n  # Middlewares\n  register :middleware, CMDx::Middlewares::Timeout\n  deregister :middleware, AuditTrailMiddleware\n\n  # Callbacks\n  register :callback, :on_complete, proc { |task|\n    runtime = task.metadata[:runtime]\n    Analytics.track(\"email_campaign.sent\", runtime, tags: [\"task:#{task.class.name}\"])\n  }\n  deregister :callback, :before_execution, :initialize_user_session\n\n  # Coercions\n  register :coercion, :currency, CurrencyCoercion\n  deregister :coercion, :coordinates\n\n  # Validators\n  register :validator, :username, :username_validator\n  deregister :validator, :url\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"configuration/#configuration-management","title":"Configuration Management","text":""},{"location":"configuration/#access","title":"Access","text":"<pre><code># Global configuration access\nCMDx.configuration.logger               #=&gt; &lt;Logger instance&gt;\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"]\nCMDx.configuration.middlewares.registry #=&gt; [&lt;Middleware&gt;, ...]\n\n# Task configuration access\nclass ProcessUpload &lt; CMDx::Task\n  settings(tags: [\"files\", \"storage\"])\n\n  def work\n    self.class.settings[:logger] #=&gt; Global configuration value\n    self.class.settings[:tags]   #=&gt; Task configuration value =&gt; [\"files\", \"storage\"]\n  end\nend\n</code></pre>"},{"location":"configuration/#resetting","title":"Resetting","text":"<p>Warning</p> <p>Resetting affects your entire application. Use this primarily in test environments.</p> <pre><code># Reset to framework defaults\nCMDx.reset_configuration!\n\n# Verify reset\nCMDx.configuration.task_breakpoints     #=&gt; [\"failed\"] (default)\nCMDx.configuration.middlewares.registry #=&gt; Empty registry\n\n# Commonly used in test setup (RSpec example)\nRSpec.configure do |config|\n  config.before(:each) do\n    CMDx.reset_configuration!\n  end\nend\n</code></pre>"},{"location":"deprecation/","title":"Task Deprecation","text":"<p>Manage legacy tasks gracefully with built-in deprecation support. Choose how to handle deprecated tasks\u2014log warnings for awareness, issue Ruby warnings for development, or prevent execution entirely.</p>"},{"location":"deprecation/#modes","title":"Modes","text":""},{"location":"deprecation/#raise","title":"Raise","text":"<p>Prevent task execution completely. Perfect for tasks that must no longer run.</p> <p>Warning</p> <p>Use <code>:raise</code> mode carefully\u2014it will break existing workflows immediately.</p> <pre><code>class ProcessObsoleteAPI &lt; CMDx::Task\n  settings(deprecated: :raise)\n\n  def work\n    # Will never execute...\n  end\nend\n\nresult = ProcessObsoleteAPI.execute\n#=&gt; raises CMDx::DeprecationError: \"ProcessObsoleteAPI usage prohibited\"\n</code></pre>"},{"location":"deprecation/#log","title":"Log","text":"<p>Allow execution while tracking deprecation in logs. Ideal for gradual migrations.</p> <pre><code>class ProcessLegacyFormat &lt; CMDx::Task\n  settings(deprecated: :log)\n  settings(deprecated: true)\n\n  def work\n    # Executes but logs deprecation warning...\n  end\nend\n\nresult = ProcessLegacyFormat.execute\nresult.successful? #=&gt; true\n\n# Deprecation warning appears in logs:\n# WARN -- : DEPRECATED: ProcessLegacyFormat - migrate to replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#warn","title":"Warn","text":"<p>Issue Ruby warnings visible during development and testing. Keeps production logs clean while alerting developers.</p> <pre><code>class ProcessOldData &lt; CMDx::Task\n  settings(deprecated: :warn)\n\n  def work\n    # Executes but emits Ruby warning...\n  end\nend\n\nresult = ProcessOldData.execute\nresult.successful? #=&gt; true\n\n# Ruby warning appears in stderr:\n# [ProcessOldData] DEPRECATED: migrate to a replacement or discontinue use\n</code></pre>"},{"location":"deprecation/#declarations","title":"Declarations","text":""},{"location":"deprecation/#symbol-or-string","title":"Symbol or String","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecated: :raise)\n\n  # String\n  settings(deprecated: \"warn\")\nend\n</code></pre>"},{"location":"deprecation/#boolean-or-nil","title":"Boolean or Nil","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Deprecates with default :log mode\n  settings(deprecated: true)\n\n  # Skips deprecation\n  settings(deprecated: false)\n  settings(deprecated: nil)\nend\n</code></pre>"},{"location":"deprecation/#method","title":"Method","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Symbol\n  settings(deprecated: :deprecated?)\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def deprecated?\n    Time.now.year &gt; 2024 ? :raise : false\n  end\nend\n</code></pre>"},{"location":"deprecation/#proc-or-lambda","title":"Proc or Lambda","text":"<pre><code>class OutdatedConnector &lt; CMDx::Task\n  # Proc\n  settings(deprecated: proc { Rails.env.development? ? :raise : :log })\n\n  # Lambda\n  settings(deprecated: -&gt; { Current.tenant.legacy_mode? ? :warn : :raise })\nend\n</code></pre>"},{"location":"deprecation/#class-or-module","title":"Class or Module","text":"<pre><code>class OutdatedTaskDeprecator\n  def call(task)\n    task.class.name.include?(\"Outdated\")\n  end\nend\n\nclass OutdatedConnector &lt; CMDx::Task\n  # Class or Module\n  settings(deprecated: OutdatedTaskDeprecator)\n\n  # Instance\n  settings(deprecated: OutdatedTaskDeprecator.new)\nend\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>CMDx is a Ruby framework for building maintainable, observable business logic through composable command objects. It brings structure, consistency, and powerful developer tools to your business processes.</p> <p>Common challenges:</p> <ul> <li>Inconsistent service object patterns across your codebase</li> <li>Black boxes make debugging a nightmare</li> <li>Fragile error handling erodes confidence</li> </ul> <p>What you get:</p> <ul> <li>Consistent, standardized architecture</li> <li>Built-in flow control and error handling</li> <li>Composable, reusable workflows</li> <li>Comprehensive logging for observability</li> <li>Attribute validation with type coercions</li> <li>Sensible defaults and developer-friendly APIs</li> </ul>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Add CMDx to your Gemfile:</p> <pre><code>gem install cmdx\n\n# - or -\n\nbundle add cmdx\n</code></pre>"},{"location":"getting_started/#configuration","title":"Configuration","text":"<p>For Rails applications, run the following command to generate a global configuration file in <code>config/initializers/cmdx.rb</code>.</p> <pre><code>rails generate cmdx:install\n</code></pre> <p>If not using Rails, manually copy the configuration file.</p>"},{"location":"getting_started/#the-cero-pattern","title":"The CERO Pattern","text":"<p>CMDx embraces the Compose, Execute, React, Observe (CERO, pronounced \"zero\") pattern\u2014a simple yet powerful approach to building reliable business logic.</p> <pre><code>flowchart LR\n    Compose --&gt; Execute\n    Execute --&gt; React\n    Execute -.-&gt; Observe</code></pre>"},{"location":"getting_started/#compose","title":"Compose","text":"<p>Build reusable, single-responsibility tasks with typed attributes, validation, and callbacks. Tasks can be chained together in workflows to create complex business processes from simple building blocks.</p> <pre><code>class AnalyzeMetrics &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"getting_started/#execute","title":"Execute","text":"<p>Invoke tasks with a consistent API that always returns a result object. Execution automatically handles validation, type coercion, error handling, and logging. Arguments are validated and coerced before your task logic runs.</p> <pre><code># Without args\nresult = AnalyzeMetrics.execute\n\n# With args\nresult = AnalyzeMetrics.execute(model: \"blackbox\", \"sensitivity\" =&gt; 3)\n</code></pre>"},{"location":"getting_started/#react","title":"React","text":"<p>Every execution returns a result object with a clear outcome. Check the result's state (<code>success?</code>, <code>failed?</code>, <code>skipped?</code>) and access returned values, error messages, and metadata to make informed decisions.</p> <pre><code>if result.success?\n  # Handle success\nelsif result.skipped?\n  # Handle skipped\nelsif result.failed?\n  # Handle failed\nend\n</code></pre>"},{"location":"getting_started/#observe","title":"Observe","text":"<p>Every task execution generates structured logs with execution chains, runtime metrics, and contextual metadata. Logs can be automatically correlated using chain IDs, making it easy to trace complex workflows and debug issues.</p> <pre><code>I, [2022-07-17T18:42:37.000000 #3784] INFO -- CMDx:\nindex=1 chain_id=\"018c2b95-23j4-2kj3-32kj-3n4jk3n4jknf\" type=\"Task\" class=\"SendAnalyzedEmail\" state=\"complete\" status=\"success\" metadata={runtime: 347}\n\nI, [2022-07-17T18:43:15.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"AnalyzeMetrics\" state=\"complete\" status=\"success\" metadata={runtime: 187}\n</code></pre> <p>Note</p> <p>This represents a log-only event-sourcing approach, enabling full traceability and a complete, time-ordered view of system behavior.</p>"},{"location":"getting_started/#domain-driven-design","title":"Domain Driven Design","text":"<p>CMDx facilitates Domain Driven Design (DDD) by making business processes explicit and structural.</p> <ul> <li> <p>Ubiquitous Language: Task names like <code>ApproveLoan</code> or <code>ShipOrder</code> mirror the language of domain experts, creating a shared vocabulary that eliminates translation gaps between business requirements and code.</p> </li> <li> <p>Bounded Contexts: Namespaces naturally enforce boundaries. <code>Billing::GenerateInvoice</code> and <code>Shipping::GenerateLabel</code> encapsulate logic within their specific domains, preventing leakage and \"God objects.\"</p> </li> <li> <p>Rich Domain Layer: Move orchestration and rules out of Controllers and ActiveRecord models. Entities focus on state; CMDx tasks handle behavior. This separation prevents \"Fat Models\" and keeps business logic testable and isolated.</p> </li> </ul>"},{"location":"getting_started/#event-sourcing-replacement","title":"Event Sourcing Replacement","text":"<p>Traditional Event Sourcing architectures impose a significant \"complexity tax\"\u2014requiring specialized event stores, snapshots, and complex state rehydration logic. CMDx offers a pragmatic alternative: Log-Based Event Sourcing.</p> <p>By ensuring all state changes occur through CMDx tasks, your structured logs become a complete, immutable ledger of system behavior.</p> <ul> <li> <p>Audit Trail: Every execution is automatically logged with its inputs, status, and metadata. This provides a detailed history of intent (arguments) and outcome (success/failure) without extra coding.</p> </li> <li> <p>Reconstructability Because commands encapsulate all inputs required for an action, you can reconstruct past system states or replay business logic by inspecting the command history, giving you the traceability of Event Sourcing without the infrastructure overhead.</p> </li> <li> <p>Simplified Architecture Keep your standard relational database for current state queries (the \"Read Model\") while using CMDx logs as your historical record (the \"Write Model\"). This gives you CQRS-like benefits without the complexity of maintaining separate projections.</p> </li> </ul>"},{"location":"getting_started/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:task ModerateBlogPost\n</code></pre> <p>This creates a new task file with the basic structure:</p> <pre><code># app/tasks/moderate_blog_post.rb\nclass ModerateBlogPost &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + noun for task names, eg: <code>ModerateBlogPost</code>, <code>ScheduleAppointment</code>, <code>ValidateDocument</code></p>"},{"location":"getting_started/#type-safety","title":"Type safety","text":"<p>CMDx includes built-in RBS (Ruby Type Signature) inline annotations throughout the codebase, providing type information for static analysis and editor support.</p> <ul> <li>Type checking \u2014 Catch type errors before runtime using tools like Steep or TypeProf</li> <li>Better IDE support \u2014 Enhanced autocomplete, navigation, and inline documentation</li> <li>Self-documenting code \u2014 Clear method signatures and return types</li> <li>Refactoring confidence \u2014 Type-aware refactoring reduces bugs</li> </ul>"},{"location":"internationalization/","title":"Internationalization (i18n)","text":"<p>CMDx supports 90+ languages out of the box for all error messages, validations, coercions, and faults. Error messages automatically adapt to the current <code>I18n.locale</code>, making it easy to build applications for global audiences.</p>"},{"location":"internationalization/#usage","title":"Usage","text":"<p>All error messages are automatically localized based on your current locale:</p> <pre><code>class ProcessQuote &lt; CMDx::Task\n  attribute :price, type: :float\n\n  def work\n    # Your logic here...\n  end\nend\n\nI18n.with_locale(:fr) do\n  result = ProcessQuote.execute(price: \"invalid\")\n  result.metadata[:messages][:price] #=&gt; [\"impossible de contraindre en float\"]\nend\n</code></pre>"},{"location":"internationalization/#configuration","title":"Configuration","text":"<p>CMDx uses the <code>I18n</code> gem for localization. In Rails, locales load automatically.</p>"},{"location":"internationalization/#copy-locale-files","title":"Copy Locale Files","text":"<p>Copy locale files to your Rails application's <code>config/locales</code> directory:</p> <pre><code>rails generate cmdx:locale [LOCALE]\n\n# Eg: generate french locale\nrails generate cmdx:locale fr\n</code></pre>"},{"location":"internationalization/#available-locales","title":"Available Locales","text":"<ul> <li>af - Afrikaans</li> <li>ar - Arabic</li> <li>az - Azerbaijani</li> <li>be - Belarusian</li> <li>bg - Bulgarian</li> <li>bn - Bengali</li> <li>bs - Bosnian</li> <li>ca - Catalan</li> <li>cnr - Montenegrin</li> <li>cs - Czech</li> <li>cy - Welsh</li> <li>da - Danish</li> <li>de - German</li> <li>dz - Dzongkha</li> <li>el - Greek</li> <li>en - English</li> <li>eo - Esperanto</li> <li>es - Spanish</li> <li>et - Estonian</li> <li>eu - Basque</li> <li>fa - Persian</li> <li>fi - Finnish</li> <li>fr - French</li> <li>fy - Western Frisian</li> <li>gd - Scottish Gaelic</li> <li>gl - Galician</li> <li>he - Hebrew</li> <li>hi - Hindi</li> <li>hr - Croatian</li> <li>hu - Hungarian</li> <li>hy - Armenian</li> <li>id - Indonesian</li> <li>is - Icelandic</li> <li>it - Italian</li> <li>ja - Japanese</li> <li>ka - Georgian</li> <li>kk - Kazakh</li> <li>km - Khmer</li> <li>kn - Kannada</li> <li>ko - Korean</li> <li>lb - Luxembourgish</li> <li>lo - Lao</li> <li>lt - Lithuanian</li> <li>lv - Latvian</li> <li>mg - Malagasy</li> <li>mk - Macedonian</li> <li>ml - Malayalam</li> <li>mn - Mongolian</li> <li>mr-IN - Marathi (India)</li> <li>ms - Malay</li> <li>nb - Norwegian Bokm\u00e5l</li> <li>ne - Nepali</li> <li>nl - Dutch</li> <li>nn - Norwegian Nynorsk</li> <li>oc - Occitan</li> <li>or - Odia</li> <li>pa - Punjabi</li> <li>pl - Polish</li> <li>pt - Portuguese</li> <li>rm - Romansh</li> <li>ro - Romanian</li> <li>ru - Russian</li> <li>sc - Sardinian</li> <li>sk - Slovak</li> <li>sl - Slovenian</li> <li>sq - Albanian</li> <li>sr - Serbian</li> <li>st - Southern Sotho</li> <li>sv - Swedish</li> <li>sw - Swahili</li> <li>ta - Tamil</li> <li>te - Telugu</li> <li>th - Thai</li> <li>tl - Tagalog</li> <li>tr - Turkish</li> <li>tt - Tatar</li> <li>ug - Uyghur</li> <li>uk - Ukrainian</li> <li>ur - Urdu</li> <li>uz - Uzbek</li> <li>vi - Vietnamese</li> <li>wo - Wolof</li> <li>zh-CN - Chinese (Simplified)</li> <li>zh-HK - Chinese (Hong Kong)</li> <li>zh-TW - Chinese (Traditional)</li> <li>zh-YUE - Chinese (Yue)</li> </ul>"},{"location":"logging/","title":"Logging","text":"<p>CMDx automatically logs every task execution with structured data, making debugging and monitoring effortless. Choose from multiple formatters to match your logging infrastructure.</p>"},{"location":"logging/#formatters","title":"Formatters","text":"<p>Choose the format that works best for your logging system:</p> Formatter Use Case Output Style <code>Line</code> Traditional logging Single-line format <code>Json</code> Structured systems Compact JSON <code>KeyValue</code> Log parsing <code>key=value</code> pairs <code>Logstash</code> ELK stack JSON with @version/@timestamp <code>Raw</code> Minimal output Message content only <p>Sample output:</p> <pre><code>&lt;!-- Success (INFO level) --&gt;\nI, [2025-12-23T17:04:07.292614Z #20108] INFO -- cmdx: {index: 1, chain_id: \"019b4c2b-087b-79be-8ef2-96c11b659df5\", type: \"Task\", tags: [], class: \"GenerateInvoice\", dry_run: false, id: \"019b4c2b-0878-704d-ba0b-daa5410123ec\", state: \"complete\", status: \"success\", outcome: \"success\", metadata: {runtime: 187}}\n\n&lt;!-- Skipped (INFO level) --&gt;\nI, [2025-12-23T17:04:11.496881Z #20139] INFO -- cmdx: {index: 2, chain_id: \"019b4c2b-18e8-7af6-a38b-63b042c4fbed\", type: \"Task\", tags: [], class: \"ValidateCustomer\", dry_run: false, id: \"019b4c2b-18e5-7230-af7e-5b4a4bd7cda2\", state: \"interrupted\", status: \"skipped\", outcome: \"skipped\", metadata: {}, reason: \"Customer already validated\", cause: #&lt;CMDx::SkipFault: Customer already validated&gt;, rolled_back: false}\n\n&lt;!-- Failed (INFO level) --&gt;\nI, [2025-12-23T17:04:15.875306Z #20173] INFO -- cmdx: {index: 3, chain_id: \"019b4c2b-2a02-7dbc-b713-b20a7379704f\", type: \"Task\", tags: [], class: \"CalculateTax\", dry_run: false, id: \"019b4c2b-2a00-70b7-9fab-2f14db9139ef\", state: \"interrupted\", status: \"failed\", outcome: \"failed\", metadata: {error_code: \"TAX_SERVICE_UNAVAILABLE\"}, reason: \"Validation failed\", cause: #&lt;CMDx::FailFault: Validation failed&gt;, rolled_back: false}\n\n&lt;!-- Failed Chain --&gt;\nI, [2025-12-23T17:04:20.972539Z #20209] INFO -- cmdx: {index: 0, chain_id: \"019b4c2b-3de9-71f7-bcc3-2a98836bcfd7\", type: \"Workflow\", tags: [], class: \"BillingWorkflow\", dry_run: false, id: \"019b4c2b-3de6-70b9-9c16-5be13b1a463c\", state: \"interrupted\", status: \"failed\", outcome: \"interrupted\", metadata: {}, reason: \"Validation failed\", cause: #&lt;CMDx::FailFault: Validation failed&gt;, rolled_back: false, threw_failure: {index: 3, chain_id: \"019b4c2b-3de9-71f7-bcc3-2a98836bcfd7\", type: \"Task\", tags: [], class: \"CalculateTax\", id: \"019b4c2b-3dec-70b3-969b-c5b7896e3b27\", state: \"interrupted\", status: \"failed\", outcome: \"failed\", metadata: {error_code: \"TAX_SERVICE_UNAVAILABLE\"}, reason: \"Validation failed\", cause: #&lt;CMDx::FailFault: Validation failed&gt;, rolled_back: false}, caused_failure: {index: 3, chain_id: \"019b4c2b-3de9-71f7-bcc3-2a98836bcfd7\", type: \"Task\", tags: [], class: \"CalculateTax\", id: \"019b4c2b-3dec-70b3-969b-c5b7896e3b27\", state: \"interrupted\", status: \"failed\", outcome: \"failed\", metadata: {error_code: \"TAX_SERVICE_UNAVAILABLE\"}, reason: \"Validation failed\", cause: #&lt;CMDx::FailFault: Validation failed&gt;, rolled_back: false}}\n</code></pre> <p>Tip</p> <p>Use logging as a low-level event stream to track all tasks in a request. Combine with correlation for powerful distributed tracing.</p>"},{"location":"logging/#structure","title":"Structure","text":"<p>Every log entry includes rich metadata. Available fields depend on execution context and outcome.</p>"},{"location":"logging/#core-fields","title":"Core Fields","text":"Field Description Example <code>severity</code> Log level <code>INFO</code>, <code>WARN</code>, <code>ERROR</code> <code>timestamp</code> ISO 8601 execution time <code>2022-07-17T18:43:15.000000</code> <code>pid</code> Process ID <code>3784</code>"},{"location":"logging/#task-information","title":"Task Information","text":"Field Description Example <code>index</code> Execution sequence position <code>0</code>, <code>1</code>, <code>2</code> <code>chain_id</code> Unique execution chain ID <code>018c2b95-b764-7615...</code> <code>type</code> Execution unit type <code>Task</code>, <code>Workflow</code> <code>class</code> Task class name <code>GenerateInvoiceTask</code> <code>id</code> Unique task instance ID <code>018c2b95-b764-7615...</code> <code>tags</code> Custom categorization <code>[\"billing\", \"financial\"]</code>"},{"location":"logging/#execution-data","title":"Execution Data","text":"Field Description Example <code>state</code> Lifecycle state <code>complete</code>, <code>interrupted</code> <code>status</code> Business outcome <code>success</code>, <code>skipped</code>, <code>failed</code> <code>outcome</code> Final classification <code>success</code>, <code>interrupted</code> <code>metadata</code> Custom task data <code>{order_id: 123, amount: 99.99}</code>"},{"location":"logging/#failure-chain","title":"Failure Chain","text":"Field Description <code>reason</code> Reason given for the stoppage <code>caused</code> Cause exception details <code>caused_failure</code> Original failing task details <code>threw_failure</code> Task that propagated the failure"},{"location":"logging/#usage","title":"Usage","text":"<p>Access the framework logger directly within tasks:</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  def work\n    logger.debug { \"Activated feature flags: #{Features.active_flags}\" }\n    # Your logic here...\n    logger.info(\"Subscription processed\")\n  end\nend\n</code></pre>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Wrap task execution with middleware for cross-cutting concerns like authentication, caching, timeouts, and monitoring. Think Rack middleware, but for your business logic.</p> <p>See Global Configuration for framework-wide setup.</p>"},{"location":"middlewares/#execution-order","title":"Execution Order","text":"<p>Middleware wraps task execution in layers, like an onion:</p> <p>Note</p> <p>First registered = outermost wrapper. They execute in registration order.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  register :middleware, AuditMiddleware         # 1st: outermost wrapper\n  register :middleware, AuthorizationMiddleware # 2nd: middle wrapper\n  register :middleware, CacheMiddleware         # 3rd: innermost wrapper\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Execution flow:\n# 1. AuditMiddleware (before)\n# 2.   AuthorizationMiddleware (before)\n# 3.     CacheMiddleware (before)\n# 4.       [task execution]\n# 5.     CacheMiddleware (after)\n# 6.   AuthorizationMiddleware (after)\n# 7. AuditMiddleware (after)\n</code></pre>"},{"location":"middlewares/#declarations","title":"Declarations","text":""},{"location":"middlewares/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple middleware logic:</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Proc\n  register :middleware, proc do |task, options, &amp;block|\n    result = block.call\n    Analytics.track(result.status)\n    result\n  end\n\n  # Lambda\n  register :middleware, -&gt;(task, options, &amp;block) {\n    result = block.call\n    Analytics.track(result.status)\n    result\n  }\nend\n</code></pre>"},{"location":"middlewares/#class-or-module","title":"Class or Module","text":"<p>For complex middleware logic, use classes or modules:</p> <pre><code>class TelemetryMiddleware\n  def call(task, options)\n    result = yield\n    Telemetry.record(result.status)\n  ensure\n    result # Always return result\n  end\nend\n\nclass ProcessCampaign &lt; CMDx::Task\n  # Class or Module\n  register :middleware, TelemetryMiddleware\n\n  # Instance\n  register :middleware, TelemetryMiddleware.new\n\n  # With options\n  register :middleware, MonitoringMiddleware, service_key: ENV[\"MONITORING_KEY\"]\n  register :middleware, MonitoringMiddleware.new(ENV[\"MONITORING_KEY\"])\nend\n</code></pre>"},{"location":"middlewares/#removals","title":"Removals","text":"<p>Remove class or module-based middleware globally or per-task:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one middleware. Use multiple calls for batch removals.</p> <pre><code>class ProcessCampaign &lt; CMDx::Task\n  # Class or Module (no instances)\n  deregister :middleware, TelemetryMiddleware\nend\n</code></pre>"},{"location":"middlewares/#built-in","title":"Built-in","text":""},{"location":"middlewares/#timeout","title":"Timeout","text":"<p>Prevent tasks from running too long:</p> <pre><code>class ProcessReport &lt; CMDx::Task\n  # Default timeout: 3 seconds\n  register :middleware, CMDx::Middlewares::Timeout\n\n  # Seconds (takes Numeric, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, seconds: :max_processing_time\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Timeout, unless: -&gt; { self.class.name.include?(\"Quick\") }\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def max_processing_time\n    Rails.env.production? ? 2 : 10\n  end\nend\n\n# Slow task\nresult = ProcessReport.execute\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failure\"\nresult.reason   #=&gt; \"[CMDx::TimeoutError] execution exceeded 3 seconds\"\nresult.cause    #=&gt; &lt;CMDx::TimeoutError&gt;\nresult.metadata #=&gt; { limit: 3 }\n</code></pre>"},{"location":"middlewares/#correlate","title":"Correlate","text":"<p>Add correlation IDs for distributed tracing and request tracking:</p> <pre><code>class ProcessExport &lt; CMDx::Task\n  # Default correlation ID generation\n  register :middleware, CMDx::Middlewares::Correlate\n\n  # Seconds (takes Object, Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, id: proc { |task| task.context.session_id }\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Correlate, if: :correlation_enabled?\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def correlation_enabled?\n    ENV[\"CORRELATION_ENABLED\"] == \"true\"\n  end\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { correlation_id: \"550e8400-e29b-41d4-a716-446655440000\" }\n</code></pre>"},{"location":"middlewares/#runtime","title":"Runtime","text":"<p>Track task execution time in milliseconds using a monotonic clock:</p> <pre><code>class PerformanceMonitoringCheck\n  def call(task)\n    task.context.tenant.monitoring_enabled?\n  end\nend\n\nclass ProcessExport &lt; CMDx::Task\n  # Default timeout is 3 seconds\n  register :middleware, CMDx::Middlewares::Runtime\n\n  # If or Unless (takes Symbol, Proc, Lambda, Class, Module)\n  register :middleware, CMDx::Middlewares::Runtime, if: PerformanceMonitoringCheck\nend\n\nresult = ProcessExport.execute\nresult.metadata #=&gt; { runtime: 1247 } (ms)\n</code></pre>"},{"location":"retries/","title":"Retries","text":"<p>CMDx provides automatic retry functionality for tasks that encounter transient failures. This is essential for handling temporary issues like network timeouts, rate limits, or database locks without manual intervention.</p>"},{"location":"retries/#basic-usage","title":"Basic Usage","text":"<p>Configure retries upto n attempts without any delay.</p> <pre><code>class FetchExternalData &lt; CMDx::Task\n  settings retries: 3\n\n  def work\n    response = HTTParty.get(\"https://api.example.com/data\")\n    context.data = response.parsed_response\n  end\nend\n</code></pre> <p>When an exception occurs during execution, CMDx automatically retries up to the configured limit. Each retry attempt is logged at the <code>warn</code> level with retry metadata. If all retries are exhausted, the task fails with the original exception.</p>"},{"location":"retries/#selective-retries","title":"Selective Retries","text":"<p>By default, CMDx retries on <code>StandardError</code> and its subclasses. Narrow this to specific exception types:</p> <pre><code>class ProcessPayment &lt; CMDx::Task\n  settings retries: 5, retry_on: [Stripe::RateLimitError, Net::ReadTimeout]\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Important</p> <p>Only exceptions matching the <code>retry_on</code> configuration will trigger retries. Uncaught exceptions immediately fail the task.</p>"},{"location":"retries/#retry-jitter","title":"Retry Jitter","text":"<p>Add delays between retry attempts to avoid overwhelming external services or to implement exponential backoff strategies.</p>"},{"location":"retries/#fixed-value","title":"Fixed Value","text":"<p>Use a numeric value to calculate linear delay (<code>jitter * current_retry</code>):</p> <pre><code>class ImportRecords &lt; CMDx::Task\n  settings retries: 3, retry_jitter: 0.5\n\n  def work\n    # Delays: 0s, 0.5s (retry 1), 1.0s (retry 2), 1.5s (retry 3)\n    context.records = ExternalAPI.fetch_records\n  end\nend\n</code></pre>"},{"location":"retries/#symbol-references","title":"Symbol References","text":"<p>Define an instance method for custom delay logic:</p> <pre><code>class SyncInventory &lt; CMDx::Task\n  settings retries: 5, retry_jitter: :exponential_backoff\n\n  def work\n    context.inventory = InventoryAPI.sync\n  end\n\n  private\n\n  def exponential_backoff(current_retry)\n    2 ** current_retry # 2s, 4s, 8s, 16s, 32s\n  end\nend\n</code></pre>"},{"location":"retries/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Pass a proc for inline delay calculations:</p> <pre><code>class PollJobStatus &lt; CMDx::Task\n  # Proc\n  settings retries: 10, retry_jitter: proc { |retry_count| [retry_count * 0.5, 5.0].min }\n\n  # Lambda\n  settings retries: 10, retry_jitter: -&gt;(retry_count) { [retry_count * 0.5, 5.0].min }\n\n  def work\n    # Delays: 0.5s, 1.0s, 1.5s, 2.0s, 2.5s, 3.0s, 3.5s, 4.0s, 4.5s, 5.0s (capped)\n    context.status = JobAPI.check_status(context.job_id)\n  end\nend\n</code></pre>"},{"location":"retries/#class-or-module","title":"Class or Module","text":"<p>Implement reusable delay logic in dedicated modules and classes:</p> <pre><code>class ExponentialBackoff\n  def call(task, retry_count)\n    base_delay = task.context.base_delay || 1.0\n    [base_delay * (2 ** retry_count), 60.0].min\n  end\nend\n\nclass FetchUserProfile &lt; CMDx::Task\n  # Class or Module\n  settings retries: 4, retry_jitter: ExponentialBackoff\n\n  # Instance\n  settings retries: 4, retry_jitter: ExponentialBackoff.new\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/","title":"Tips and Tricks","text":"<p>Best practices, patterns, and techniques to build maintainable CMDx applications.</p>"},{"location":"tips_and_tricks/#project-organization","title":"Project Organization","text":""},{"location":"tips_and_tricks/#directory-structure","title":"Directory Structure","text":"<p>Create a well-organized command structure for maintainable applications:</p> <pre><code>/app/\n\u2514\u2500\u2500 /tasks/\n    \u251c\u2500\u2500 /invoices/\n    \u2502   \u251c\u2500\u2500 calculate_tax.rb\n    \u2502   \u251c\u2500\u2500 validate_invoice.rb\n    \u2502   \u251c\u2500\u2500 send_invoice.rb\n    \u2502   \u2514\u2500\u2500 process_invoice.rb # workflow\n    \u251c\u2500\u2500 /reports/\n    \u2502   \u251c\u2500\u2500 generate_pdf.rb\n    \u2502   \u251c\u2500\u2500 compile_data.rb\n    \u2502   \u251c\u2500\u2500 export_csv.rb\n    \u2502   \u2514\u2500\u2500 create_reports.rb # workflow\n    \u251c\u2500\u2500 application_task.rb # base class\n    \u251c\u2500\u2500 authenticate_session.rb\n    \u2514\u2500\u2500 activate_account.rb\n</code></pre>"},{"location":"tips_and_tricks/#naming-conventions","title":"Naming Conventions","text":"<p>Follow consistent naming patterns for clarity and maintainability:</p> <pre><code># Verb + Noun\nclass ExportData &lt; CMDx::Task; end\nclass CompressFile &lt; CMDx::Task; end\nclass ValidateSchema &lt; CMDx::Task; end\n\n# Use present tense verbs for actions\nclass GenerateToken &lt; CMDx::Task; end      # \u2713 Good\nclass GeneratingToken &lt; CMDx::Task; end    # \u274c Avoid\nclass TokenGeneration &lt; CMDx::Task; end    # \u274c Avoid\n</code></pre>"},{"location":"tips_and_tricks/#story-telling","title":"Story Telling","text":"<p>Break down complex logic into descriptive methods that read like a narrative:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    charge_payment_method\n    assign_to_warehouse\n    send_notification\n  end\n\n  private\n\n  def charge_payment_method\n    order.primary_payment_method.charge!\n  end\n\n  def assign_to_warehouse\n    order.ready_for_shipping!\n  end\n\n  def send_notification\n    if order.products_out_of_stock?\n      OrderMailer.pending(order).deliver\n    else\n      OrderMailer.preparing(order).deliver\n    end\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#style-guide","title":"Style Guide","text":"<p>Follow this order for consistent, readable tasks:</p> <pre><code>class ExportReport &lt; CMDx::Task\n\n  # 1. Register functions\n  register :middleware, CMDx::Middlewares::Correlate\n  register :validator, :format, FormatValidator\n\n  # 2. Define callbacks\n  before_execution :find_report\n  on_complete :track_export_metrics, if: -&gt;(task) { Current.tenant.analytics? }\n\n  # 3. Declare attributes\n  attributes :user_id\n  required :report_id\n  optional :format_type\n\n  # 4. Define work method\n  def work\n    report.compile!\n    report.export!\n\n    context.exported_at = Time.now\n  end\n\n  # TIP: Favor private business logic to reduce the surface of the public API.\n  private\n\n  # 5. Build helper functions\n  def find_report\n    @report ||= Report.find(report_id)\n  end\n\n  def track_export_metrics\n    Analytics.increment(:report_exported)\n  end\n\nend\n</code></pre>"},{"location":"tips_and_tricks/#attribute-options","title":"Attribute Options","text":"<p>Use <code>with_options</code> to reduce duplication:</p> <pre><code>class ConfigureCompany &lt; CMDx::Task\n  # Apply common options to multiple attributes\n  with_options(type: :string, presence: true) do\n    attributes :website, format: { with: URI::DEFAULT_PARSER.make_regexp(%w[http https]) }\n    required :company_name, :industry\n    optional :description, format: { with: /\\A[\\w\\s\\-\\.,!?]+\\z/ }\n  end\n\n  # Nested attributes with shared prefix\n  required :headquarters do\n    with_options(prefix: :hq_) do\n      attributes :street, :city, :zip_code, type: :string\n      required :country, type: :string, inclusion: { in: VALID_COUNTRIES }\n      optional :region, type: :string\n    end\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"tips_and_tricks/#useful-examples","title":"Useful Examples","text":"<ul> <li>Active Record Database Transaction</li> <li>Active Record Query Tagging</li> <li>Flipper Feature Flags</li> <li>Paper Trail Whatdunnit</li> <li>Redis Idempotency</li> <li>Sentry Error Tracking</li> <li>Sidekiq Async Execution</li> <li>Stoplight Circuit Breaker</li> </ul>"},{"location":"workflows/","title":"Workflows","text":"<p>Compose multiple tasks into powerful, sequential pipelines. Workflows provide a declarative way to build complex business processes with conditional execution, shared context, and flexible error handling.</p>"},{"location":"workflows/#declarations","title":"Declarations","text":"<p>Tasks run in declaration order (FIFO), sharing a common context across the pipeline.</p> <p>Warning</p> <p>Don't define a <code>work</code> method in workflows\u2014the module handles execution automatically.</p>"},{"location":"workflows/#task","title":"Task","text":"<pre><code>class OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateUserProfile\n  task SetupAccountPreferences\n\n  tasks SendWelcomeEmail, SendWelcomeSms, CreateDashboard\nend\n</code></pre> <p>Tip</p> <p>Execute tasks in parallel via the cmdx-parallel gem.</p>"},{"location":"workflows/#group","title":"Group","text":"<p>Group related tasks to share configuration:</p> <p>Important</p> <p>Settings and conditionals apply to all tasks in the group.</p> <pre><code>class ContentModerationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Screening phase\n  tasks ScanForProfanity, CheckForSpam, ValidateImages, breakpoints: [\"skipped\"]\n\n  # Review phase\n  tasks ApplyFilters, ScoreContent, FlagSuspicious\n\n  # Decision phase\n  tasks PublishContent, QueueForReview, NotifyModerators\nend\n</code></pre>"},{"location":"workflows/#conditionals","title":"Conditionals","text":"<p>Conditionals support multiple syntaxes for flexible execution control:</p> <pre><code>class ContentAccessCheck\n  def call(task)\n    task.context.user.can?(:publish_content)\n  end\nend\n\nclass OnboardingWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # If and/or Unless\n  task SendWelcomeEmail, if: :email_configured?, unless: :email_disabled?\n\n  # Proc\n  task SendWelcomeEmail, if: -&gt; { Rails.env.production? &amp;&amp; self.class.name.include?(\"Premium\") }\n\n  # Lambda\n  task SendWelcomeEmail, if: proc { context.features_enabled? }\n\n  # Class or Module\n  task SendWelcomeEmail, unless: ContentAccessCheck\n\n  # Instance\n  task SendWelcomeEmail, if: ContentAccessCheck.new\n\n  # Conditional applies to all tasks of this declaration group\n  tasks SendWelcomeEmail, CreateDashboard, SetupTutorial, if: :email_configured?\n\n  private\n\n  def email_configured?\n    context.user.email_address == true\n  end\n\n  def email_disabled?\n    context.user.communication_preference == :disabled\n  end\nend\n</code></pre>"},{"location":"workflows/#halt-behavior","title":"Halt Behavior","text":"<p>By default, skipped tasks don't stop the workflow\u2014they're treated as no-ops. Configure breakpoints globally or per-task to customize this behavior.</p> <pre><code>class AnalyticsWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CollectMetrics      # If fails \u2192 workflow stops\n  task FilterOutliers      # If skipped \u2192 workflow continues\n  task GenerateDashboard   # Only runs if no failures occurred\nend\n</code></pre>"},{"location":"workflows/#task-configuration","title":"Task Configuration","text":"<p>Configure halt behavior for the entire workflow:</p> <pre><code>class SecurityWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Halt on both failed and skipped results\n  settings(workflow_breakpoints: [\"skipped\", \"failed\"])\n\n  task PerformSecurityScan\n  task ValidateSecurityRules\nend\n\nclass OptionalTasksWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Never halt, always continue\n  settings(breakpoints: [])\n\n  task TryBackupData\n  task TryCleanupLogs\n  task TryOptimizeCache\nend\n</code></pre>"},{"location":"workflows/#group-configuration","title":"Group Configuration","text":"<p>Different task groups can have different halt behavior:</p> <pre><code>class SubscriptionWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task CreateSubscription, ValidatePayment, workflow_breakpoints: [\"skipped\", \"failed\"]\n\n  # Never halt, always continue\n  task SendConfirmationEmail, UpdateBilling, breakpoints: []\nend\n</code></pre>"},{"location":"workflows/#nested-workflows","title":"Nested Workflows","text":"<p>Build hierarchical workflows by composing workflows within workflows:</p> <pre><code>class EmailPreparationWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task ValidateRecipients\n  task CompileTemplate\nend\n\nclass EmailDeliveryWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks SendEmails, TrackDeliveries\nend\n\nclass CompleteEmailWorkflow &lt; CMDx::Task\n  include CMDx::Workflow\n\n  task EmailPreparationWorkflow\n  task EmailDeliveryWorkflow, if: proc { context.preparation_successful? }\n  task GenerateDeliveryReport\nend\n</code></pre>"},{"location":"workflows/#parallel-execution","title":"Parallel Execution","text":"<p>Run tasks concurrently using the Parallel gem. It automatically uses all available processors for maximum throughput.</p> <p>Warning</p> <p>Context is read-only during parallel execution. Load all required data beforehand.</p> <pre><code>class SendWelcomeNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  # Default options (dynamically calculated to available processors)\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel\n\n  # Fix number of threads\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_threads: 2\n\n  # Fix number of forked processes\n  tasks SendWelcomeEmail, SendWelcomeSms, SendWelcomePush, strategy: :parallel, in_processes: 2\n\n  # NOTE: Reactors are not supported\nend\n</code></pre>"},{"location":"workflows/#task-generator","title":"Task Generator","text":"<p>Generate new CMDx workflow tasks quickly using the built-in generator:</p> <pre><code>rails generate cmdx:workflow SendNotifications\n</code></pre> <p>This creates a new workflow task file with the basic structure:</p> <pre><code># app/tasks/send_notifications.rb\nclass SendNotifications &lt; CMDx::Task\n  include CMDx::Workflow\n\n  tasks Task1, Task2\nend\n</code></pre> <p>Tip</p> <p>Use present tense verbs + pluralized noun for workflow task names, eg: <code>SendNotifications</code>, <code>DownloadFiles</code>, <code>ValidateDocuments</code></p>"},{"location":"attributes/coercions/","title":"Attributes - Coercions","text":"<p>Automatically convert inputs to expected types. Coercions handle everything from simple string-to-integer conversions to JSON parsing.</p> <p>See Global Configuration for custom coercion setup.</p>"},{"location":"attributes/coercions/#usage","title":"Usage","text":"<p>Define attribute types to enable automatic coercion:</p> <pre><code>class ParseMetrics &lt; CMDx::Task\n  # Coerce into a symbol\n  attribute :measurement_type, type: :symbol\n\n  # Coerce into a rational fallback to big decimal\n  attribute :value, type: [:rational, :big_decimal]\n\n  # Coerce with options\n  attribute :recorded_at, type: :date, strptime: \"%m-%d-%Y\"\n\n  def work\n    measurement_type #=&gt; :temperature\n    recorded_at      #=&gt; &lt;Date 2024-01-23&gt;\n    value            #=&gt; 98.6 (Float)\n  end\nend\n\nParseMetrics.execute(\n  measurement_type: \"temperature\",\n  recorded_at: \"01-23-2020\",\n  value: \"98.6\"\n)\n</code></pre> <p>Tip</p> <p>Specify multiple coercion types for attributes that could be a variety of value formats. CMDx attempts each type in order until one succeeds.</p>"},{"location":"attributes/coercions/#built-in-coercions","title":"Built-in Coercions","text":"Type Options Description Examples <code>:array</code> Array conversion with JSON support <code>\"val\"</code> \u2192 <code>[\"val\"]</code><code>\"[1,2,3]\"</code> \u2192 <code>[1, 2, 3]</code> <code>:big_decimal</code> <code>:precision</code> High-precision decimal <code>\"123.456\"</code> \u2192 <code>BigDecimal(\"123.456\")</code> <code>:boolean</code> Boolean with text patterns <code>\"yes\"</code> \u2192 <code>true</code>, <code>\"no\"</code> \u2192 <code>false</code> <code>:complex</code> Complex numbers <code>\"1+2i\"</code> \u2192 <code>Complex(1, 2)</code> <code>:date</code> <code>:strptime</code> Date objects <code>\"2024-01-23\"</code> \u2192 <code>Date.new(2024, 1, 23)</code> <code>:datetime</code> <code>:strptime</code> DateTime objects <code>\"2024-01-23 10:30\"</code> \u2192 <code>DateTime.new(2024, 1, 23, 10, 30)</code> <code>:float</code> Floating-point numbers <code>\"123.45\"</code> \u2192 <code>123.45</code> <code>:hash</code> Hash conversion with JSON support <code>'{\"a\":1}'</code> \u2192 <code>{\"a\" =&gt; 1}</code> <code>:integer</code> Integer with hex/octal support <code>\"0xFF\"</code> \u2192 <code>255</code>, <code>\"077\"</code> \u2192 <code>63</code> <code>:rational</code> Rational numbers <code>\"1/2\"</code> \u2192 <code>Rational(1, 2)</code> <code>:string</code> String conversion <code>123</code> \u2192 <code>\"123\"</code> <code>:symbol</code> Symbol conversion <code>\"abc\"</code> \u2192 <code>:abc</code> <code>:time</code> <code>:strptime</code> Time objects <code>\"10:30:00\"</code> \u2192 <code>Time.new(2024, 1, 23, 10, 30)</code>"},{"location":"attributes/coercions/#declarations","title":"Declarations","text":"<p>Important</p> <p>Custom coercions must raise <code>CMDx::CoercionError</code> with a descriptive message.</p>"},{"location":"attributes/coercions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple coercion logic:</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  # Proc\n  register :callback, :geolocation, proc do |value, options = {}|\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  end\n\n  # Lambda\n  register :callback, :geolocation, -&gt;(value, options = {}) {\n    begin\n      Geolocation(value)\n    rescue StandardError\n      raise CMDx::CoercionError, \"could not convert into a geolocation\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/coercions/#class-or-module","title":"Class or Module","text":"<p>Register custom coercion logic for specialized type handling:</p> <pre><code>class GeolocationCoercion\n  def self.call(value, options = {})\n    Geolocation(value)\n  rescue StandardError\n    raise CMDx::CoercionError, \"could not convert into a geolocation\"\n  end\nend\n\nclass TransformCoordinates &lt; CMDx::Task\n  register :coercion, :geolocation, GeolocationCoercion\n\n  attribute :latitude, type: :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#removals","title":"Removals","text":"<p>Remove unwanted coercions:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one coercion. Use multiple calls for batch removals.</p> <pre><code>class TransformCoordinates &lt; CMDx::Task\n  deregister :coercion, :geolocation\nend\n</code></pre>"},{"location":"attributes/coercions/#error-handling","title":"Error Handling","text":"<p>Coercion failures provide detailed error information including attribute paths, attempted types, and specific failure reasons:</p> <pre><code>class AnalyzePerformance &lt; CMDx::Task\n  attribute  :iterations, type: :integer\n  attribute  :score, type: [:float, :big_decimal]\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = AnalyzePerformance.execute(\n  iterations: \"not-a-number\",\n  score: \"invalid-float\"\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"iterations could not coerce into an integer. score could not coerce into one of: float, big_decimal.\",\n                #       messages: {\n                #         iterations: [\"could not coerce into an integer\"],\n                #         score: [\"could not coerce into one of: float, big_decimal\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/defaults/","title":"Attributes - Defaults","text":"<p>Provide fallback values for optional attributes. Defaults kick in when values aren't provided or are <code>nil</code>.</p>"},{"location":"attributes/defaults/#declarations","title":"Declarations","text":"<p>Defaults work seamlessly with coercions, validations, and nested attributes:</p>"},{"location":"attributes/defaults/#static-values","title":"Static Values","text":"<pre><code>class OptimizeDatabase &lt; CMDx::Task\n  attribute :strategy, default: :incremental\n  attribute :level, default: \"basic\"\n  attribute :notify_admin, default: true\n  attribute :timeout_minutes, default: 30\n  attribute :indexes, default: []\n  attribute :options, default: {}\n\n  def work\n    strategy        #=&gt; :incremental\n    level           #=&gt; \"basic\"\n    notify_admin    #=&gt; true\n    timeout_minutes #=&gt; 30\n    indexes         #=&gt; []\n    options         #=&gt; {}\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic default values:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :granularity, default: :default_granularity\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def default_granularity\n    Current.user.premium? ? \"hourly\" : \"daily\"\n  end\nend\n</code></pre>"},{"location":"attributes/defaults/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic default values:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, default: proc { Current.tenant.cache_duration || 24 }\n\n  # Lambda\n  attribute :compression, default: -&gt; { Current.tenant.premium? ? \"gzip\" : \"none\" }\nend\n</code></pre>"},{"location":"attributes/defaults/#coercions-and-validations","title":"Coercions and Validations","text":"<p>Defaults follow the same coercion and validation rules as provided values:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, default: \"7\", type: :integer\n\n  # Validations\n  optional :frequency, default: \"daily\", inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/definitions/","title":"Attributes - Definitions","text":"<p>Attributes define your task's interface with automatic validation, type coercion, and accessor generation. They're the contract between callers and your business logic.</p>"},{"location":"attributes/definitions/#declarations","title":"Declarations","text":"<p>Important</p> <p>Attributes are order-dependent, so if you need to reference them as a source or use them in conditions, make sure they\u2019re defined in the correct order.</p> <p>Tip</p> <p>Prefer using the <code>required</code> and <code>optional</code> alias for <code>attributes</code> for brevity and to clearly signal intent.</p>"},{"location":"attributes/definitions/#optional","title":"Optional","text":"<p>Optional attributes return <code>nil</code> when not provided.</p> <pre><code>class ScheduleEvent &lt; CMDx::Task\n  attribute :title\n  attributes :duration, :location\n\n  # Alias for attributes (preferred)\n  optional :description\n  optional :visibility, :attendees\n\n  def work\n    title       #=&gt; \"Team Standup\"\n    duration    #=&gt; 30\n    location    #=&gt; nil\n    description #=&gt; nil\n    visibility  #=&gt; nil\n    attendees   #=&gt; [\"alice@company.com\", \"bob@company.com\"]\n  end\nend\n\n# Attributes passed as keyword arguments\nScheduleEvent.execute(\n  title: \"Team Standup\",\n  duration: 30,\n  attendees: [\"alice@company.com\", \"bob@company.com\"]\n)\n</code></pre>"},{"location":"attributes/definitions/#required","title":"Required","text":"<p>Required attributes must be provided in call arguments or task execution will fail.</p> <pre><code>class PublishArticle &lt; CMDx::Task\n  attribute :title, required: true\n  attributes :content, :author_id, required: true\n\n  # Alias for attributes =&gt; required: true (preferred)\n  required :category\n  required :status, :tags\n\n  # Conditionally required\n  required :publisher, if: :magazine?\n  attribute :approver, required: true, unless: proc { status == :published }\n\n  def work\n    title     #=&gt; \"Getting Started with Ruby\"\n    content   #=&gt; \"This is a comprehensive guide...\"\n    author_id #=&gt; 42\n    category  #=&gt; \"programming\"\n    status    #=&gt; :published\n    tags      #=&gt; [\"ruby\", \"beginner\"]\n    publisher #=&gt; \"Eastbay\"\n    approver  #=&gt; #&lt;Editor ...&gt;\n  end\n\n  private\n\n  def magazine?\n    context.title.ends_with?(\"[M]\")\n  end\nend\n</code></pre> <p>Note</p> <p>When a required attribute's condition evaluates to <code>false</code>, the attribute behaves as optional. All other attribute features such as coercions, validations, defaults, and transformations still apply normally.</p>"},{"location":"attributes/definitions/#sources","title":"Sources","text":"<p>Attributes read from any accessible object\u2014not just context. Use sources to pull data from models, services, or any callable:</p>"},{"location":"attributes/definitions/#context","title":"Context","text":"<pre><code>class BackupDatabase &lt; CMDx::Task\n  # Default source is :context\n  required :database_name\n  optional :compression_level\n\n  # Explicitly specify context source\n  attribute :backup_path, source: :context\n\n  def work\n    database_name     #=&gt; context.database_name\n    backup_path       #=&gt; context.backup_path\n    compression_level #=&gt; context.compression_level\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  attributes :host, :credentials, source: :database_config\n\n  # Access from declared attributes\n  attribute :connection_string, source: :credentials\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def database_config\n    @database_config ||= DatabaseConfig.find(context.database_name)\n  end\nend\n</code></pre>"},{"location":"attributes/definitions/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic source values:</p> <pre><code>class BackupDatabase &lt; CMDx::Task\n  # Proc\n  attribute :timestamp, source: proc { Time.current }\n\n  # Lambda\n  attribute :server, source: -&gt; { Current.server }\nend\n</code></pre>"},{"location":"attributes/definitions/#class-or-module","title":"Class or Module","text":"<p>For complex source logic, use classes or modules:</p> <pre><code>class DatabaseResolver\n  def self.call(task)\n    Database.find(task.context.database_name)\n  end\nend\n\nclass BackupDatabase &lt; CMDx::Task\n  # Class or Module\n  attribute :schema, source: DatabaseResolver\n\n  # Instance\n  attribute :metadata, source: DatabaseResolver.new\nend\n</code></pre>"},{"location":"attributes/definitions/#nesting","title":"Nesting","text":"<p>Build complex structures with nested attributes. Children inherit their parent as source and support all attribute options:</p> <p>Note</p> <p>Nested attributes support all features: naming, coercions, validations, defaults, and more.</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  # Required parent with required children\n  required :network_config do\n    required :hostname, :port, :protocol, :subnet\n    optional :load_balancer\n    attribute :firewall_rules\n  end\n\n  # Optional parent with conditional children\n  optional :ssl_config do\n    required :certificate_path, :private_key # Only required if ssl_config provided\n    optional :enable_http2, prefix: true\n  end\n\n  # Multi-level nesting\n  attribute :monitoring do\n    required :provider\n\n    optional :alerting do\n      required :threshold_percentage\n      optional :notification_channel\n    end\n  end\n\n  def work\n    network_config   #=&gt; { hostname: \"api.company.com\" ... }\n    hostname         #=&gt; \"api.company.com\"\n    load_balancer    #=&gt; nil\n  end\nend\n\nConfigureServer.execute(\n  server_id: \"srv-001\",\n  network_config: {\n    hostname: \"api.company.com\",\n    port: 443,\n    protocol: \"https\",\n    subnet: \"10.0.1.0/24\",\n    firewall_rules: \"allow_web_traffic\"\n  },\n  monitoring: {\n    provider: \"datadog\",\n    alerting: {\n      threshold_percentage: 85.0,\n      notification_channel: \"slack\"\n    }\n  }\n)\n</code></pre> <p>Important</p> <p>Child requirements only apply when the parent is provided\u2014perfect for optional structures.</p>"},{"location":"attributes/definitions/#error-handling","title":"Error Handling","text":"<p>Validation failures provide detailed, structured error messages:</p> <p>Note</p> <p>Nested attributes are only validated when their parent is present and valid.</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  required :server_id, :environment\n  required :network_config do\n    required :hostname, :port\n  end\n\n  def work\n    # Your logic here...\n  end\nend\n\n# Missing required top-level attributes\nresult = ConfigureServer.execute(server_id: \"srv-001\")\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"environment is required. network_config is required.\",\n                #       messages: {\n                #         environment: [\"is required\"],\n                #         network_config: [\"is required\"]\n                #       }\n                #     }\n                #   }\n\n# Missing required nested attributes\nresult = ConfigureServer.execute(\n  server_id: \"srv-001\",\n  environment: \"production\",\n  network_config: { hostname: \"api.company.com\" } # Missing port\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"port is required.\",\n                #       messages: {\n                #         port: [\"is required\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"attributes/naming/","title":"Attributes - Naming","text":"<p>Customize accessor method names to avoid conflicts and improve clarity. Affixing changes only the generated methods\u2014not the original attribute names.</p> <p>Note</p> <p>Use naming when attributes conflict with existing methods or need better clarity in your code.</p>"},{"location":"attributes/naming/#prefix","title":"Prefix","text":"<p>Adds a prefix to the generated accessor method name.</p> <pre><code>class GenerateReport &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :template, prefix: true\n\n  # Static\n  attribute :format, prefix: \"report_\"\n\n  def work\n    context_template #=&gt; \"monthly_sales\"\n    report_format    #=&gt; \"pdf\"\n  end\nend\n\n# Attributes passed as original attribute names\nGenerateReport.execute(template: \"monthly_sales\", format: \"pdf\")\n</code></pre>"},{"location":"attributes/naming/#suffix","title":"Suffix","text":"<p>Adds a suffix to the generated accessor method name.</p> <pre><code>class DeployApplication &lt; CMDx::Task\n  # Dynamic from attribute source\n  attribute :branch, suffix: true\n\n  # Static\n  attribute :version, suffix: \"_tag\"\n\n  def work\n    branch_context #=&gt; \"main\"\n    version_tag    #=&gt; \"v1.2.3\"\n  end\nend\n\n# Attributes passed as original attribute names\nDeployApplication.execute(branch: \"main\", version: \"v1.2.3\")\n</code></pre>"},{"location":"attributes/naming/#as","title":"As","text":"<p>Completely renames the generated accessor method.</p> <pre><code>class ScheduleMaintenance &lt; CMDx::Task\n  attribute :scheduled_at, as: :when\n\n  def work\n    when #=&gt; &lt;DateTime&gt;\n  end\nend\n\n# Attributes passed as original attribute names\nScheduleMaintenance.execute(scheduled_at: DateTime.new(2024, 12, 15, 2, 0, 0))\n</code></pre>"},{"location":"attributes/transformations/","title":"Attributes - Transformations","text":"<p>Modify attribute values after coercion but before validation. Perfect for normalization, formatting, and data cleanup.</p>"},{"location":"attributes/transformations/#declarations","title":"Declarations","text":""},{"location":"attributes/transformations/#symbol-references","title":"Symbol References","text":"<p>Reference instance methods by symbol for dynamic value transformations:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  attribute :options, transform: :compact_blank\nend\n</code></pre>"},{"location":"attributes/transformations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for dynamic value transformations:</p> <pre><code>class CacheContent &lt; CMDx::Task\n  # Proc\n  attribute :expire_hours, transform: proc { |v| v * 2 }\n\n  # Lambda\n  attribute :compression, transform: -&gt;(v) { v.to_s.upcase.strip[0..2]  }\nend\n</code></pre>"},{"location":"attributes/transformations/#class-or-module","title":"Class or Module","text":"<p>Use any object that responds to <code>call</code> for reusable transformation logic:</p> <pre><code>class EmailNormalizer\n  def call(value)\n    value.to_s.downcase.strip\n  end\nend\n\nclass ProcessContacts &lt; CMDx::Task\n  # Class or Module\n  attribute :email, transform: EmailNormalizer\n\n  # Instance\n  attribute :email, transform: EmailNormalizer.new\nend\n</code></pre>"},{"location":"attributes/transformations/#validations","title":"Validations","text":"<p>Validations run on transformed values, ensuring data consistency:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Coercions\n  attribute :retention_days, type: :integer, transform: proc { |v| v.clamp(1, 5) }\n\n  # Validations\n  optional :frequency, transform: :downcase, inclusion: { in: %w[hourly daily weekly monthly] }\nend\n</code></pre>"},{"location":"attributes/validations/","title":"Attributes - Validations","text":"<p>Ensure inputs meet requirements before execution. Validations run after coercions, giving you declarative data integrity checks.</p> <p>See Global Configuration for custom validator setup.</p>"},{"location":"attributes/validations/#usage","title":"Usage","text":"<p>Define validation rules on attributes to enforce data requirements:</p> <pre><code>class ProcessSubscription &lt; CMDx::Task\n  # Required field with presence validation\n  attribute :user_id, presence: true\n\n  # String with length constraints\n  optional :preferences, length: { minimum: 10, maximum: 500 }\n\n  # Numeric range validation\n  required :tier_level, inclusion: { in: 1..5 }\n\n  # Format validation for email\n  attribute :contact_email, format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    user_id       #=&gt; \"98765\"\n    preferences   #=&gt; \"Send weekly digest emails\"\n    tier_level    #=&gt; 3\n    contact_email #=&gt; \"user@company.com\"\n  end\nend\n\nProcessSubscription.execute(\n  user_id: \"98765\",\n  preferences: \"Send weekly digest emails\",\n  tier_level: 3,\n  contact_email: \"user@company.com\"\n)\n</code></pre> <p>Tip</p> <p>Validations run after coercions, so you can validate the final coerced values rather than raw input.</p>"},{"location":"attributes/validations/#built-in-validators","title":"Built-in Validators","text":""},{"location":"attributes/validations/#common-options","title":"Common Options","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  # Allow nil\n  attribute :tier_level, inclusion: {\n    in: 1..5,\n    allow_nil: true\n  }\n\n  # Conditionals\n  optional :contact_email, format: {\n    with: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i,\n    if: -&gt;(value) { value.includes?(\"@\") }\n  }\n  required :status, exclusion: {\n    in: %w[recalled archived],\n    unless: :product_sunsetted?\n  }\n\n  # Custom message\n  attribute :title, length: {\n    within: 5..100,\n    message: \"must be in optimal size\"\n  }\n\n  def work\n    # Your logic here...\n  end\n\n  private\n\n  def product_defunct?(value)\n    context.company.out_of_business? || value == \"deprecated\"\n  end\nend\n</code></pre> <p>This list of options is available to all validators:</p> Option Description <code>:allow_nil</code> Skip validation when value is <code>nil</code> <code>:if</code> Symbol, proc, lambda, or callable determining when to validate <code>:unless</code> Symbol, proc, lambda, or callable determining when to skip validation <code>:message</code> Custom error message for validation failures"},{"location":"attributes/validations/#exclusion","title":"Exclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :status, exclusion: { in: %w[recalled archived] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of forbidden values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value exclusions <code>:in_message</code> Custom message for range-based exclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#format","title":"Format","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :sku, format: /\\A[A-Z]{3}-[0-9]{4}\\z/\n\n  attribute :sku, format: { with: /\\A[A-Z]{3}-[0-9]{4}\\z/ }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>regexp</code> Alias for :with option <code>:with</code> Regex pattern that the value must match <code>:without</code> Regex pattern that the value must not match"},{"location":"attributes/validations/#inclusion","title":"Inclusion","text":"<pre><code>class ProcessProduct &lt; CMDx::Task\n  attribute :availability, inclusion: { in: %w[available limited] }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:in</code> The collection of allowed values or range <code>:within</code> Alias for :in option <code>:of_message</code> Custom message for discrete value inclusions <code>:in_message</code> Custom message for range-based inclusions <code>:within_message</code> Alias for :in_message option"},{"location":"attributes/validations/#length","title":"Length","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :title, length: { within: 5..100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the length must fall within (inclusive) <code>:not_within</code> Range that the length must not fall within <code>:in</code> Alias for :within <code>:not_in</code> Range that the length must not fall within <code>:min</code> Minimum allowed length <code>:max</code> Maximum allowed length <code>:is</code> Exact required length <code>:is_not</code> Length that is not allowed <code>:within_message</code> Custom message for within/range validations <code>:in_message</code> Custom message for :in validation <code>:not_within_message</code> Custom message for not_within validation <code>:not_in_message</code> Custom message for not_in validation <code>:min_message</code> Custom message for minimum length validation <code>:max_message</code> Custom message for maximum length validation <code>:is_message</code> Custom message for exact length validation <code>:is_not_message</code> Custom message for is_not validation"},{"location":"attributes/validations/#numeric","title":"Numeric","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :word_count, numeric: { min: 100 }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>:within</code> Range that the value must fall within (inclusive) <code>:not_within</code> Range that the value must not fall within <code>:in</code> Alias for :within option <code>:not_in</code> Alias for :not_within option <code>:min</code> Minimum allowed value (inclusive, &gt;=) <code>:max</code> Maximum allowed value (inclusive, &lt;=) <code>:is</code> Exact value that must match <code>:is_not</code> Value that must not match <code>:within_message</code> Custom message for range validations <code>:not_within_message</code> Custom message for exclusion validations <code>:min_message</code> Custom message for minimum validation <code>:max_message</code> Custom message for maximum validation <code>:is_message</code> Custom message for exact match validation <code>:is_not_message</code> Custom message for exclusion validation"},{"location":"attributes/validations/#presence","title":"Presence","text":"<pre><code>class CreateBlogPost &lt; CMDx::Task\n  attribute :content, presence: true\n\n  attribute :content, presence: { message: \"cannot be blank\" }\n\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> Options Description <code>true</code> Ensures value is not nil, empty string, or whitespace"},{"location":"attributes/validations/#declarations","title":"Declarations","text":"<p>Important</p> <p>Custom validators must raise <code>CMDx::ValidationError</code> with a descriptive message.</p>"},{"location":"attributes/validations/#proc-or-lambda","title":"Proc or Lambda","text":"<p>Use anonymous functions for simple validation logic:</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  # Proc\n  register :validator, :api_key, proc do |value, options = {}|\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\n\n  # Lambda\n  register :validator, :api_key, -&gt;(value, options = {}) {\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  }\nend\n</code></pre>"},{"location":"attributes/validations/#class-or-module","title":"Class or Module","text":"<p>Register custom validation logic for specialized requirements:</p> <pre><code>class ApiKeyValidator\n  def self.call(value, options = {})\n    unless value.match?(/\\A[a-zA-Z0-9]{32}\\z/)\n      raise CMDx::ValidationError, \"invalid API key format\"\n    end\n  end\nend\n\nclass SetupApplication &lt; CMDx::Task\n  register :validator, :api_key, ApiKeyValidator\n\n  attribute :access_key, api_key: true\nend\n</code></pre>"},{"location":"attributes/validations/#removals","title":"Removals","text":"<p>Remove unwanted validators:</p> <p>Warning</p> <p>Each <code>deregister</code> call removes one validator. Use multiple calls for batch removals.</p> <pre><code>class SetupApplication &lt; CMDx::Task\n  deregister :validator, :api_key\nend\n</code></pre>"},{"location":"attributes/validations/#error-handling","title":"Error Handling","text":"<p>Validation failures provide detailed, structured error messages:</p> <pre><code>class CreateProject &lt; CMDx::Task\n  attribute :project_name,\n    presence: true,\n    length: { minimum: 3, maximum: 50 }\n  optional :budget,\n    numeric: { greater_than: 1000, less_than: 1000000 }\n  required :priority,\n    inclusion: { in: [:low, :medium, :high] }\n  attribute :contact_email,\n    format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    # Your logic here...\n  end\nend\n\nresult = CreateProject.execute(\n  project_name: \"AB\",           # Too short\n  budget: 500,                  # Too low\n  priority: :urgent,            # Not in allowed list\n  contact_email: \"invalid-email\"    # Invalid format\n)\n\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.reason   #=&gt; \"Invalid\"\nresult.metadata #=&gt; {\n                #     errors: {\n                #       full_message: \"project_name is too short (minimum is 3 characters). budget must be greater than 1000. priority is not included in the list. contact_email is invalid.\",\n                #       messages: {\n                #         project_name: [\"is too short (minimum is 3 characters)\"],\n                #         budget: [\"must be greater than 1000\"],\n                #         priority: [\"is not included in the list\"],\n                #         contact_email: [\"is invalid\"]\n                #       }\n                #     }\n                #   }\n</code></pre>"},{"location":"basics/chain/","title":"Basics - Chain","text":"<p>Chains automatically track related task executions within a thread. Think of them as execution traces that help you understand what happened and in what order.</p>"},{"location":"basics/chain/#management","title":"Management","text":"<p>Each thread maintains its own isolated chain using thread-local storage.</p> <p>Warning</p> <p>Chains are thread-local. Don't share chain references across threads\u2014it causes race conditions.</p> <pre><code># Thread A\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch1.csv\")\n  result.chain.id    #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nend\n\n# Thread B (completely separate chain)\nThread.new do\n  result = ImportDataset.execute(file_path: \"/data/batch2.csv\")\n  result.chain.id    #=&gt; \"z3a42b95-c821-7892-b156-dd7c921fe2a3\"\nend\n\n# Access current thread's chain\nCMDx::Chain.current  #=&gt; Returns current chain or nil\nCMDx::Chain.clear    #=&gt; Clears current thread's chain\n</code></pre>"},{"location":"basics/chain/#links","title":"Links","text":"<p>Tasks automatically create or join the current thread's chain:</p> <p>Important</p> <p>Chain management is automatic\u2014no manual lifecycle handling needed.</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    # First task creates new chain\n    result1 = ValidateHeaders.execute(file_path: context.file_path)\n    result1.chain.id           #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\n    result1.chain.results.size #=&gt; 1\n\n    # Second task joins existing chain\n    result2 = SendNotification.execute(to: \"admin@company.com\")\n    result2.chain.id == result1.chain.id  #=&gt; true\n    result2.chain.results.size            #=&gt; 2\n\n    # Both results reference the same chain\n    result1.chain.results == result2.chain.results #=&gt; true\n  end\nend\n</code></pre>"},{"location":"basics/chain/#inheritance","title":"Inheritance","text":"<p>Subtasks automatically inherit the current thread's chain, building a unified execution trail:</p> <pre><code>class ImportDataset &lt; CMDx::Task\n  def work\n    context.dataset = Dataset.find(context.dataset_id)\n\n    # Subtasks automatically inherit current chain\n    ValidateSchema.execute\n    TransformData.execute!(context)\n    SaveToDatabase.execute(dataset_id: context.dataset_id)\n  end\nend\n\nresult = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# All tasks share the same chain\nchain.results.size #=&gt; 4 (main task + 3 subtasks)\nchain.results.map { |r| r.task.class }\n#=&gt; [ImportDataset, ValidateSchema, TransformData, SaveToDatabase]\n</code></pre>"},{"location":"basics/chain/#structure","title":"Structure","text":"<p>Chains expose comprehensive execution information:</p> <p>Important</p> <p>Chain state reflects the first (outermost) task result. Subtasks maintain their own states.</p> <pre><code>result = ImportDataset.execute(dataset_id: 456)\nchain = result.chain\n\n# Chain identification\nchain.id      #=&gt; \"018c2b95-b764-7615-a924-cc5b910ed1e5\"\nchain.results #=&gt; Array of all results in execution order\n\n# State delegation (from first/outer-most result)\nchain.state   #=&gt; \"complete\"\nchain.status  #=&gt; \"success\"\nchain.outcome #=&gt; \"success\"\n\n# Access individual results\nchain.results.each_with_index do |result, index|\n  puts \"#{index}: #{result.task.class} - #{result.status}\"\nend\n</code></pre>"},{"location":"basics/context/","title":"Basics - Context","text":"<p>Context is your data container for inputs, intermediate values, and outputs. It makes sharing data between tasks effortless.</p>"},{"location":"basics/context/#assigning-data","title":"Assigning Data","text":"<p>Context automatically captures all task inputs, normalizing keys to symbols:</p> <pre><code># Direct execution\nCalculateShipping.execute(weight: 2.5, destination: \"CA\")\n\n# Instance creation\nCalculateShipping.new(weight: 2.5, \"destination\" =&gt; \"CA\")\n</code></pre> <p>Important</p> <p>String keys convert to symbols automatically. Prefer symbols for consistency.</p>"},{"location":"basics/context/#accessing-data","title":"Accessing Data","text":"<p>Access context data using method notation, hash keys, or safe accessors:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Method style access (preferred)\n    weight = context.weight\n    destination = context.destination\n\n    # Hash style access\n    service_type = context[:service_type]\n    options = context[\"options\"]\n\n    # Safe access with defaults\n    rush_delivery = context.fetch!(:rush_delivery, false)\n    carrier = context.dig(:options, :carrier)\n\n    # Shorter alias\n    cost = ctx.weight * ctx.rate_per_pound  # ctx aliases context\n  end\nend\n</code></pre> <p>Important</p> <p>Undefined attributes return <code>nil</code> instead of raising errors\u2014perfect for optional data.</p>"},{"location":"basics/context/#modifying-context","title":"Modifying Context","text":"<p>Context supports dynamic modification during task execution:</p> <pre><code>class CalculateShipping &lt; CMDx::Task\n  def work\n    # Direct assignment\n    context.carrier = Carrier.find_by(code: context.carrier_code)\n    context.package = Package.new(weight: context.weight)\n    context.calculated_at = Time.now\n\n    # Hash-style assignment\n    context[:status] = \"calculating\"\n    context[\"tracking_number\"] = \"SHIP#{SecureRandom.hex(6)}\"\n\n    # Conditional assignment\n    context.insurance_included ||= false\n\n    # Batch updates\n    context.merge!(\n      status: \"completed\",\n      shipping_cost: calculate_cost,\n      estimated_delivery: Time.now + 3.days\n    )\n\n    # Remove sensitive data\n    context.delete!(:credit_card_token)\n\n    # Clear all data\n    context.clear!\n  end\n\n  private\n\n  def calculate_cost\n    base_rate = context.weight * context.rate_per_pound\n    base_rate + (base_rate * context.tax_percentage)\n  end\nend\n</code></pre> <p>Tip</p> <p>Use context for both input values and intermediate results. This creates natural data flow through your task execution pipeline.</p>"},{"location":"basics/context/#data-sharing","title":"Data Sharing","text":"<p>Share context across tasks for seamless data flow:</p> <pre><code># During execution\nclass CalculateShipping &lt; CMDx::Task\n  def work\n    # Validate shipping data\n    validation_result = ValidateAddress.execute(context)\n\n    # Via context\n    CalculateInsurance.execute(context)\n\n    # Via result\n    NotifyShippingCalculated.execute(validation_result)\n\n    # Context now contains accumulated data from all tasks\n    context.address_validated    #=&gt; true (from validation)\n    context.insurance_calculated #=&gt; true (from insurance)\n    context.notification_sent    #=&gt; true (from notification)\n  end\nend\n\n# After execution\nresult = CalculateShipping.execute(destination: \"New York, NY\")\n\nCreateShippingLabel.execute(result)\n</code></pre>"},{"location":"basics/execution/","title":"Basics - Execution","text":"<p>CMDx offers two execution methods with different error handling approaches. Choose based on your needs: safe result handling or exception-based control flow.</p>"},{"location":"basics/execution/#execution-methods","title":"Execution Methods","text":"<p>Both methods return results, but handle failures differently:</p> Method Returns Exceptions Use Case <code>execute</code> Always returns <code>CMDx::Result</code> Never raises Predictable result handling <code>execute!</code> Returns <code>CMDx::Result</code> on success Raises <code>CMDx::Fault</code> when skipped or failed Exception-based control flow <pre><code>flowchart LR\n    subgraph Methods\n        E[execute]\n        EB[execute!]\n    end\n\n    subgraph Returns [Returns CMDx::Result]\n        Success\n        Failed\n        Skipped\n    end\n\n    subgraph Raises [Raises CMDx::Fault]\n        FailFault\n        SkipFault\n    end\n\n    E --&gt; Success\n    E --&gt; Failed\n    E --&gt; Skipped\n\n    EB --&gt; Success\n    EB --&gt; FailFault\n    EB --&gt; SkipFault</code></pre>"},{"location":"basics/execution/#non-bang-execution","title":"Non-bang Execution","text":"<p>Always returns a <code>CMDx::Result</code>, never raises exceptions. Perfect for most use cases.</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Check execution state\nresult.success?         #=&gt; true/false\nresult.failed?          #=&gt; true/false\nresult.skipped?         #=&gt; true/false\n\n# Access result data\nresult.context.email    #=&gt; \"user@example.com\"\nresult.state            #=&gt; \"complete\"\nresult.status           #=&gt; \"success\"\n</code></pre>"},{"location":"basics/execution/#bang-execution","title":"Bang Execution","text":"<p>Raises <code>CMDx::Fault</code> exceptions on failure or skip. Returns results only on success.</p> Exception Raised When <code>CMDx::FailFault</code> Task execution fails <code>CMDx::SkipFault</code> Task execution is skipped <p>Important</p> <p>Behavior depends on <code>task_breakpoints</code> or <code>workflow_breakpoints</code> config. Default: only failures raise exceptions.</p> <pre><code>begin\n  result = CreateAccount.execute!(email: \"user@example.com\")\n  SendWelcomeEmail.execute(result.context)\nrescue CMDx::FailFault =&gt; e\n  ScheduleAccountRetryJob.perform_later(e.result.context.email)\nrescue CMDx::SkipFault =&gt; e\n  Rails.logger.info(\"Account creation skipped: #{e.result.reason}\")\nrescue Exception =&gt; e\n  ErrorTracker.capture(unhandled_exception: e)\nend\n</code></pre>"},{"location":"basics/execution/#direct-instantiation","title":"Direct Instantiation","text":"<p>Tasks can be instantiated directly for advanced use cases, testing, and custom execution patterns:</p> <pre><code># Direct instantiation\ntask = CreateAccount.new(email: \"user@example.com\", send_welcome: true)\n\n# Access properties before execution\ntask.id                      #=&gt; \"abc123...\" (unique task ID)\ntask.context.email           #=&gt; \"user@example.com\"\ntask.context.send_welcome    #=&gt; true\ntask.result.state            #=&gt; \"initialized\"\ntask.result.status           #=&gt; \"success\"\n\n# Manual execution\ntask.execute\n# or\ntask.execute!\n\ntask.result.success?         #=&gt; true/false\n</code></pre>"},{"location":"basics/execution/#result-details","title":"Result Details","text":"<p>The <code>Result</code> object provides comprehensive execution information:</p> <pre><code>result = CreateAccount.execute(email: \"user@example.com\")\n\n# Execution metadata\nresult.id           #=&gt; \"abc123...\"  (unique execution ID)\nresult.task         #=&gt; CreateAccount instance (frozen)\nresult.chain        #=&gt; Task execution chain\n\n# Context and metadata\nresult.context      #=&gt; Context with all task data\nresult.metadata     #=&gt; Hash with execution metadata\n</code></pre>"},{"location":"basics/execution/#dry-run","title":"Dry Run","text":"<p>Execute tasks in dry-run mode to simulate execution without performing side effects. Pass <code>dry_run: true</code> in the context when initializing or executing the task.</p> <p>Inside your task, use the <code>dry_run?</code> method to conditionally skip side effects.</p> <pre><code>class CloseStripeCard &lt; CMDx::Task\n  def work\n    context.stripe_result =\n      if dry_run?\n        FactoryBot.build(:stripe_closed_card)\n      else\n        StripeApi.close_card(context.card_id)\n      end\n  end\nend\n\n# Execute in dry-run mode\nresult = CloseStripeCard.execute(card_id: \"card_abc123\", dry_run: true)\nresult.success? # =&gt; true\n\n# FactoryBot object\nresult.context.stripe_result = {\n  card_id: \"card_abc123\",\n  status: \"closed\"\n}\n</code></pre>"},{"location":"basics/setup/","title":"Basics - Setup","text":"<p>Tasks are the heart of CMDx\u2014self-contained units of business logic with built-in validation, error handling, and execution tracking.</p>"},{"location":"basics/setup/#structure","title":"Structure","text":"<p>Tasks need only two things: inherit from <code>CMDx::Task</code> and define a <code>work</code> method:</p> <pre><code>class ValidateDocument &lt; CMDx::Task\n  def work\n    # Your logic here...\n  end\nend\n</code></pre> <p>Without a <code>work</code> method, execution raises <code>CMDx::UndefinedMethodError</code>.</p> <pre><code>class IncompleteTask &lt; CMDx::Task\n  # No `work` method defined\nend\n\nIncompleteTask.execute #=&gt; raises CMDx::UndefinedMethodError\n</code></pre>"},{"location":"basics/setup/#rollback","title":"Rollback","text":"<p>Undo any operations linked to the given status, helping to restore a pristine state.</p> <pre><code>class ChargeCard &lt; CMDx::Task\n  def work\n    # Your logic here, ex: charge $100\n  end\n\n  # Called automatically if a later step in the workflow fails\n  def rollback\n    # Your undo logic, ex: void $100 charge\n  end\nend\n</code></pre>"},{"location":"basics/setup/#inheritance","title":"Inheritance","text":"<p>Share configuration across tasks using inheritance:</p> <pre><code>class ApplicationTask &lt; CMDx::Task\n  register :middleware, SecurityMiddleware\n\n  before_execution :initialize_request_tracking\n\n  attribute :session_id\n\n  private\n\n  def initialize_request_tracking\n    context.tracking_id ||= SecureRandom.uuid\n  end\nend\n\nclass SyncInventory &lt; ApplicationTask\n  def work\n    # Your logic here...\n  end\nend\n</code></pre>"},{"location":"basics/setup/#lifecycle","title":"Lifecycle","text":"<p>Tasks follow a predictable execution pattern:</p> <pre><code>stateDiagram-v2\n    Initialized: Instantiation\n    Initialized --&gt; Validating: execute\n    Validating --&gt; Executing: Valid?\n    Validating --&gt; Failed: Invalid\n    Executing --&gt; Success: Work done\n    Executing --&gt; Skipped: skip!\n    Executing --&gt; Failed: fail! / Exception\n    Executed\n\n    state Executed {\n        Success\n        Skipped\n        Failed\n        Rollback\n\n        Skipped --&gt; Rollback\n        Failed --&gt; Rollback\n    }</code></pre> <p>Caution</p> <p>Tasks are single-use objects. Once executed, they're frozen and immutable.</p> Stage State Status Description Instantiation <code>initialized</code> <code>success</code> Task created with context Validation <code>executing</code> <code>success</code>/<code>failed</code> Attributes validated Execution <code>executing</code> <code>success</code>/<code>failed</code>/<code>skipped</code> <code>work</code> method runs Completion <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Result finalized Freezing <code>executed</code> <code>success</code>/<code>failed</code>/<code>skipped</code> Task becomes immutable Rollback <code>executed</code> <code>failed</code>/<code>skipped</code> Work undone"},{"location":"blog/","title":"Blog","text":"<p>Updates, tutorials, and announcements from the CMDx team.</p>"},{"location":"blog/getting-started-with-cmdx/","title":"Getting Started with CMDx: Taming Business Logic in Ruby","text":"<p>I've spent years wrestling with service objects. You know the pattern\u2014create a class, throw some business logic in a <code>call</code> method, cross your fingers, and hope for the best. The problem? Every team member writes them differently. Every project invents its own conventions. And when something breaks at 2 AM, good luck tracing what actually happened.</p> <p>That frustration led me to create CMDx.</p>"},{"location":"blog/getting-started-with-cmdx/#the-problem-with-service-objects","title":"The Problem with Service Objects","text":"<p>Let's be honest about what we're dealing with. Your typical Rails service object looks something like this:</p> <pre><code>class ProcessOrder\n  def initialize(order_id, user)\n    @order_id = order_id\n    @user = user\n  end\n\n  def call\n    order = Order.find(@order_id)\n    return false if order.processed?\n\n    order.process!\n    OrderMailer.confirmation(@user).deliver_now\n    true\n  rescue =&gt; e\n    Rails.logger.error(\"Order processing failed: #{e.message}\")\n    false\n  end\nend\n</code></pre> <p>What's wrong with this? Everything and nothing. It works, but:</p> <ul> <li>Inconsistent patterns \u2014 Does it return <code>true</code>/<code>false</code>? An object? Raises exceptions? Every service decides differently.</li> <li>Black box execution \u2014 When something fails in production, you're left grepping logs hoping someone remembered to add useful output.</li> <li>Fragile error handling \u2014 That <code>rescue =&gt; e</code> catches everything. Validation errors, network timeouts, database issues\u2014all get the same treatment.</li> </ul> <p>These aren't hypothetical problems. They're the Monday morning fire drills that eat your week.</p>"},{"location":"blog/getting-started-with-cmdx/#why-i-built-cmdx","title":"Why I Built CMDx","text":"<p>I wanted something simple enough for a junior dev to pick up in an afternoon, but powerful enough to handle complex business processes. CMDx is built around a straightforward pattern I call CERO: Compose, Execute, React, Observe.</p> <p>The idea is that every piece of business logic should:</p> <ol> <li>Be composed as a self-contained task</li> <li>Execute with consistent, predictable behavior</li> <li>Return a result you can react to</li> <li>Be observable through structured logging</li> </ol> <p>Let me show you what this looks like in practice.</p>"},{"location":"blog/getting-started-with-cmdx/#your-first-cmdx-task","title":"Your First CMDx Task","text":"<p>Here's the simplest possible task:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    order = Order.find(context.order_id)\n    order.process!\n    context.processed_at = Time.current\n  end\nend\n</code></pre> <p>That's it. Inherit from <code>CMDx::Task</code>, define a <code>work</code> method, and you're done.</p> <p>The <code>context</code> object is your data container\u2014it holds everything you pass in and everything you want to pass out. No instance variables to juggle, no wondering what data is available where.</p> <p>Let's execute it:</p> <pre><code>result = ProcessOrder.execute(order_id: 42)\n</code></pre> <p>Every execution returns a <code>Result</code> object. Always. No exceptions (pun intended\u2014we'll get to those).</p>"},{"location":"blog/getting-started-with-cmdx/#reacting-to-outcomes","title":"Reacting to Outcomes","text":"<p>Here's where CMDx starts earning its keep. The result tells you exactly what happened:</p> <pre><code>result = ProcessOrder.execute(order_id: 42)\n\nif result.success?\n  puts \"Order processed at #{result.context.processed_at}\"\nelsif result.skipped?\n  puts \"Order was skipped: #{result.reason}\"\nelsif result.failed?\n  puts \"Order failed: #{result.reason}\"\nend\n</code></pre> <p>Three possible statuses: <code>success</code>, <code>skipped</code>, or <code>failed</code>. That's it. No mystery booleans, no exceptions to catch (unless you want them), no guessing what happened.</p>"},{"location":"blog/getting-started-with-cmdx/#controlling-execution-flow","title":"Controlling Execution Flow","text":"<p>Real business logic isn't a straight line. Sometimes you need to stop early, sometimes things go wrong. CMDx gives you two explicit methods for this: <code>skip!</code> and <code>fail!</code>.</p>"},{"location":"blog/getting-started-with-cmdx/#skipping-when-theres-nothing-to-do","title":"Skipping: When There's Nothing to Do","text":"<p>Use <code>skip!</code> when the task legitimately shouldn't run. It's a no-op, not an error:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    order = Order.find(context.order_id)\n\n    if order.already_processed?\n      skip!(\"Order was already processed on #{order.processed_at}\")\n    end\n\n    order.process!\n    context.processed_at = Time.current\n  end\nend\n</code></pre> <p>Skipped tasks are considered successful outcomes\u2014the task did exactly what it should by recognizing there was nothing to do.</p>"},{"location":"blog/getting-started-with-cmdx/#failing-when-something-goes-wrong","title":"Failing: When Something Goes Wrong","text":"<p>Use <code>fail!</code> when the task cannot complete. This is an intentional, controlled failure:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    order = Order.find_by(id: context.order_id)\n\n    if order.nil?\n      fail!(\"Order not found\", code: :not_found)\n    elsif order.expired?\n      fail!(\"Order has expired\", code: :expired, expired_at: order.expired_at)\n    end\n\n    order.process!\n    context.processed_at = Time.current\n  end\nend\n</code></pre> <p>Notice the metadata I'm passing\u2014<code>code</code>, <code>expired_at</code>. This gets captured in the result:</p> <pre><code>result = ProcessOrder.execute(order_id: 999)\n\nif result.failed?\n  puts result.reason              # =&gt; \"Order not found\"\n  puts result.metadata[:code]     # =&gt; :not_found\nend\n</code></pre>"},{"location":"blog/getting-started-with-cmdx/#handling-real-exceptions","title":"Handling Real Exceptions","text":"<p>What about actual exceptions\u2014database timeouts, network failures, unexpected nil values? CMDx catches these and converts them to failures automatically:</p> <pre><code>result = ProcessOrder.execute(order_id: 42)\n\nif result.failed?\n  puts result.reason  # =&gt; \"[ActiveRecord::ConnectionError] Connection timed out\"\n  puts result.cause   # =&gt; The actual exception object\nend\n</code></pre> <p>Your code doesn't change. The result still tells you what happened, the exception is still available if you need it for debugging, but your calling code doesn't need a <code>rescue</code> block.</p>"},{"location":"blog/getting-started-with-cmdx/#observing-everything","title":"Observing Everything","text":"<p>This is my favorite part. Every CMDx execution automatically logs what happened:</p> <pre><code>I, [2025-01-07T14:32:15.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-b764-7615-a924-cc5b910ed1e5\" type=\"Task\" class=\"ProcessOrder\" state=\"complete\" status=\"success\" metadata={runtime: 47}\n</code></pre> <p>Every execution. Automatically. With timing, chain correlation, and outcome status.</p> <p>When something fails:</p> <pre><code>I, [2025-01-07T14:32:17.000000 #3784] INFO -- CMDx:\nindex=0 chain_id=\"018c2b95-c921-8834-b234-dd6c721fe3a7\" type=\"Task\" class=\"ProcessOrder\" state=\"interrupted\" status=\"failed\" metadata={code: :not_found} reason=\"Order not found\"\n</code></pre> <p>You can also log from within your task:</p> <pre><code>class ProcessOrder &lt; CMDx::Task\n  def work\n    logger.debug { \"Looking up order #{context.order_id}\" }\n\n    order = Order.find(context.order_id)\n    order.process!\n\n    logger.info \"Order #{order.id} processed successfully\"\n    context.processed_at = Time.current\n  end\nend\n</code></pre>"},{"location":"blog/getting-started-with-cmdx/#whats-next","title":"What's Next","text":"<p>This introduction covers the foundation\u2014tasks, execution, halting, and observability. But CMDx has more to offer:</p> <ul> <li>Attributes with type coercion and validation</li> <li>Callbacks for cross-cutting concerns</li> <li>Workflows for orchestrating multi-step processes</li> <li>Middlewares for wrapping execution with custom behavior</li> <li>Retries for handling transient failures</li> </ul> <p>Check out the full documentation to explore these features.</p> <p>The goal of CMDx is simple: make your business logic predictable, observable, and maintainable. No more 2 AM mysteries. No more inconsistent patterns. Just clean, focused tasks that tell you exactly what they did.</p> <p>Give it a try! I'd love to hear how it works for you.</p>"},{"location":"blog/mastering-cmdx-attributes/","title":"Mastering CMDx Attributes: Your Task's Contract with the World","text":"<p>Attributes in CMDx are deceptively simple. You define what data your task needs, and the framework handles the rest\u2014coercion, validation, defaults, the works. But there's real depth here. After building dozens of production systems with CMDx, I've found that well-designed attributes are the difference between tasks that \"just work\" and tasks that fight you at every turn.</p> <p>Let me show you what I mean.</p>"},{"location":"blog/mastering-cmdx-attributes/#starting-simple-required-vs-optional","title":"Starting Simple: Required vs Optional","text":"<p>Every task starts with a question: what data do I need? Let's build a simple user registration task:</p> <pre><code>class RegisterUser &lt; CMDx::Task\n  required :email\n  required :password\n  optional :name\n\n  def work\n    user = User.create!(\n      email: email,\n      password: password,\n      name: name\n    )\n    context.user = user\n  end\nend\n</code></pre> <p>The <code>required</code> and <code>optional</code> helpers make intent crystal clear. When you call this task:</p> <pre><code># This works\nresult = RegisterUser.execute(email: \"alice@example.com\", password: \"secret123\")\n\n# This fails immediately\nresult = RegisterUser.execute(password: \"secret123\")\nresult.failed?           # =&gt; true\nresult.metadata[:errors] # =&gt; { messages: { email: [\"is required\"] } }\n</code></pre> <p>No exceptions to catch, no mystery failures buried in a stack trace. The task tells you exactly what went wrong.</p>"},{"location":"blog/mastering-cmdx-attributes/#how-attributes-become-methods","title":"How Attributes Become Methods","text":"<p>You might have noticed something in that example: I'm calling <code>email</code> and <code>password</code> directly, not <code>context.email</code> or <code>@email</code>. That's because each attribute definition creates an instance method on your task.</p> <p>When you write:</p> <pre><code>class RegisterUser &lt; CMDx::Task\n  required :email\n  required :password\n  optional :name\nend\n</code></pre> <p>CMDx generates something equivalent to:</p> <pre><code>def email\n  attributes[:email]\nend\n\ndef password\n  attributes[:password]\nend\n\ndef name\n  attributes[:name]\nend\n</code></pre> <p>These methods return the fully processed value\u2014sourced, coerced, transformed, and validated. The <code>attributes</code> hash is where CMDx stores all your processed attribute values, separate from the raw <code>context</code>.</p> <p>This design gives you several benefits:</p> <ol> <li>Clean code \u2014 <code>email</code> reads better than <code>context.email</code> or <code>context[:email]</code></li> <li>Encapsulation \u2014 The method returns the processed value, not the raw input</li> <li>IDE support \u2014 Your editor can autocomplete and navigate to attribute definitions</li> <li>Conflict detection \u2014 CMDx raises an error if an attribute would shadow an existing method</li> </ol> <p>That last point is important. If you try this:</p> <pre><code>class BadTask &lt; CMDx::Task\n  required :context  # Conflicts with CMDx::Task#context\nend\n</code></pre> <p>You'll get a clear error:</p> <pre><code>The method :context is already defined on the BadTask task.\nThis may be due to conflicts with one of the task's user defined or internal methods/attributes.\n\nUse :as, :prefix, and/or :suffix attribute options to avoid conflicts with existing methods.\n</code></pre> <p>We'll cover those naming options later, but the key insight is: attributes aren't just data declarations\u2014they're method definitions.</p>"},{"location":"blog/mastering-cmdx-attributes/#type-coercion-let-the-framework-do-the-heavy-lifting","title":"Type Coercion: Let the Framework Do the Heavy Lifting","text":"<p>Here's where things get interesting. Real-world data is messy. Form submissions send everything as strings. JSON payloads might have numbers where you expect integers. CMDx handles this automatically:</p> <pre><code>class ProcessPayment &lt; CMDx::Task\n  required :amount, type: :big_decimal\n  required :currency, type: :symbol\n  optional :metadata, type: :hash\n  optional :processed_at, type: :datetime\n\n  def work\n    amount       # =&gt; BigDecimal(\"99.99\") (was \"99.99\")\n    currency     # =&gt; :usd (was \"usd\")\n    metadata     # =&gt; {\"source\" =&gt; \"web\"} (was '{\"source\":\"web\"}')\n    processed_at # =&gt; DateTime object (was \"2025-01-07T10:30:00Z\")\n  end\nend\n\nProcessPayment.execute(\n  amount: \"99.99\",\n  currency: \"usd\",\n  metadata: '{\"source\":\"web\"}',\n  processed_at: \"2025-01-07T10:30:00Z\"\n)\n</code></pre> <p>The built-in coercions cover most cases:</p> Type What it does <code>:integer</code> Handles strings, hex (<code>0xFF</code>), octal (<code>077</code>) <code>:float</code> Parses numeric strings <code>:big_decimal</code> High-precision decimals <code>:boolean</code> Understands \"yes\"/\"no\", \"true\"/\"false\", 1/0 <code>:symbol</code> Converts strings to symbols <code>:array</code> Wraps single values, parses JSON arrays <code>:hash</code> Parses JSON objects <code>:date</code> / <code>:datetime</code> / <code>:time</code> Flexible date parsing <p>When data can come in multiple formats, specify fallbacks:</p> <pre><code>class ImportRecord &lt; CMDx::Task\n  # Try rational first, fall back to big_decimal\n  required :value, type: [:rational, :big_decimal]\nend\n</code></pre> <p>CMDx attempts each type in order until one succeeds.</p>"},{"location":"blog/mastering-cmdx-attributes/#validation-declarative-data-integrity","title":"Validation: Declarative Data Integrity","text":"<p>Coercion gets your data into the right shape. Validation ensures it makes sense:</p> <pre><code>class CreateProject &lt; CMDx::Task\n  required :name,\n    presence: true,\n    length: { minimum: 3, maximum: 100 }\n\n  required :budget,\n    type: :big_decimal,\n    numeric: { min: 1000, max: 1_000_000 }\n\n  required :priority,\n    type: :symbol,\n    inclusion: { in: [:low, :medium, :high, :critical] }\n\n  optional :contact_email,\n    format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    Project.create!(\n      name: name,\n      budget: budget,\n      priority: priority,\n      contact_email: contact_email\n    )\n  end\nend\n</code></pre> <p>Validation happens after coercion, so you're validating the final value, not the raw input. This is exactly what you want\u2014validate <code>BigDecimal(\"1000\")</code>, not the string <code>\"1000\"</code>.</p> <p>The error messages are structured and actionable:</p> <pre><code>result = CreateProject.execute(\n  name: \"AB\",\n  budget: \"500\",\n  priority: \"urgent\",\n  contact_email: \"not-an-email\"\n)\n\nresult.metadata[:errors]\n# =&gt; {\n#      full_message: \"name is too short (minimum is 3 characters). budget must be at least 1000. priority is not included in the list. contact_email is invalid.\",\n#      messages: {\n#        name: [\"is too short (minimum is 3 characters)\"],\n#        budget: [\"must be at least 1000\"],\n#        priority: [\"is not included in the list\"],\n#        contact_email: [\"is invalid\"]\n#      }\n#    }\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#defaults-smart-fallbacks","title":"Defaults: Smart Fallbacks","text":"<p>Sometimes attributes should have sensible defaults. Static values work great:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  required :database_name\n  optional :retention_days, default: 7\n  optional :compression, default: \"gzip\"\n  optional :notify, default: true\n\n  def work\n    retention_days # =&gt; 7 (when not provided)\n    compression    # =&gt; \"gzip\"\n    notify         # =&gt; true\n  end\nend\n</code></pre> <p>But often defaults need context. Use procs for dynamic defaults:</p> <pre><code>class GenerateReport &lt; CMDx::Task\n  required :user_id\n  optional :timezone, default: -&gt; { Current.user&amp;.timezone || \"UTC\" }\n  optional :format, default: proc { context.user_id.to_s.start_with?(\"admin\") ? \"detailed\" : \"summary\" }\n\n  def work\n    # timezone and format resolved at execution time\n  end\nend\n</code></pre> <p>Or reference a method for complex logic:</p> <pre><code>class ProcessAnalytics &lt; CMDx::Task\n  required :account_id\n  optional :granularity, default: :default_granularity\n\n  def work\n    granularity # =&gt; \"hourly\" for premium, \"daily\" for free\n  end\n\n  private\n\n  def default_granularity\n    account.premium? ? \"hourly\" : \"daily\"\n  end\n\n  def account\n    @account ||= Account.find(context.account_id)\n  end\nend\n</code></pre> <p>Defaults are coerced and validated like any other value:</p> <pre><code>class ScheduleBackup &lt; CMDx::Task\n  # Default \"7\" gets coerced to integer, then validated\n  optional :retention_days,\n    default: \"7\",\n    type: :integer,\n    numeric: { min: 1, max: 30 }\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#transformations-clean-data-before-validation","title":"Transformations: Clean Data Before Validation","text":"<p>Sometimes you need to normalize data before validating it. Transformations run after coercion but before validation:</p> <pre><code>class ProcessContact &lt; CMDx::Task\n  required :email,\n    transform: -&gt;(v) { v.to_s.downcase.strip },\n    format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  required :phone,\n    transform: -&gt;(v) { v.gsub(/\\D/, \"\") },  # Strip non-digits\n    length: { is: 10 }\n\n  optional :preferences,\n    type: :hash,\n    transform: :compact_blank  # Remove empty values\n\n  def work\n    email       # =&gt; \"alice@example.com\" (was \"  ALICE@Example.COM  \")\n    phone       # =&gt; \"5551234567\" (was \"(555) 123-4567\")\n    preferences # =&gt; { theme: \"dark\" } (was { theme: \"dark\", other: \"\" })\n  end\nend\n</code></pre> <p>For reusable transformations, use a class:</p> <pre><code>class EmailNormalizer\n  def self.call(value)\n    value.to_s.downcase.strip.gsub(/\\s+/, \"\")\n  end\nend\n\nclass ProcessContact &lt; CMDx::Task\n  required :email, transform: EmailNormalizer\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#sources-reading-from-anywhere","title":"Sources: Reading from Anywhere","text":"<p>By default, attributes read from the context. But sometimes your data lives elsewhere:</p> <pre><code>class UpdateUserProfile &lt; CMDx::Task\n  required :user_id\n\n  # Read from a method that returns an object\n  required :current_plan, source: :user\n  required :email, source: :user\n\n  # Read from a lambda\n  optional :feature_flags, source: -&gt; { Current.feature_flags }\n\n  # Read from a class\n  optional :server_config, source: ConfigResolver\n\n  def work\n    current_plan  # =&gt; user.current_plan\n    email         # =&gt; user.email\n    feature_flags # =&gt; Current.feature_flags[:user_id]\n  end\n\n  private\n\n  def user\n    @user ||= User.find(context.user_id)\n  end\nend\n</code></pre> <p>This is powerful for building tasks that aggregate data from multiple sources without cluttering your context.</p>"},{"location":"blog/mastering-cmdx-attributes/#nested-attributes-handling-complex-structures","title":"Nested Attributes: Handling Complex Structures","text":"<p>Real APIs send nested data. CMDx handles this elegantly:</p> <pre><code>class ConfigureServer &lt; CMDx::Task\n  required :server_id\n\n  required :network do\n    required :hostname, format: /\\A[a-z0-9\\-\\.]+\\z/i\n    required :port, type: :integer, numeric: { min: 1, max: 65535 }\n    optional :protocol, default: \"https\", inclusion: { in: %w[http https] }\n  end\n\n  optional :ssl do\n    required :certificate_path, presence: true\n    required :private_key_path, presence: true\n    optional :passphrase\n  end\n\n  optional :monitoring do\n    required :provider, inclusion: { in: %w[datadog newrelic prometheus] }\n\n    optional :alerting do\n      required :threshold, type: :integer, numeric: { min: 1, max: 100 }\n      optional :channel, default: \"slack\"\n    end\n  end\n\n  def work\n    # Access nested values directly\n    hostname  # =&gt; \"api.example.com\"\n    port      # =&gt; 443\n    protocol  # =&gt; \"https\"\n    threshold # =&gt; 85 (from monitoring.alerting.threshold)\n    channel   # =&gt; \"slack\"\n\n    # Or access the whole structure\n    network   # =&gt; { hostname: \"api.example.com\", port: 443, protocol: \"https\" }\n  end\nend\n</code></pre> <p>The key insight: child requirements only apply when the parent is provided. If <code>ssl</code> isn't passed, <code>certificate_path</code> and <code>private_key_path</code> aren't required. But if you pass <code>ssl: {}</code>, they become required.</p> <pre><code># Valid - ssl is optional, so no ssl config needed\nConfigureServer.execute(\n  server_id: \"srv-001\",\n  network: { hostname: \"api.example.com\", port: 443 }\n)\n\n# Invalid - ssl provided but missing required children\nConfigureServer.execute(\n  server_id: \"srv-001\",\n  network: { hostname: \"api.example.com\", port: 443 },\n  ssl: {}  # Missing certificate_path and private_key_path!\n)\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#naming-avoiding-conflicts","title":"Naming: Avoiding Conflicts","text":"<p>Sometimes attribute names conflict with existing methods. Use naming options to work around this:</p> <pre><code>class ProcessData &lt; CMDx::Task\n  # Conflicts with Object#class\n  required :class, as: :category\n\n  # Add context for clarity\n  required :template, prefix: true  # =&gt; context_template\n  required :version, suffix: \"_tag\" # =&gt; version_tag\n\n  def work\n    category         # =&gt; \"premium\"\n    context_template # =&gt; \"monthly_report\"\n    version_tag      # =&gt; \"v2.1.0\"\n  end\nend\n\n# Still pass original names\nProcessData.execute(class: \"premium\", template: \"monthly_report\", version: \"v2.1.0\")\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#conditional-requirements","title":"Conditional Requirements","text":"<p>Sometimes an attribute is only required under certain conditions:</p> <pre><code>class PublishContent &lt; CMDx::Task\n  required :title\n  required :content\n  required :status, inclusion: { in: %w[draft published scheduled] }\n\n  # Only required when scheduled\n  required :publish_at, type: :datetime, if: :scheduled?\n\n  # Only required for published content\n  required :author_id, unless: proc { status == \"draft\" }\n\n  def work\n    # ...\n  end\n\n  private\n\n  def scheduled?\n    context.status == \"scheduled\"\n  end\nend\n</code></pre> <p>When the condition is false, the attribute becomes optional. All other features\u2014coercion, validation, defaults\u2014still apply.</p>"},{"location":"blog/mastering-cmdx-attributes/#custom-coercions-and-validators","title":"Custom Coercions and Validators","text":"<p>For domain-specific types, register your own coercions:</p> <pre><code>class GeoCoercion\n  def self.call(value, options = {})\n    case value\n    when Array then Geo::Point.new(*value)\n    when String then Geo::Point.parse(value)\n    when Geo::Point then value\n    else raise CMDx::CoercionError, \"cannot convert to geographic point\"\n    end\n  end\nend\n\nclass DeliverPackage &lt; CMDx::Task\n  register :coercion, :geo_point, GeoCoercion\n\n  required :origin, type: :geo_point\n  required :destination, type: :geo_point\n\n  def work\n    origin      # =&gt; Geo::Point instance\n    destination # =&gt; Geo::Point instance\n  end\nend\n</code></pre> <p>Same pattern for validators:</p> <pre><code>class UUIDValidator\n  UUID_PATTERN = /\\A[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\z/i\n\n  def self.call(value, options = {})\n    return if value.nil? &amp;&amp; options[:allow_nil]\n    raise CMDx::ValidationError, \"is not a valid UUID\" unless value.to_s.match?(UUID_PATTERN)\n  end\nend\n\nclass ProcessEntity &lt; CMDx::Task\n  register :validator, :uuid, UUIDValidator\n\n  required :entity_id, uuid: true\n\n  def work\n    entity_id # Guaranteed to be a valid UUID format\n  end\nend\n</code></pre>"},{"location":"blog/mastering-cmdx-attributes/#putting-it-all-together","title":"Putting It All Together","text":"<p>Here's a real-world example combining everything\u2014a task that processes subscription upgrades:</p> <pre><code>class UpgradeSubscription &lt; CMDx::Task\n  # Core identifiers\n  required :user_id, uuid: true\n  required :subscription_id, uuid: true\n\n  # Plan details with validation\n  required :new_plan,\n    type: :symbol,\n    inclusion: { in: [:starter, :professional, :enterprise] }\n\n  # Payment info (conditionally required)\n  required :payment_method_id, uuid: true, unless: :enterprise_invoicing?\n\n  optional :billing do\n    required :address_line1, presence: true\n    optional :address_line2\n    required :city, presence: true\n    required :postal_code, format: /\\A\\d{5}(-\\d{4})?\\z/\n    required :country, inclusion: { in: ISO3166::Country.codes }\n  end\n\n  # Proration settings\n  optional :prorate, default: true, type: :boolean\n  optional :proration_date,\n    type: :datetime,\n    default: -&gt; { Time.current }\n\n  # Contact preferences\n  optional :notification_email,\n    transform: -&gt;(v) { v.to_s.downcase.strip },\n    format: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n  def work\n    subscription = Subscription.find(subscription_id)\n\n    subscription.upgrade!(\n      plan: new_plan,\n      payment_method_id: payment_method_id,\n      prorate: prorate,\n      proration_date: proration_date,\n      billing_address: billing\n    )\n\n    if notification_email\n      SubscriptionMailer.upgrade_confirmation(notification_email, subscription).deliver_later\n    end\n\n    context.subscription = subscription\n  end\n\n  private\n\n  def enterprise_invoicing?\n    context.new_plan == :enterprise\n  end\nend\n</code></pre> <p>Every attribute has a clear purpose. Types are explicit. Validations are declarative. The task's interface is self-documenting.</p>"},{"location":"blog/mastering-cmdx-attributes/#the-payoff","title":"The Payoff","text":"<p>Well-designed attributes give you:</p> <ol> <li>Self-documenting interfaces \u2014 One glance tells you what data the task needs</li> <li>Fail-fast behavior \u2014 Invalid data never reaches your business logic</li> <li>Consistent error handling \u2014 Structured errors, every time</li> <li>Less defensive coding \u2014 Trust your attributes, focus on business logic</li> </ol> <p>The time you invest in thoughtful attribute design pays dividends in debugging time saved and confidence gained. Your future self (and your teammates) will thank you.</p> <p>Next time you're building a task, start with the attributes. Ask yourself: What data do I need? What shape should it be in? What makes it valid? Answer those questions with attributes, and the rest follows naturally.</p>"},{"location":"interruptions/exceptions/","title":"Interruptions - Exceptions","text":"<p>Exception handling differs between <code>execute</code> and <code>execute!</code>. Choose the method that matches your error handling strategy.</p>"},{"location":"interruptions/exceptions/#exception-handling","title":"Exception Handling","text":"<p>Important</p> <p>Prefer <code>skip!</code> and <code>fail!</code> over raising exceptions\u2014they signal intent more clearly.</p>"},{"location":"interruptions/exceptions/#non-bang-execution","title":"Non-bang execution","text":"<p>Captures all exceptions and returns them as failed results:</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nresult = CompressDocument.execute(document_id: \"unknown-doc-id\")\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\nresult.failed?  #=&gt; true\nresult.reason   #=&gt; \"[ActiveRecord::NotFoundError] record not found\"\nresult.cause    #=&gt; &lt;ActiveRecord::NotFoundError&gt;\n</code></pre> <p>Note</p> <p>Use <code>exception_handler</code> with <code>execute</code> to send exceptions to APM tools before they become failed results.</p>"},{"location":"interruptions/exceptions/#bang-execution","title":"Bang execution","text":"<p>Lets exceptions propagate naturally for standard Ruby error handling:</p> <pre><code>class CompressDocument &lt; CMDx::Task\n  def work\n    document = Document.find(context.document_id)\n    document.compress!\n  end\nend\n\nbegin\n  CompressDocument.execute!(document_id: \"unknown-doc-id\")\nrescue ActiveRecord::NotFoundError =&gt; e\n  puts \"Handle exception: #{e.message}\"\nend\n</code></pre>"},{"location":"interruptions/faults/","title":"Interruptions - Faults","text":"<p>Faults are exceptions raised by <code>execute!</code> when tasks halt. They carry rich context about execution state, enabling sophisticated error handling patterns.</p>"},{"location":"interruptions/faults/#fault-types","title":"Fault Types","text":"Type Triggered By Use Case <code>CMDx::Fault</code> Base class Catch-all for any interruption <code>CMDx::SkipFault</code> <code>skip!</code> method Optional processing, early returns <code>CMDx::FailFault</code> <code>fail!</code> method Validation errors, processing failures <p>Important</p> <p>All faults inherit from <code>CMDx::Fault</code> and expose result, task, context, and chain data.</p>"},{"location":"interruptions/faults/#fault-handling","title":"Fault Handling","text":"<pre><code>begin\n  ProcessTicket.execute!(ticket_id: 456)\nrescue CMDx::SkipFault =&gt; e\n  logger.info \"Ticket processing skipped: #{e.message}\"\n  schedule_retry(e.context.ticket_id)\nrescue CMDx::FailFault =&gt; e\n  logger.error \"Ticket processing failed: #{e.message}\"\n  notify_admin(e.context.assigned_agent, e.result.metadata[:error_code])\nrescue CMDx::Fault =&gt; e\n  logger.warn \"Ticket processing interrupted: #{e.message}\"\n  rollback_changes\nend\n</code></pre>"},{"location":"interruptions/faults/#data-access","title":"Data Access","text":"<p>Access rich execution data from fault exceptions:</p> <pre><code>begin\n  LicenseActivation.execute!(license_key: key, machine_id: machine)\nrescue CMDx::Fault =&gt; e\n  # Result information\n  e.result.state     #=&gt; \"interrupted\"\n  e.result.status    #=&gt; \"failed\" or \"skipped\"\n  e.result.reason    #=&gt; \"License key already activated\"\n\n  # Task information\n  e.task.class       #=&gt; &lt;LicenseActivation&gt;\n  e.task.id          #=&gt; \"abc123...\"\n\n  # Context data\n  e.context.license_key #=&gt; \"ABC-123-DEF\"\n  e.context.machine_id  #=&gt; \"[FILTERED]\"\n\n  # Chain information\n  e.chain.id         #=&gt; \"def456...\"\n  e.chain.size       #=&gt; 3\nend\n</code></pre>"},{"location":"interruptions/faults/#advanced-matching","title":"Advanced Matching","text":""},{"location":"interruptions/faults/#task-specific-matching","title":"Task-Specific Matching","text":"<p>Handle faults only from specific tasks using <code>for?</code>:</p> <pre><code>begin\n  DocumentWorkflow.execute!(document_data: data)\nrescue CMDx::FailFault.for?(FormatValidator, ContentProcessor) =&gt; e\n  # Handle only document-related failures\n  retry_with_alternate_parser(e.context)\nrescue CMDx::SkipFault.for?(VirusScanner, ContentFilter) =&gt; e\n  # Handle security-related skips\n  quarantine_for_review(e.context.document_id)\nend\n</code></pre>"},{"location":"interruptions/faults/#custom-logic-matching","title":"Custom Logic Matching","text":"<pre><code>begin\n  ReportGenerator.execute!(report: report_data)\nrescue CMDx::Fault.matches? { |f| f.context.data_size &gt; 10_000 } =&gt; e\n  escalate_large_dataset_failure(e)\nrescue CMDx::FailFault.matches? { |f| f.result.metadata[:attempt_count] &gt; 3 } =&gt; e\n  abandon_report_generation(e)\nrescue CMDx::Fault.matches? { |f| f.result.metadata[:error_type] == \"memory\" } =&gt; e\n  increase_memory_and_retry(e)\nend\n</code></pre>"},{"location":"interruptions/faults/#fault-propagation","title":"Fault Propagation","text":"<p>Propagate failures with <code>throw!</code> to preserve context and maintain the error chain:</p>"},{"location":"interruptions/faults/#basic-propagation","title":"Basic Propagation","text":"<pre><code>class ReportGenerator &lt; CMDx::Task\n  def work\n    # Throw if skipped or failed\n    validation_result = DataValidator.execute(context)\n    throw!(validation_result)\n\n    # Only throw if skipped\n    check_permissions = CheckPermissions.execute(context)\n    throw!(check_permissions) if check_permissions.skipped?\n\n    # Only throw if failed\n    data_result = DataProcessor.execute(context)\n    throw!(data_result) if data_result.failed?\n\n    # Continue processing\n    generate_report\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#additional-metadata","title":"Additional Metadata","text":"<pre><code>class BatchProcessor &lt; CMDx::Task\n  def work\n    step_result = FileValidation.execute(context)\n\n    if step_result.failed?\n      throw!(step_result, {\n        batch_stage: \"validation\",\n        can_retry: true,\n        next_step: \"file_repair\"\n      })\n    end\n\n    continue_batch\n  end\nend\n</code></pre>"},{"location":"interruptions/faults/#chain-analysis","title":"Chain Analysis","text":"<p>Trace fault origins and propagation through the execution chain:</p> <pre><code>result = DocumentWorkflow.execute(invalid_data)\n\nif result.failed?\n  # Trace the original failure\n  original = result.caused_failure\n  if original\n    puts \"Original failure: #{original.task.class.name}\"\n    puts \"Reason: #{original.reason}\"\n  end\n\n  # Find what propagated the failure\n  thrower = result.threw_failure\n  puts \"Propagated by: #{thrower.task.class.name}\" if thrower\n\n  # Analyze failure type\n  case\n  when result.caused_failure?\n    puts \"This task was the original source\"\n  when result.threw_failure?\n    puts \"This task propagated a failure\"\n  when result.thrown_failure?\n    puts \"This task failed due to propagation\"\n  end\nend\n</code></pre>"},{"location":"interruptions/halt/","title":"Interruptions - Halt","text":"<p>Stop task execution intentionally using <code>skip!</code> or <code>fail!</code>. Both methods signal clear intent about why execution stopped.</p>"},{"location":"interruptions/halt/#skipping","title":"Skipping","text":"<p>Use <code>skip!</code> when the task doesn't need to run. It's a no-op, not an error.</p> <p>Important</p> <p>Skipped tasks are considered \"good\" outcomes\u2014they succeeded by doing nothing.</p> <pre><code>class ProcessInventory &lt; CMDx::Task\n  def work\n    # Without a reason\n    skip! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    # With a reason\n    skip!(\"Warehouse closed\") unless Time.now.hour.between?(8, 18)\n\n    inventory = Inventory.find(context.inventory_id)\n\n    if inventory.already_counted?\n      skip!(\"Inventory already counted today\")\n    else\n      inventory.count!\n    end\n  end\nend\n\nresult = ProcessInventory.execute(inventory_id: 456)\n\n# Executed\nresult.status #=&gt; \"skipped\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Warehouse closed\"\n</code></pre>"},{"location":"interruptions/halt/#failing","title":"Failing","text":"<p>Use <code>fail!</code> when the task can't complete successfully. It signals controlled, intentional failure:</p> <pre><code>class ProcessRefund &lt; CMDx::Task\n  def work\n    # Without a reason\n    fail! if Array(ENV[\"DISABLED_TASKS\"]).include?(self.class.name)\n\n    refund = Refund.find(context.refund_id)\n\n    # With a reason\n    if refund.expired?\n      fail!(\"Refund period has expired\")\n    elsif !refund.amount.positive?\n      fail!(\"Refund amount must be positive\")\n    else\n      refund.process!\n    end\n  end\nend\n\nresult = ProcessRefund.execute(refund_id: 789)\n\n# Executed\nresult.status #=&gt; \"failed\"\n\n# Without a reason\nresult.reason #=&gt; \"Unspecified\"\n\n# With a reason\nresult.reason #=&gt; \"Refund period has expired\"\n</code></pre>"},{"location":"interruptions/halt/#metadata-enrichment","title":"Metadata Enrichment","text":"<p>Enrich halt calls with metadata for better debugging and error handling:</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    license = License.find(context.license_id)\n\n    if license.already_renewed?\n      # Without metadata\n      skip!(\"License already renewed\")\n    end\n\n    unless license.renewal_eligible?\n      # With metadata\n      fail!(\n        \"License not eligible for renewal\",\n        error_code: \"LICENSE.NOT_ELIGIBLE\",\n        retry_after: Time.current + 30.days\n      )\n    end\n\n    process_renewal\n  end\nend\n\nresult = ProcessRenewal.execute(license_id: 567)\n\n# Without metadata\nresult.metadata #=&gt; {}\n\n# With metadata\nresult.metadata #=&gt; {\n                #     error_code: \"LICENSE.NOT_ELIGIBLE\",\n                #     retry_after: &lt;Time 30 days from now&gt;\n                #   }\n</code></pre>"},{"location":"interruptions/halt/#state-transitions","title":"State Transitions","text":"<p>Halt methods trigger specific state and status transitions:</p> Method State Status Outcome <code>skip!</code> <code>interrupted</code> <code>skipped</code> <code>good? = true</code>, <code>bad? = true</code> <code>fail!</code> <code>interrupted</code> <code>failed</code> <code>good? = false</code>, <code>bad? = true</code> <pre><code>result = ProcessRenewal.execute(license_id: 567)\n\n# State information\nresult.state        #=&gt; \"interrupted\"\nresult.status       #=&gt; \"skipped\" or \"failed\"\nresult.interrupted? #=&gt; true\nresult.complete?    #=&gt; false\n\n# Outcome categorization\nresult.good?        #=&gt; true for skipped, false for failed\nresult.bad?         #=&gt; true for both skipped and failed\n</code></pre>"},{"location":"interruptions/halt/#execution-behavior","title":"Execution Behavior","text":"<p>Halt methods behave differently depending on the call method used:</p>"},{"location":"interruptions/halt/#non-bang-execution","title":"Non-bang execution","text":"<p>Returns result object without raising exceptions:</p> <pre><code>result = ProcessRefund.execute(refund_id: 789)\n\ncase result.status\nwhen \"success\"\n  puts \"Refund processed: $#{result.context.refund.amount}\"\nwhen \"skipped\"\n  puts \"Refund skipped: #{result.reason}\"\nwhen \"failed\"\n  puts \"Refund failed: #{result.reason}\"\n  handle_refund_error(result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#bang-execution","title":"Bang execution","text":"<p>Raises exceptions for halt conditions based on <code>task_breakpoints</code> configuration:</p> <pre><code>begin\n  result = ProcessRefund.execute!(refund_id: 789)\n  puts \"Success: Refund processed\"\nrescue CMDx::SkipFault =&gt; e\n  puts \"Skipped: #{e.message}\"\nrescue CMDx::FailFault =&gt; e\n  puts \"Failed: #{e.message}\"\n  handle_refund_failure(e.result.metadata[:error_code])\nend\n</code></pre>"},{"location":"interruptions/halt/#best-practices","title":"Best Practices","text":"<p>Always provide a reason for better debugging and clearer exception messages:</p> <pre><code># Good: Clear, specific reason\nskip!(\"Document processing paused for compliance review\")\nfail!(\"File format not supported by processor\", code: \"FORMAT_UNSUPPORTED\")\n\n# Acceptable: Generic, non-specific reason\nskip!(\"Paused\")\nfail!(\"Unsupported\")\n\n# Bad: Default, cannot determine reason\nskip! #=&gt; \"Unspecified\"\nfail! #=&gt; \"Unspecified\"\n</code></pre>"},{"location":"interruptions/halt/#manual-errors","title":"Manual Errors","text":"<p>For rare cases, manually add errors before halting:</p> <p>Important</p> <p>Manual errors don't stop execution\u2014you still need to call <code>fail!</code> or <code>skip!</code>.</p> <pre><code>class ProcessRenewal &lt; CMDx::Task\n  def work\n    if document.nonrenewable?\n      errors.add(:document, \"not renewable\")\n      fail!(\"document could not be renewed\")\n    else\n      document.renew!\n    end\n  end\nend\n</code></pre>"},{"location":"outcomes/result/","title":"Outcomes - Result","text":"<p>Results are your window into task execution. They expose everything: outcome, state, timing, context, and metadata.</p>"},{"location":"outcomes/result/#result-attributes","title":"Result Attributes","text":"<p>Access essential execution information:</p> <p>Important</p> <p>Results are immutable after execution completes.</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Object data\nresult.task     #=&gt; &lt;BuildApplication&gt;\nresult.context  #=&gt; &lt;CMDx::Context&gt;\nresult.chain    #=&gt; &lt;CMDx::Chain&gt;\n\n# Execution data\nresult.state    #=&gt; \"interrupted\"\nresult.status   #=&gt; \"failed\"\n\n# Fault data\nresult.reason   #=&gt; \"Build tool not found\"\nresult.cause    #=&gt; &lt;CMDx::FailFault&gt;\nresult.metadata #=&gt; { error_code: \"BUILD_TOOL.NOT_FOUND\" }\n</code></pre>"},{"location":"outcomes/result/#lifecycle-information","title":"Lifecycle Information","text":"<p>Check execution state, status, and rollback with predicate methods:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# State predicates (execution lifecycle)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\nresult.executed?    #=&gt; true (execution finished)\n\n# Status predicates (execution outcome)\nresult.success?     #=&gt; true (successful execution)\nresult.failed?      #=&gt; false (no failure)\nresult.skipped?     #=&gt; false (not skipped)\n\n# Outcome categorization\nresult.good?        #=&gt; true (success or skipped)\nresult.bad?         #=&gt; false (skipped or failed)\n\n# Rollback Status\nresult.rolled_back? #=&gt; true (execution was rolled back)\n</code></pre>"},{"location":"outcomes/result/#outcome-analysis","title":"Outcome Analysis","text":"<p>Get a unified outcome string combining state and status:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\nresult.outcome #=&gt; \"success\" (state and status)\n</code></pre>"},{"location":"outcomes/result/#chain-analysis","title":"Chain Analysis","text":"<p>Trace fault origins and propagation:</p> <pre><code>result = DeploymentWorkflow.execute(app_name: \"webapp\")\n\nif result.failed?\n  # Find the original cause of failure\n  if original_failure = result.caused_failure\n    puts \"Root cause: #{original_failure.task.class.name}\"\n    puts \"Reason: #{original_failure.reason}\"\n  end\n\n  # Find what threw the failure to this result\n  if throwing_task = result.threw_failure\n    puts \"Failure source: #{throwing_task.task.class.name}\"\n    puts \"Reason: #{throwing_task.reason}\"\n  end\n\n  # Failure classification\n  result.caused_failure?  #=&gt; true if this result was the original cause\n  result.threw_failure?   #=&gt; true if this result threw a failure\n  result.thrown_failure?  #=&gt; true if this result received a thrown failure\nend\n</code></pre>"},{"location":"outcomes/result/#index-and-position","title":"Index and Position","text":"<p>Results track their position within execution chains:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Position in execution sequence\nresult.index #=&gt; 0 (first task in chain)\n\n# Access via chain\nresult.chain.results[result.index] == result #=&gt; true\n</code></pre>"},{"location":"outcomes/result/#block-yield","title":"Block Yield","text":"<p>Execute code with direct result access:</p> <pre><code>BuildApplication.execute(version: \"1.2.3\") do |result|\n  if result.success?\n    notify_deployment_ready(result)\n  elsif result.failed?\n    handle_build_failure(result)\n  else\n    log_skip_reason(result)\n  end\nend\n</code></pre>"},{"location":"outcomes/result/#handlers","title":"Handlers","text":"<p>Handle outcomes with functional-style methods. Handlers return the result for chaining:</p> <pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\n# Status-based handlers\nresult\n  .on(:success) { |result| notify_deployment_ready(result) }\n  .on(:failed) { |result| handle_build_failure(result) }\n  .on(:skipped) { |result| log_skip_reason(result) }\n\n# State-based handlers\nresult\n  .on(:complete) { |result| update_build_status(result) }\n  .on(:interrupted) { |result| cleanup_partial_artifacts(result) }\n  .on(:executed) { |result| alert_operations_team(result) } #=&gt; .on(:complete, :interrupted)\n\n# Outcome-based handlers\nresult\n  .on(:good) { |result| increment_success_counter(result) } #=&gt; .on(:success, :skipped)\n  .on(:bad) { |result| alert_operations_team(result) }      #=&gt; .on(:failed, :skipped)\n</code></pre>"},{"location":"outcomes/result/#pattern-matching","title":"Pattern Matching","text":"<p>Use Ruby 3.0+ pattern matching for elegant outcome handling:</p> <p>Important</p> <p>Pattern matching works with both array and hash deconstruction.</p>"},{"location":"outcomes/result/#array-pattern","title":"Array Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin [\"complete\", \"success\"]\n  redirect_to build_success_page\nin [\"interrupted\", \"failed\"]\n  retry_build_with_backoff(result)\nin [\"interrupted\", \"skipped\"]\n  log_skip_and_continue\nend\n</code></pre>"},{"location":"outcomes/result/#hash-pattern","title":"Hash Pattern","text":"<pre><code>result = BuildApplication.execute(version: \"1.2.3\")\n\ncase result\nin { state: \"complete\", status: \"success\" }\n  celebrate_build_success\nin { status: \"failed\", metadata: { retryable: true } }\n  schedule_build_retry(result)\nin { bad: true, metadata: { reason: String =&gt; reason } }\n  escalate_build_error(\"Build failed: #{reason}\")\nend\n</code></pre>"},{"location":"outcomes/result/#pattern-guards","title":"Pattern Guards","text":"<pre><code>case result\nin { status: \"failed\", metadata: { attempts: n } } if n &lt; 3\n  retry_build_with_delay(result, n * 2)\nin { status: \"failed\", metadata: { attempts: n } } if n &gt;= 3\n  mark_build_permanently_failed(result)\nin { runtime: time } if time &gt; performance_threshold\n  investigate_build_performance(result)\nend\n</code></pre>"},{"location":"outcomes/states/","title":"Outcomes - States","text":"<p>States track where a task is in its execution lifecycle\u2014from creation through completion or interruption.</p>"},{"location":"outcomes/states/#definitions","title":"Definitions","text":"State Description <code>initialized</code> Task created but execution not yet started. Default state for new tasks. <code>executing</code> Task is actively running its business logic. Transient state during execution. <code>complete</code> Task finished execution successfully without any interruption or halt. <code>interrupted</code> Task execution was stopped due to a fault, exception, or explicit halt. <p>State-Status combinations:</p> State Status Meaning <code>initialized</code> <code>success</code> Task created, not yet executed <code>executing</code> <code>success</code> Task currently running <code>complete</code> <code>success</code> Task finished successfully <code>complete</code> <code>skipped</code> Task finished by skipping execution <code>interrupted</code> <code>failed</code> Task stopped due to failure <code>interrupted</code> <code>skipped</code> Task stopped by skip condition"},{"location":"outcomes/states/#transitions","title":"Transitions","text":"<p>Caution</p> <p>States are managed automatically\u2014never modify them manually.</p> <pre><code># Valid state transition flow\ninitialized \u2192 executing \u2192 complete    (successful execution)\ninitialized \u2192 executing \u2192 interrupted (skipped/failed execution)\n</code></pre>"},{"location":"outcomes/states/#predicates","title":"Predicates","text":"<p>Use state predicates to check the current execution lifecycle:</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state checks\nresult.initialized? #=&gt; false (after execution)\nresult.executing?   #=&gt; false (after execution)\nresult.complete?    #=&gt; true (successful completion)\nresult.interrupted? #=&gt; false (no interruption)\n\n# State categorization\nresult.executed?    #=&gt; true (complete OR interrupted)\n</code></pre>"},{"location":"outcomes/states/#handlers","title":"Handlers","text":"<p>Handle lifecycle events with state-based handlers. Use <code>on(:executed)</code> for cleanup that runs regardless of outcome:</p> <pre><code>result = ProcessVideoUpload.execute\n\n# Individual state handlers\nresult\n  .on(:complete) { |result| send_upload_notification(result) }\n  .on(:interrupted) { |result| cleanup_temp_files(result) }\n  .on(:executed) { |result| log_upload_metrics(result) } #=&gt; .on(:complete, :interrupted)\n</code></pre>"},{"location":"outcomes/statuses/","title":"Outcomes - Statuses","text":"<p>Statuses represent the business outcome\u2014did the task succeed, skip, or fail? This differs from state, which tracks the execution lifecycle.</p>"},{"location":"outcomes/statuses/#definitions","title":"Definitions","text":"Status Description <code>success</code> Task execution completed successfully with expected business outcome. Default status for all tasks. <code>skipped</code> Task intentionally stopped execution because conditions weren't met or continuation was unnecessary. <code>failed</code> Task stopped execution due to business rule violations, validation errors, or exceptions."},{"location":"outcomes/statuses/#transitions","title":"Transitions","text":"<p>Important</p> <p>Status transitions are final and unidirectional. Once skipped or failed, tasks can't return to success.</p> <pre><code># Valid status transitions\nsuccess \u2192 skipped    # via skip!\nsuccess \u2192 failed     # via fail! or exception\n\n# Invalid transitions (will raise errors)\nskipped \u2192 success    # \u274c Cannot transition\nskipped \u2192 failed     # \u274c Cannot transition\nfailed \u2192 success     # \u274c Cannot transition\nfailed \u2192 skipped     # \u274c Cannot transition\n</code></pre>"},{"location":"outcomes/statuses/#predicates","title":"Predicates","text":"<p>Use status predicates to check execution outcomes:</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status checks\nresult.success? #=&gt; true/false\nresult.skipped? #=&gt; true/false\nresult.failed?  #=&gt; true/false\n\n# Outcome categorization\nresult.good?    #=&gt; true if success OR skipped\nresult.bad?     #=&gt; true if skipped OR failed (not success)\n</code></pre>"},{"location":"outcomes/statuses/#handlers","title":"Handlers","text":"<p>Branch business logic with status-based handlers. Use <code>on(:good)</code> and <code>on(:bad)</code> for success/skip vs failed outcomes:</p> <pre><code>result = ProcessNotification.execute\n\n# Individual status handlers\nresult\n  .on(:success) { |result| mark_notification_sent(result) }\n  .on(:skipped) { |result| log_notification_skipped(result) }\n  .on(:failed){ |result| queue_retry_notification(result) }\n\n# Outcome-based handlers\nresult\n  .on(:good) { |result| update_message_stats(result) }  #=&gt; .on(:success, :skipped)\n  .on(:bad) { |result| track_delivery_failure(result) } #=&gt; .on(:failed, :skipped)\n</code></pre>"},{"location":"blog/archive/2025/","title":"January 2025","text":""},{"location":"blog/category/tutorials/","title":"Tutorials","text":""}]}