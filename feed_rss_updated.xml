<?xml version="1.0" encoding="UTF-8" ?> <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel> <title>CMDx</title><description>Build business logic that&#39;s powerful, predictable, and maintainable.</description><link>https://drexed.github.io/cmdx/</link><atom:link href="https://drexed.github.io/cmdx/feed_rss_updated.xml" rel="self" type="application/rss+xml" /> <managingEditor>drexed</managingEditor><docs>https://github.com/drexed/cmdx</docs><language>en</language> <pubDate>Mon, 23 Feb 2026 18:05:21 -0000</pubDate> <lastBuildDate>Mon, 23 Feb 2026 18:05:21 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.17.9</generator> <image> <url>None</url> <title>CMDx</title> <link>https://drexed.github.io/cmdx/</link> </image> <item> <title>Mastering CMDx: Retries, Deprecation, and Internationalization</title> <author>drexed</author> <category>Tutorials</category> <description>&lt;h1&gt;Mastering CMDx: Retries, Deprecation, and Internationalization&lt;/h1&gt; &lt;p&gt;As developers, we often obsess over the &#34;happy path&#34;—that perfect scenario where networks never time out, requirements never change, and every user speaks English. But the real world isn&#39;t so accommodating. Services fail, code evolves, and your application needs to speak more than just one language.&lt;/p&gt; &lt;p&gt;In this post, I want to dive into three CMDx features that help you handle these realities: &lt;strong&gt;Retries&lt;/strong&gt; for resilience, &lt;strong&gt;Deprecation&lt;/strong&gt; for lifecycle management, and &lt;strong&gt;Internationalization&lt;/strong&gt; for global reach. These tools might seem distinct, but together they elevate your business logic from &#34;functional&#34; to &#34;production-grade.&#34;&lt;/p&gt;</description> <link>https://drexed.github.io/cmdx/blog/mastering-cmdx-retries-deprecation-i18n/</link> <pubDate>Fri, 06 Feb 2026 18:39:29 +0000</pubDate> <source url="https://drexed.github.io/cmdx/feed_rss_updated.xml">CMDx</source><guid isPermaLink="true">https://drexed.github.io/cmdx/blog/mastering-cmdx-retries-deprecation-i18n/</guid> </item> <item> <title>Mastering CMDx Attributes: Your Task&#39;s Contract with the World</title> <author>drexed</author> <category>Tutorials</category> <description>&lt;h1&gt;Mastering CMDx Attributes: Your Task&#39;s Contract with the World&lt;/h1&gt; &lt;p&gt;Attributes in CMDx are deceptively simple. You define what data your task needs, and the framework handles the rest—coercion, validation, defaults, the works. But there&#39;s real depth here. After building dozens of production systems with CMDx, I&#39;ve found that well-designed attributes are the difference between tasks that &#34;just work&#34; and tasks that fight you at every turn.&lt;/p&gt; &lt;p&gt;Let me show you what I mean.&lt;/p&gt;</description> <link>https://drexed.github.io/cmdx/blog/mastering-cmdx-attributes/</link> <pubDate>Tue, 13 Jan 2026 18:18:29 +0000</pubDate> <source url="https://drexed.github.io/cmdx/feed_rss_updated.xml">CMDx</source><guid isPermaLink="true">https://drexed.github.io/cmdx/blog/mastering-cmdx-attributes/</guid> </item> <item> <title>Mastering CMDx Callbacks and Middlewares: Hooks and Wrappers</title> <author>drexed</author> <category>Tutorials</category> <description>&lt;h1&gt;Mastering CMDx Callbacks and Middlewares: Hooks and Wrappers&lt;/h1&gt; &lt;p&gt;When I&#39;m writing complex business logic in Ruby, I often find that the core &#34;work&#34; is only half the battle. The other half is everything around it: logging, error handling, notifications, database transactions, and performance tracking.&lt;/p&gt; &lt;p&gt;If you put all that code inside your main method, you end up with a mess. That&#39;s where CMDx&#39;s &lt;strong&gt;Callbacks&lt;/strong&gt; and &lt;strong&gt;Middlewares&lt;/strong&gt; come in. They let you separate the &#34;what&#34; from the &#34;how&#34; and the &#34;when,&#34; keeping your tasks clean and focused.&lt;/p&gt; &lt;p&gt;Let&#39;s dive into how you can use these tools to write better service objects.&lt;/p&gt;</description> <link>https://drexed.github.io/cmdx/blog/mastering-cmdx-callbacks-and-middlewares/</link> <pubDate>Tue, 13 Jan 2026 18:18:29 +0000</pubDate> <source url="https://drexed.github.io/cmdx/feed_rss_updated.xml">CMDx</source><guid isPermaLink="true">https://drexed.github.io/cmdx/blog/mastering-cmdx-callbacks-and-middlewares/</guid> </item> <item> <title>Mastering CMDx Fundamentals: Tasks, Context, Execution, and Chains</title> <author>drexed</author> <category>Tutorials</category> <description>&lt;h1&gt;Mastering CMDx Fundamentals: Tasks, Context, Execution, and Chains&lt;/h1&gt; &lt;p&gt;When I first started building CMDx, I focused obsessively on four concepts: tasks, context, execution, and chains. These aren&#39;t just implementation details—they&#39;re the mental model that makes everything else click. Once you understand how they work together, you&#39;ll write cleaner business logic and debug issues faster.&lt;/p&gt; &lt;p&gt;Let me walk you through each piece, building from a simple task to a fully orchestrated task.&lt;/p&gt;</description> <link>https://drexed.github.io/cmdx/blog/mastering-cmdx-fundamentals/</link> <pubDate>Tue, 13 Jan 2026 18:18:29 +0000</pubDate> <source url="https://drexed.github.io/cmdx/feed_rss_updated.xml">CMDx</source><guid isPermaLink="true">https://drexed.github.io/cmdx/blog/mastering-cmdx-fundamentals/</guid> </item> <item> <title>Mastering CMDx Interruptions: Controlling Flow When Things Go Sideways</title> <author>drexed</author> <category>Tutorials</category> <description>&lt;h1&gt;Mastering CMDx Interruptions: Controlling Flow When Things Go Sideways&lt;/h1&gt; &lt;p&gt;Business logic isn&#39;t always a straight line. Orders get cancelled. Users don&#39;t have permissions. External APIs timeout. What separates robust code from fragile code is how gracefully you handle these interruptions.&lt;/p&gt; &lt;p&gt;CMDx gives you three tools for this: halt methods (&lt;code&gt;skip!&lt;/code&gt; and &lt;code&gt;fail!&lt;/code&gt;), exception handling, and faults. Together, they form a complete system for controlling execution flow—whether you&#39;re stopping intentionally, handling errors, or propagating failures across tasks.&lt;/p&gt;</description> <link>https://drexed.github.io/cmdx/blog/mastering-cmdx-interruptions/</link> <pubDate>Tue, 13 Jan 2026 18:18:29 +0000</pubDate> <source url="https://drexed.github.io/cmdx/feed_rss_updated.xml">CMDx</source><guid isPermaLink="true">https://drexed.github.io/cmdx/blog/mastering-cmdx-interruptions/</guid> </item> <item> <title>Mastering CMDx Outcomes: Results, States, and Statuses</title> <author>drexed</author> <category>Tutorials</category> <description>&lt;h1&gt;Mastering CMDx Outcomes: Results, States, and Statuses&lt;/h1&gt; &lt;p&gt;If you&#39;ve ever found yourself asking &#34;What does this service object actually return?&#34;, you&#39;re not alone. Does it return &lt;code&gt;true&lt;/code&gt;? The record it created? A hash with errors? Or does it just raise an exception and hope someone catches it?&lt;/p&gt; &lt;p&gt;In my experience, inconsistent return values are the silent killers of maintainable Ruby code. That&#39;s why CMDx standardizes everything into a single, powerful concept: the &lt;strong&gt;Result&lt;/strong&gt;.&lt;/p&gt;</description> <link>https://drexed.github.io/cmdx/blog/mastering-cmdx-outcomes/</link> <pubDate>Tue, 13 Jan 2026 18:18:29 +0000</pubDate> <source url="https://drexed.github.io/cmdx/feed_rss_updated.xml">CMDx</source><guid isPermaLink="true">https://drexed.github.io/cmdx/blog/mastering-cmdx-outcomes/</guid> </item> <item> <title>Mastering CMDx Workflows: Orchestrating Complex Business Logic</title> <author>drexed</author> <category>Tutorials</category> <description>&lt;h1&gt;Mastering CMDx Workflows: Orchestrating Complex Business Logic&lt;/h1&gt; &lt;p&gt;I remember when my service objects started getting messy. I&#39;d have a &lt;code&gt;PlaceOrder&lt;/code&gt; service that began as a simple 10-line script but slowly mutated into a 500-line monster handling validation, payments, inventory, shipping, and a dozen notification types. It was a nightmare to test and even harder to read.&lt;/p&gt; &lt;p&gt;That&#39;s exactly why I built CMDx Workflows. They allow you to decompose complex processes into small, focused tasks and orchestrate them declaratively. It turns your business logic from a tangled mess of &lt;code&gt;if&lt;/code&gt; statements into a clean, readable pipeline.&lt;/p&gt; &lt;p&gt;Let&#39;s dive into how workflows can transform your Ruby application&#39;s architecture.&lt;/p&gt;</description> <link>https://drexed.github.io/cmdx/blog/mastering-cmdx-workflows/</link> <pubDate>Tue, 13 Jan 2026 18:18:29 +0000</pubDate> <source url="https://drexed.github.io/cmdx/feed_rss_updated.xml">CMDx</source><guid isPermaLink="true">https://drexed.github.io/cmdx/blog/mastering-cmdx-workflows/</guid> </item> <item> <title>Getting Started with CMDx: Taming Business Logic in Ruby</title> <author>drexed</author> <category>Tutorials</category> <description>&lt;h1&gt;Getting Started with CMDx: Taming Business Logic in Ruby&lt;/h1&gt; &lt;p&gt;I&#39;ve spent years wrestling with service objects. You know the pattern—create a class, throw some business logic in a &lt;code&gt;call&lt;/code&gt; method, cross your fingers, and hope for the best. The problem? Every team member writes them differently. Every project invents its own conventions. And when something breaks at 2 AM, good luck tracing what actually happened.&lt;/p&gt; &lt;p&gt;That frustration led me to create CMDx.&lt;/p&gt;</description> <link>https://drexed.github.io/cmdx/blog/getting-started-with-cmdx/</link> <pubDate>Fri, 09 Jan 2026 22:03:27 +0000</pubDate> <source url="https://drexed.github.io/cmdx/feed_rss_updated.xml">CMDx</source><guid isPermaLink="true">https://drexed.github.io/cmdx/blog/getting-started-with-cmdx/</guid> </item> </channel> </rss>